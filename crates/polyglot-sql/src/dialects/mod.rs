//! SQL Dialect System
//!
//! This module implements the dialect abstraction layer that enables SQL transpilation
//! between 30+ database engines. Each dialect encapsulates three concerns:
//!
//! - **Tokenization**: Dialect-specific lexing rules (e.g., BigQuery uses backtick quoting,
//!   MySQL uses backtick for identifiers, TSQL uses square brackets).
//! - **Generation**: How AST nodes are rendered back to SQL text, including identifier quoting
//!   style, function name casing, and syntax variations.
//! - **Transformation**: AST-level rewrites that convert dialect-specific constructs to/from
//!   a normalized form (e.g., Snowflake `SQUARE(x)` becomes `POWER(x, 2)`).
//!
//! The primary entry point is [`Dialect::get`], which returns a configured [`Dialect`] instance
//! for a given [`DialectType`]. From there, callers can [`parse`](Dialect::parse),
//! [`generate`](Dialect::generate), [`transform`](Dialect::transform), or
//! [`transpile_to`](Dialect::transpile_to) another dialect in a single call.
//!
//! Each concrete dialect (e.g., `PostgresDialect`, `BigQueryDialect`) implements the
//! [`DialectImpl`] trait, which provides configuration hooks and expression-level transforms.
//! Dialect modules live in submodules of this module and are re-exported here.

mod generic; // Always compiled

#[cfg(feature = "dialect-athena")]
mod athena;
#[cfg(feature = "dialect-bigquery")]
mod bigquery;
#[cfg(feature = "dialect-clickhouse")]
mod clickhouse;
#[cfg(feature = "dialect-cockroachdb")]
mod cockroachdb;
#[cfg(feature = "dialect-databricks")]
mod databricks;
#[cfg(feature = "dialect-datafusion")]
mod datafusion;
#[cfg(feature = "dialect-doris")]
mod doris;
#[cfg(feature = "dialect-dremio")]
mod dremio;
#[cfg(feature = "dialect-drill")]
mod drill;
#[cfg(feature = "dialect-druid")]
mod druid;
#[cfg(feature = "dialect-duckdb")]
mod duckdb;
#[cfg(feature = "dialect-dune")]
mod dune;
#[cfg(feature = "dialect-exasol")]
mod exasol;
#[cfg(feature = "dialect-fabric")]
mod fabric;
#[cfg(feature = "dialect-hive")]
mod hive;
#[cfg(feature = "dialect-materialize")]
mod materialize;
#[cfg(feature = "dialect-mysql")]
mod mysql;
#[cfg(feature = "dialect-oracle")]
mod oracle;
#[cfg(feature = "dialect-postgresql")]
mod postgres;
#[cfg(feature = "dialect-presto")]
mod presto;
#[cfg(feature = "dialect-redshift")]
mod redshift;
#[cfg(feature = "dialect-risingwave")]
mod risingwave;
#[cfg(feature = "dialect-singlestore")]
mod singlestore;
#[cfg(feature = "dialect-snowflake")]
mod snowflake;
#[cfg(feature = "dialect-solr")]
mod solr;
#[cfg(feature = "dialect-spark")]
mod spark;
#[cfg(feature = "dialect-sqlite")]
mod sqlite;
#[cfg(feature = "dialect-starrocks")]
mod starrocks;
#[cfg(feature = "dialect-tableau")]
mod tableau;
#[cfg(feature = "dialect-teradata")]
mod teradata;
#[cfg(feature = "dialect-tidb")]
mod tidb;
#[cfg(feature = "dialect-trino")]
mod trino;
#[cfg(feature = "dialect-tsql")]
mod tsql;

pub use generic::GenericDialect; // Always available

#[cfg(feature = "dialect-athena")]
pub use athena::AthenaDialect;
#[cfg(feature = "dialect-bigquery")]
pub use bigquery::BigQueryDialect;
#[cfg(feature = "dialect-clickhouse")]
pub use clickhouse::ClickHouseDialect;
#[cfg(feature = "dialect-cockroachdb")]
pub use cockroachdb::CockroachDBDialect;
#[cfg(feature = "dialect-databricks")]
pub use databricks::DatabricksDialect;
#[cfg(feature = "dialect-datafusion")]
pub use datafusion::DataFusionDialect;
#[cfg(feature = "dialect-doris")]
pub use doris::DorisDialect;
#[cfg(feature = "dialect-dremio")]
pub use dremio::DremioDialect;
#[cfg(feature = "dialect-drill")]
pub use drill::DrillDialect;
#[cfg(feature = "dialect-druid")]
pub use druid::DruidDialect;
#[cfg(feature = "dialect-duckdb")]
pub use duckdb::DuckDBDialect;
#[cfg(feature = "dialect-dune")]
pub use dune::DuneDialect;
#[cfg(feature = "dialect-exasol")]
pub use exasol::ExasolDialect;
#[cfg(feature = "dialect-fabric")]
pub use fabric::FabricDialect;
#[cfg(feature = "dialect-hive")]
pub use hive::HiveDialect;
#[cfg(feature = "dialect-materialize")]
pub use materialize::MaterializeDialect;
#[cfg(feature = "dialect-mysql")]
pub use mysql::MySQLDialect;
#[cfg(feature = "dialect-oracle")]
pub use oracle::OracleDialect;
#[cfg(feature = "dialect-postgresql")]
pub use postgres::PostgresDialect;
#[cfg(feature = "dialect-presto")]
pub use presto::PrestoDialect;
#[cfg(feature = "dialect-redshift")]
pub use redshift::RedshiftDialect;
#[cfg(feature = "dialect-risingwave")]
pub use risingwave::RisingWaveDialect;
#[cfg(feature = "dialect-singlestore")]
pub use singlestore::SingleStoreDialect;
#[cfg(feature = "dialect-snowflake")]
pub use snowflake::SnowflakeDialect;
#[cfg(feature = "dialect-solr")]
pub use solr::SolrDialect;
#[cfg(feature = "dialect-spark")]
pub use spark::SparkDialect;
#[cfg(feature = "dialect-sqlite")]
pub use sqlite::SQLiteDialect;
#[cfg(feature = "dialect-starrocks")]
pub use starrocks::StarRocksDialect;
#[cfg(feature = "dialect-tableau")]
pub use tableau::TableauDialect;
#[cfg(feature = "dialect-teradata")]
pub use teradata::TeradataDialect;
#[cfg(feature = "dialect-tidb")]
pub use tidb::TiDBDialect;
#[cfg(feature = "dialect-trino")]
pub use trino::TrinoDialect;
#[cfg(feature = "dialect-tsql")]
pub use tsql::TSQLDialect;

use crate::error::Result;
use crate::expressions::{Expression, FunctionBody};
use crate::generator::{Generator, GeneratorConfig};
use crate::parser::Parser;
use crate::tokens::{Token, Tokenizer, TokenizerConfig};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::{Arc, LazyLock, RwLock};

/// Enumeration of all supported SQL dialects.
///
/// Each variant corresponds to a specific SQL database engine or query language.
/// The `Generic` variant represents standard SQL with no dialect-specific behavior,
/// and is used as the default when no dialect is specified.
///
/// Dialect names are case-insensitive when parsed from strings via [`FromStr`].
/// Some dialects accept aliases (e.g., "mssql" and "sqlserver" both resolve to [`TSQL`](DialectType::TSQL)).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum DialectType {
    /// Standard SQL with no dialect-specific behavior (default).
    Generic,
    /// PostgreSQL -- advanced open-source relational database.
    PostgreSQL,
    /// MySQL -- widely-used open-source relational database (also accepts "mysql").
    MySQL,
    /// Google BigQuery -- serverless cloud data warehouse with unique syntax (backtick quoting, STRUCT types, QUALIFY).
    BigQuery,
    /// Snowflake -- cloud data platform with QUALIFY clause, FLATTEN, and variant types.
    Snowflake,
    /// DuckDB -- in-process analytical database with modern SQL extensions.
    DuckDB,
    /// SQLite -- lightweight embedded relational database.
    SQLite,
    /// Apache Hive -- data warehouse on Hadoop with HiveQL syntax.
    Hive,
    /// Apache Spark SQL -- distributed query engine (also accepts "spark2").
    Spark,
    /// Trino -- distributed SQL query engine (formerly PrestoSQL).
    Trino,
    /// PrestoDB -- distributed SQL query engine for big data.
    Presto,
    /// Amazon Redshift -- cloud data warehouse based on PostgreSQL.
    Redshift,
    /// Transact-SQL (T-SQL) -- Microsoft SQL Server and Azure SQL (also accepts "mssql", "sqlserver").
    TSQL,
    /// Oracle Database -- commercial relational database with PL/SQL extensions.
    Oracle,
    /// ClickHouse -- column-oriented OLAP database for real-time analytics.
    ClickHouse,
    /// Databricks SQL -- Spark-based lakehouse platform with QUALIFY support.
    Databricks,
    /// Amazon Athena -- serverless query service (hybrid Trino/Hive engine).
    Athena,
    /// Teradata -- enterprise data warehouse with proprietary SQL extensions.
    Teradata,
    /// Apache Doris -- real-time analytical database (MySQL-compatible).
    Doris,
    /// StarRocks -- sub-second OLAP database (MySQL-compatible).
    StarRocks,
    /// Materialize -- streaming SQL database built on differential dataflow.
    Materialize,
    /// RisingWave -- distributed streaming database with PostgreSQL compatibility.
    RisingWave,
    /// SingleStore (formerly MemSQL) -- distributed SQL database (also accepts "memsql").
    SingleStore,
    /// CockroachDB -- distributed SQL database with PostgreSQL compatibility (also accepts "cockroach").
    CockroachDB,
    /// TiDB -- distributed HTAP database with MySQL compatibility.
    TiDB,
    /// Apache Druid -- real-time analytics database.
    Druid,
    /// Apache Solr -- search platform with SQL interface.
    Solr,
    /// Tableau -- data visualization platform with its own SQL dialect.
    Tableau,
    /// Dune Analytics -- blockchain analytics SQL engine.
    Dune,
    /// Microsoft Fabric -- unified analytics platform (T-SQL based).
    Fabric,
    /// Apache Drill -- schema-free SQL query engine for big data.
    Drill,
    /// Dremio -- data lakehouse platform with Arrow-based query engine.
    Dremio,
    /// Exasol -- in-memory analytic database.
    Exasol,
    /// Apache DataFusion -- Arrow-based query engine with modern SQL extensions.
    DataFusion,
}

impl Default for DialectType {
    fn default() -> Self {
        DialectType::Generic
    }
}

impl std::fmt::Display for DialectType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DialectType::Generic => write!(f, "generic"),
            DialectType::PostgreSQL => write!(f, "postgresql"),
            DialectType::MySQL => write!(f, "mysql"),
            DialectType::BigQuery => write!(f, "bigquery"),
            DialectType::Snowflake => write!(f, "snowflake"),
            DialectType::DuckDB => write!(f, "duckdb"),
            DialectType::SQLite => write!(f, "sqlite"),
            DialectType::Hive => write!(f, "hive"),
            DialectType::Spark => write!(f, "spark"),
            DialectType::Trino => write!(f, "trino"),
            DialectType::Presto => write!(f, "presto"),
            DialectType::Redshift => write!(f, "redshift"),
            DialectType::TSQL => write!(f, "tsql"),
            DialectType::Oracle => write!(f, "oracle"),
            DialectType::ClickHouse => write!(f, "clickhouse"),
            DialectType::Databricks => write!(f, "databricks"),
            DialectType::Athena => write!(f, "athena"),
            DialectType::Teradata => write!(f, "teradata"),
            DialectType::Doris => write!(f, "doris"),
            DialectType::StarRocks => write!(f, "starrocks"),
            DialectType::Materialize => write!(f, "materialize"),
            DialectType::RisingWave => write!(f, "risingwave"),
            DialectType::SingleStore => write!(f, "singlestore"),
            DialectType::CockroachDB => write!(f, "cockroachdb"),
            DialectType::TiDB => write!(f, "tidb"),
            DialectType::Druid => write!(f, "druid"),
            DialectType::Solr => write!(f, "solr"),
            DialectType::Tableau => write!(f, "tableau"),
            DialectType::Dune => write!(f, "dune"),
            DialectType::Fabric => write!(f, "fabric"),
            DialectType::Drill => write!(f, "drill"),
            DialectType::Dremio => write!(f, "dremio"),
            DialectType::Exasol => write!(f, "exasol"),
            DialectType::DataFusion => write!(f, "datafusion"),
        }
    }
}

impl std::str::FromStr for DialectType {
    type Err = crate::error::Error;

    fn from_str(s: &str) -> Result<Self> {
        match s.to_lowercase().as_str() {
            "generic" | "" => Ok(DialectType::Generic),
            "postgres" | "postgresql" => Ok(DialectType::PostgreSQL),
            "mysql" => Ok(DialectType::MySQL),
            "bigquery" => Ok(DialectType::BigQuery),
            "snowflake" => Ok(DialectType::Snowflake),
            "duckdb" => Ok(DialectType::DuckDB),
            "sqlite" => Ok(DialectType::SQLite),
            "hive" => Ok(DialectType::Hive),
            "spark" | "spark2" => Ok(DialectType::Spark),
            "trino" => Ok(DialectType::Trino),
            "presto" => Ok(DialectType::Presto),
            "redshift" => Ok(DialectType::Redshift),
            "tsql" | "mssql" | "sqlserver" => Ok(DialectType::TSQL),
            "oracle" => Ok(DialectType::Oracle),
            "clickhouse" => Ok(DialectType::ClickHouse),
            "databricks" => Ok(DialectType::Databricks),
            "athena" => Ok(DialectType::Athena),
            "teradata" => Ok(DialectType::Teradata),
            "doris" => Ok(DialectType::Doris),
            "starrocks" => Ok(DialectType::StarRocks),
            "materialize" => Ok(DialectType::Materialize),
            "risingwave" => Ok(DialectType::RisingWave),
            "singlestore" | "memsql" => Ok(DialectType::SingleStore),
            "cockroachdb" | "cockroach" => Ok(DialectType::CockroachDB),
            "tidb" => Ok(DialectType::TiDB),
            "druid" => Ok(DialectType::Druid),
            "solr" => Ok(DialectType::Solr),
            "tableau" => Ok(DialectType::Tableau),
            "dune" => Ok(DialectType::Dune),
            "fabric" => Ok(DialectType::Fabric),
            "drill" => Ok(DialectType::Drill),
            "dremio" => Ok(DialectType::Dremio),
            "exasol" => Ok(DialectType::Exasol),
            "datafusion" | "arrow-datafusion" | "arrow_datafusion" => Ok(DialectType::DataFusion),
            _ => Err(crate::error::Error::parse(
                format!("Unknown dialect: {}", s),
                0,
                0,
            )),
        }
    }
}

/// Trait that each concrete SQL dialect must implement.
///
/// `DialectImpl` provides the configuration hooks and per-expression transform logic
/// that distinguish one dialect from another. Implementors supply:
///
/// - A [`DialectType`] identifier.
/// - Optional overrides for tokenizer and generator configuration (defaults to generic SQL).
/// - An expression-level transform function ([`transform_expr`](DialectImpl::transform_expr))
///   that rewrites individual AST nodes for this dialect (e.g., converting `NVL` to `COALESCE`).
/// - An optional preprocessing step ([`preprocess`](DialectImpl::preprocess)) for whole-tree
///   rewrites that must run before the recursive per-node transform (e.g., eliminating QUALIFY).
///
/// The default implementations are no-ops, so a minimal dialect only needs to provide
/// [`dialect_type`](DialectImpl::dialect_type) and override the methods that differ from
/// standard SQL.
pub trait DialectImpl {
    /// Returns the [`DialectType`] that identifies this dialect.
    fn dialect_type(&self) -> DialectType;

    /// Returns the tokenizer configuration for this dialect.
    ///
    /// Override to customize identifier quoting characters, string escape rules,
    /// comment styles, and other lexing behavior.
    fn tokenizer_config(&self) -> TokenizerConfig {
        TokenizerConfig::default()
    }

    /// Returns the generator configuration for this dialect.
    ///
    /// Override to customize identifier quoting style, function name casing,
    /// keyword casing, and other SQL generation behavior.
    fn generator_config(&self) -> GeneratorConfig {
        GeneratorConfig::default()
    }

    /// Returns a generator configuration tailored to a specific expression.
    ///
    /// Override this for hybrid dialects like Athena that route to different SQL engines
    /// based on expression type (e.g., Hive-style generation for DDL, Trino-style for DML).
    /// The default delegates to [`generator_config`](DialectImpl::generator_config).
    fn generator_config_for_expr(&self, _expr: &Expression) -> GeneratorConfig {
        self.generator_config()
    }

    /// Transforms a single expression node for this dialect, without recursing into children.
    ///
    /// This is the per-node rewrite hook invoked by [`transform_recursive`]. Return the
    /// expression unchanged if no dialect-specific rewrite is needed. Transformations
    /// typically include function renaming, operator substitution, and type mapping.
    fn transform_expr(&self, expr: Expression) -> Result<Expression> {
        Ok(expr)
    }

    /// Applies whole-tree preprocessing transforms before the recursive per-node pass.
    ///
    /// Override this to apply structural rewrites that must see the entire tree at once,
    /// such as `eliminate_qualify`, `eliminate_distinct_on`, `ensure_bools`, or
    /// `explode_projection_to_unnest`. The default is a no-op pass-through.
    fn preprocess(&self, expr: Expression) -> Result<Expression> {
        Ok(expr)
    }
}

/// Recursively transforms a [`DataType`](crate::expressions::DataType), handling nested
/// parametric types such as `ARRAY<INT>`, `STRUCT<a INT, b TEXT>`, and `MAP<STRING, INT>`.
///
/// The outer type is first passed through `transform_fn` as an `Expression::DataType`,
/// and then nested element/field types are recursed into. This ensures that dialect-level
/// type mappings (e.g., `INT` to `INTEGER`) propagate into complex nested types.
fn transform_data_type_recursive<F>(
    dt: crate::expressions::DataType,
    transform_fn: &F,
) -> Result<crate::expressions::DataType>
where
    F: Fn(Expression) -> Result<Expression>,
{
    use crate::expressions::DataType;
    // First, transform the outermost type through the expression system
    let dt_expr = transform_fn(Expression::DataType(dt))?;
    let dt = match dt_expr {
        Expression::DataType(d) => d,
        _ => {
            return Ok(match dt_expr {
                _ => DataType::Custom {
                    name: "UNKNOWN".to_string(),
                },
            })
        }
    };
    // Then recurse into nested types
    match dt {
        DataType::Array {
            element_type,
            dimension,
        } => {
            let inner = transform_data_type_recursive(*element_type, transform_fn)?;
            Ok(DataType::Array {
                element_type: Box::new(inner),
                dimension,
            })
        }
        DataType::List { element_type } => {
            let inner = transform_data_type_recursive(*element_type, transform_fn)?;
            Ok(DataType::List {
                element_type: Box::new(inner),
            })
        }
        DataType::Struct { fields, nested } => {
            let mut new_fields = Vec::new();
            for mut field in fields {
                field.data_type = transform_data_type_recursive(field.data_type, transform_fn)?;
                new_fields.push(field);
            }
            Ok(DataType::Struct {
                fields: new_fields,
                nested,
            })
        }
        DataType::Map {
            key_type,
            value_type,
        } => {
            let k = transform_data_type_recursive(*key_type, transform_fn)?;
            let v = transform_data_type_recursive(*value_type, transform_fn)?;
            Ok(DataType::Map {
                key_type: Box::new(k),
                value_type: Box::new(v),
            })
        }
        other => Ok(other),
    }
}

/// Convert DuckDB C-style format strings to Presto C-style format strings.
/// DuckDB and Presto both use C-style % directives but with different specifiers for some cases.
fn duckdb_to_presto_format(fmt: &str) -> String {
    // Order matters: handle longer patterns first to avoid partial replacements
    let mut result = fmt.to_string();
    // First pass: mark multi-char patterns with placeholders
    result = result.replace("%-m", "\x01NOPADM\x01");
    result = result.replace("%-d", "\x01NOPADD\x01");
    result = result.replace("%-I", "\x01NOPADI\x01");
    result = result.replace("%-H", "\x01NOPADH\x01");
    result = result.replace("%H:%M:%S", "\x01HMS\x01");
    result = result.replace("%Y-%m-%d", "\x01YMD\x01");
    // Now convert individual specifiers
    result = result.replace("%M", "%i");
    result = result.replace("%S", "%s");
    // Restore multi-char patterns with Presto equivalents
    result = result.replace("\x01NOPADM\x01", "%c");
    result = result.replace("\x01NOPADD\x01", "%e");
    result = result.replace("\x01NOPADI\x01", "%l");
    result = result.replace("\x01NOPADH\x01", "%k");
    result = result.replace("\x01HMS\x01", "%T");
    result = result.replace("\x01YMD\x01", "%Y-%m-%d");
    result
}

/// Convert DuckDB C-style format strings to BigQuery format strings.
/// BigQuery uses a mix of strftime-like directives.
fn duckdb_to_bigquery_format(fmt: &str) -> String {
    let mut result = fmt.to_string();
    // Handle longer patterns first
    result = result.replace("%-d", "%e");
    result = result.replace("%Y-%m-%d %H:%M:%S", "%F %T");
    result = result.replace("%Y-%m-%d", "%F");
    result = result.replace("%H:%M:%S", "%T");
    result
}

/// Applies a transform function bottom-up through an entire expression tree.
///
/// This is the core tree-rewriting engine used by the dialect system. It performs
/// a post-order (children-first) traversal: for each node, all children are recursively
/// transformed before the node itself is passed to `transform_fn`. This bottom-up
/// strategy means that when `transform_fn` sees a node, its children have already
/// been rewritten, which simplifies pattern matching on sub-expressions.
///
/// The function handles all expression variants including SELECT clauses (FROM, WHERE,
/// GROUP BY, HAVING, ORDER BY, QUALIFY, WITH/CTEs, WINDOW), binary operators,
/// function calls, CASE expressions, date/time functions, and more.
///
/// # Arguments
///
/// * `expr` - The root expression to transform (consumed).
/// * `transform_fn` - A closure that receives each expression node (after its children
///   have been transformed) and returns a possibly-rewritten expression.
///
/// # Errors
///
/// Returns an error if `transform_fn` returns an error for any node.
pub fn transform_recursive<F>(expr: Expression, transform_fn: &F) -> Result<Expression>
where
    F: Fn(Expression) -> Result<Expression>,
{
    use crate::expressions::BinaryOp;

    // Helper macro to transform binary ops with Box<BinaryOp>
    macro_rules! transform_binary {
        ($variant:ident, $op:expr) => {{
            let left = transform_recursive($op.left, transform_fn)?;
            let right = transform_recursive($op.right, transform_fn)?;
            Expression::$variant(Box::new(BinaryOp {
                left,
                right,
                left_comments: $op.left_comments,
                operator_comments: $op.operator_comments,
                trailing_comments: $op.trailing_comments,
            }))
        }};
    }

    // First recursively transform children, then apply the transform function
    let expr = match expr {
        Expression::Select(mut select) => {
            select.expressions = select
                .expressions
                .into_iter()
                .map(|e| transform_recursive(e, transform_fn))
                .collect::<Result<Vec<_>>>()?;

            // Transform FROM clause
            if let Some(mut from) = select.from.take() {
                from.expressions = from
                    .expressions
                    .into_iter()
                    .map(|e| transform_recursive(e, transform_fn))
                    .collect::<Result<Vec<_>>>()?;
                select.from = Some(from);
            }

            // Transform JOINs - important for CROSS APPLY / LATERAL transformations
            select.joins = select
                .joins
                .into_iter()
                .map(|mut join| {
                    join.this = transform_recursive(join.this, transform_fn)?;
                    if let Some(on) = join.on.take() {
                        join.on = Some(transform_recursive(on, transform_fn)?);
                    }
                    // Wrap join in Expression::Join to allow transform_fn to transform it
                    match transform_fn(Expression::Join(Box::new(join)))? {
                        Expression::Join(j) => Ok(*j),
                        _ => Err(crate::error::Error::parse(
                            "Join transformation returned non-join expression",
                            0,
                            0,
                        )),
                    }
                })
                .collect::<Result<Vec<_>>>()?;

            // Transform LATERAL VIEW expressions (Hive/Spark)
            select.lateral_views = select
                .lateral_views
                .into_iter()
                .map(|mut lv| {
                    lv.this = transform_recursive(lv.this, transform_fn)?;
                    Ok(lv)
                })
                .collect::<Result<Vec<_>>>()?;

            // Transform WHERE clause
            if let Some(mut where_clause) = select.where_clause.take() {
                where_clause.this = transform_recursive(where_clause.this, transform_fn)?;
                select.where_clause = Some(where_clause);
            }

            // Transform GROUP BY
            if let Some(mut group_by) = select.group_by.take() {
                group_by.expressions = group_by
                    .expressions
                    .into_iter()
                    .map(|e| transform_recursive(e, transform_fn))
                    .collect::<Result<Vec<_>>>()?;
                select.group_by = Some(group_by);
            }

            // Transform HAVING
            if let Some(mut having) = select.having.take() {
                having.this = transform_recursive(having.this, transform_fn)?;
                select.having = Some(having);
            }

            // Transform WITH (CTEs)
            if let Some(mut with) = select.with.take() {
                with.ctes = with
                    .ctes
                    .into_iter()
                    .map(|mut cte| {
                        let original = cte.this.clone();
                        cte.this = transform_recursive(cte.this, transform_fn).unwrap_or(original);
                        cte
                    })
                    .collect();
                select.with = Some(with);
            }

            // Transform ORDER BY
            if let Some(mut order) = select.order_by.take() {
                order.expressions = order
                    .expressions
                    .into_iter()
                    .map(|o| {
                        let mut o = o;
                        let original = o.this.clone();
                        o.this = transform_recursive(o.this, transform_fn).unwrap_or(original);
                        // Also apply transform to the Ordered wrapper itself (for NULLS FIRST etc.)
                        match transform_fn(Expression::Ordered(Box::new(o.clone()))) {
                            Ok(Expression::Ordered(transformed)) => *transformed,
                            Ok(_) | Err(_) => o,
                        }
                    })
                    .collect();
                select.order_by = Some(order);
            }

            // Transform WINDOW clause order_by
            if let Some(ref mut windows) = select.windows {
                for nw in windows.iter_mut() {
                    nw.spec.order_by = std::mem::take(&mut nw.spec.order_by)
                        .into_iter()
                        .map(|o| {
                            let mut o = o;
                            let original = o.this.clone();
                            o.this = transform_recursive(o.this, transform_fn).unwrap_or(original);
                            match transform_fn(Expression::Ordered(Box::new(o.clone()))) {
                                Ok(Expression::Ordered(transformed)) => *transformed,
                                Ok(_) | Err(_) => o,
                            }
                        })
                        .collect();
                }
            }

            // Transform QUALIFY
            if let Some(mut qual) = select.qualify.take() {
                qual.this = transform_recursive(qual.this, transform_fn)?;
                select.qualify = Some(qual);
            }

            Expression::Select(select)
        }
        Expression::Function(mut f) => {
            f.args = f
                .args
                .into_iter()
                .map(|e| transform_recursive(e, transform_fn))
                .collect::<Result<Vec<_>>>()?;
            Expression::Function(f)
        }
        Expression::AggregateFunction(mut f) => {
            f.args = f
                .args
                .into_iter()
                .map(|e| transform_recursive(e, transform_fn))
                .collect::<Result<Vec<_>>>()?;
            if let Some(filter) = f.filter {
                f.filter = Some(transform_recursive(filter, transform_fn)?);
            }
            Expression::AggregateFunction(f)
        }
        Expression::WindowFunction(mut wf) => {
            wf.this = transform_recursive(wf.this, transform_fn)?;
            wf.over.partition_by = wf
                .over
                .partition_by
                .into_iter()
                .map(|e| transform_recursive(e, transform_fn))
                .collect::<Result<Vec<_>>>()?;
            // Transform order_by items through Expression::Ordered wrapper
            wf.over.order_by = wf
                .over
                .order_by
                .into_iter()
                .map(|o| {
                    let mut o = o;
                    o.this = transform_recursive(o.this, transform_fn)?;
                    match transform_fn(Expression::Ordered(Box::new(o)))? {
                        Expression::Ordered(transformed) => Ok(*transformed),
                        _ => Err(crate::error::Error::parse(
                            "Ordered transformation returned non-Ordered expression",
                            0,
                            0,
                        )),
                    }
                })
                .collect::<Result<Vec<_>>>()?;
            Expression::WindowFunction(wf)
        }
        Expression::Alias(mut a) => {
            a.this = transform_recursive(a.this, transform_fn)?;
            Expression::Alias(a)
        }
        Expression::Cast(mut c) => {
            c.this = transform_recursive(c.this, transform_fn)?;
            // Also transform the target data type (recursively for nested types like ARRAY<INT>, STRUCT<a INT>)
            c.to = transform_data_type_recursive(c.to, transform_fn)?;
            Expression::Cast(c)
        }
        Expression::And(op) => transform_binary!(And, *op),
        Expression::Or(op) => transform_binary!(Or, *op),
        Expression::Add(op) => transform_binary!(Add, *op),
        Expression::Sub(op) => transform_binary!(Sub, *op),
        Expression::Mul(op) => transform_binary!(Mul, *op),
        Expression::Div(op) => transform_binary!(Div, *op),
        Expression::Eq(op) => transform_binary!(Eq, *op),
        Expression::Lt(op) => transform_binary!(Lt, *op),
        Expression::Gt(op) => transform_binary!(Gt, *op),
        Expression::Paren(mut p) => {
            p.this = transform_recursive(p.this, transform_fn)?;
            Expression::Paren(p)
        }
        Expression::Coalesce(mut f) => {
            f.expressions = f
                .expressions
                .into_iter()
                .map(|e| transform_recursive(e, transform_fn))
                .collect::<Result<Vec<_>>>()?;
            Expression::Coalesce(f)
        }
        Expression::IfNull(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.expression = transform_recursive(f.expression, transform_fn)?;
            Expression::IfNull(f)
        }
        Expression::Nvl(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.expression = transform_recursive(f.expression, transform_fn)?;
            Expression::Nvl(f)
        }
        Expression::In(mut i) => {
            i.this = transform_recursive(i.this, transform_fn)?;
            i.expressions = i
                .expressions
                .into_iter()
                .map(|e| transform_recursive(e, transform_fn))
                .collect::<Result<Vec<_>>>()?;
            if let Some(query) = i.query {
                i.query = Some(transform_recursive(query, transform_fn)?);
            }
            Expression::In(i)
        }
        Expression::Not(mut n) => {
            n.this = transform_recursive(n.this, transform_fn)?;
            Expression::Not(n)
        }
        Expression::ArraySlice(mut s) => {
            s.this = transform_recursive(s.this, transform_fn)?;
            if let Some(start) = s.start {
                s.start = Some(transform_recursive(start, transform_fn)?);
            }
            if let Some(end) = s.end {
                s.end = Some(transform_recursive(end, transform_fn)?);
            }
            Expression::ArraySlice(s)
        }
        Expression::Subscript(mut s) => {
            s.this = transform_recursive(s.this, transform_fn)?;
            s.index = transform_recursive(s.index, transform_fn)?;
            Expression::Subscript(s)
        }
        Expression::Array(mut a) => {
            a.expressions = a
                .expressions
                .into_iter()
                .map(|e| transform_recursive(e, transform_fn))
                .collect::<Result<Vec<_>>>()?;
            Expression::Array(a)
        }
        Expression::Struct(mut s) => {
            let mut new_fields = Vec::new();
            for (name, expr) in s.fields {
                let transformed = transform_recursive(expr, transform_fn)?;
                new_fields.push((name, transformed));
            }
            s.fields = new_fields;
            Expression::Struct(s)
        }
        Expression::NamedArgument(mut na) => {
            na.value = transform_recursive(na.value, transform_fn)?;
            Expression::NamedArgument(na)
        }
        Expression::MapFunc(mut m) => {
            m.keys = m
                .keys
                .into_iter()
                .map(|e| transform_recursive(e, transform_fn))
                .collect::<Result<Vec<_>>>()?;
            m.values = m
                .values
                .into_iter()
                .map(|e| transform_recursive(e, transform_fn))
                .collect::<Result<Vec<_>>>()?;
            Expression::MapFunc(m)
        }
        Expression::ArrayFunc(mut a) => {
            a.expressions = a
                .expressions
                .into_iter()
                .map(|e| transform_recursive(e, transform_fn))
                .collect::<Result<Vec<_>>>()?;
            Expression::ArrayFunc(a)
        }
        Expression::Lambda(mut l) => {
            l.body = transform_recursive(l.body, transform_fn)?;
            Expression::Lambda(l)
        }
        Expression::JsonExtract(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.path = transform_recursive(f.path, transform_fn)?;
            Expression::JsonExtract(f)
        }
        Expression::JsonExtractScalar(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.path = transform_recursive(f.path, transform_fn)?;
            Expression::JsonExtractScalar(f)
        }

        // ===== UnaryFunc-based expressions =====
        // These all have a single `this: Expression` child
        Expression::Length(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::Length(f)
        }
        Expression::Upper(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::Upper(f)
        }
        Expression::Lower(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::Lower(f)
        }
        Expression::LTrim(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::LTrim(f)
        }
        Expression::RTrim(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::RTrim(f)
        }
        Expression::Reverse(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::Reverse(f)
        }
        Expression::Abs(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::Abs(f)
        }
        Expression::Ceil(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::Ceil(f)
        }
        Expression::Floor(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::Floor(f)
        }
        Expression::Sign(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::Sign(f)
        }
        Expression::Sqrt(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::Sqrt(f)
        }
        Expression::Cbrt(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::Cbrt(f)
        }
        Expression::Ln(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::Ln(f)
        }
        Expression::Log(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            if let Some(base) = f.base {
                f.base = Some(transform_recursive(base, transform_fn)?);
            }
            Expression::Log(f)
        }
        Expression::Exp(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::Exp(f)
        }
        Expression::Date(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::Date(f)
        }
        Expression::Stddev(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::Stddev(f)
        }
        Expression::Variance(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::Variance(f)
        }

        // ===== BinaryFunc-based expressions =====
        Expression::ModFunc(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.expression = transform_recursive(f.expression, transform_fn)?;
            Expression::ModFunc(f)
        }
        Expression::Power(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.expression = transform_recursive(f.expression, transform_fn)?;
            Expression::Power(f)
        }
        Expression::MapFromArrays(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.expression = transform_recursive(f.expression, transform_fn)?;
            Expression::MapFromArrays(f)
        }
        Expression::ElementAt(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.expression = transform_recursive(f.expression, transform_fn)?;
            Expression::ElementAt(f)
        }
        Expression::MapContainsKey(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.expression = transform_recursive(f.expression, transform_fn)?;
            Expression::MapContainsKey(f)
        }
        Expression::Left(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.length = transform_recursive(f.length, transform_fn)?;
            Expression::Left(f)
        }
        Expression::Right(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.length = transform_recursive(f.length, transform_fn)?;
            Expression::Right(f)
        }
        Expression::Repeat(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.times = transform_recursive(f.times, transform_fn)?;
            Expression::Repeat(f)
        }

        // ===== Complex function expressions =====
        Expression::Substring(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.start = transform_recursive(f.start, transform_fn)?;
            if let Some(len) = f.length {
                f.length = Some(transform_recursive(len, transform_fn)?);
            }
            Expression::Substring(f)
        }
        Expression::Replace(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.old = transform_recursive(f.old, transform_fn)?;
            f.new = transform_recursive(f.new, transform_fn)?;
            Expression::Replace(f)
        }
        Expression::ConcatWs(mut f) => {
            f.separator = transform_recursive(f.separator, transform_fn)?;
            f.expressions = f
                .expressions
                .into_iter()
                .map(|e| transform_recursive(e, transform_fn))
                .collect::<Result<Vec<_>>>()?;
            Expression::ConcatWs(f)
        }
        Expression::Trim(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            if let Some(chars) = f.characters {
                f.characters = Some(transform_recursive(chars, transform_fn)?);
            }
            Expression::Trim(f)
        }
        Expression::Split(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.delimiter = transform_recursive(f.delimiter, transform_fn)?;
            Expression::Split(f)
        }
        Expression::Lpad(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.length = transform_recursive(f.length, transform_fn)?;
            if let Some(fill) = f.fill {
                f.fill = Some(transform_recursive(fill, transform_fn)?);
            }
            Expression::Lpad(f)
        }
        Expression::Rpad(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.length = transform_recursive(f.length, transform_fn)?;
            if let Some(fill) = f.fill {
                f.fill = Some(transform_recursive(fill, transform_fn)?);
            }
            Expression::Rpad(f)
        }

        // ===== Conditional expressions =====
        Expression::Case(mut c) => {
            if let Some(operand) = c.operand {
                c.operand = Some(transform_recursive(operand, transform_fn)?);
            }
            c.whens = c
                .whens
                .into_iter()
                .map(|(cond, then)| {
                    let new_cond = transform_recursive(cond.clone(), transform_fn).unwrap_or(cond);
                    let new_then = transform_recursive(then.clone(), transform_fn).unwrap_or(then);
                    (new_cond, new_then)
                })
                .collect();
            if let Some(else_expr) = c.else_ {
                c.else_ = Some(transform_recursive(else_expr, transform_fn)?);
            }
            Expression::Case(c)
        }
        Expression::IfFunc(mut f) => {
            f.condition = transform_recursive(f.condition, transform_fn)?;
            f.true_value = transform_recursive(f.true_value, transform_fn)?;
            if let Some(false_val) = f.false_value {
                f.false_value = Some(transform_recursive(false_val, transform_fn)?);
            }
            Expression::IfFunc(f)
        }

        // ===== Date/Time expressions =====
        Expression::DateAdd(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.interval = transform_recursive(f.interval, transform_fn)?;
            Expression::DateAdd(f)
        }
        Expression::DateSub(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.interval = transform_recursive(f.interval, transform_fn)?;
            Expression::DateSub(f)
        }
        Expression::DateDiff(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.expression = transform_recursive(f.expression, transform_fn)?;
            Expression::DateDiff(f)
        }
        Expression::DateTrunc(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::DateTrunc(f)
        }
        Expression::Extract(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::Extract(f)
        }

        // ===== JSON expressions =====
        Expression::JsonObject(mut f) => {
            f.pairs = f
                .pairs
                .into_iter()
                .map(|(k, v)| {
                    let new_k = transform_recursive(k, transform_fn)?;
                    let new_v = transform_recursive(v, transform_fn)?;
                    Ok((new_k, new_v))
                })
                .collect::<Result<Vec<_>>>()?;
            Expression::JsonObject(f)
        }

        // ===== Subquery expressions =====
        Expression::Subquery(mut s) => {
            s.this = transform_recursive(s.this, transform_fn)?;
            Expression::Subquery(s)
        }
        Expression::Exists(mut e) => {
            e.this = transform_recursive(e.this, transform_fn)?;
            Expression::Exists(e)
        }

        // ===== Set operations =====
        Expression::Union(mut u) => {
            u.left = transform_recursive(u.left, transform_fn)?;
            u.right = transform_recursive(u.right, transform_fn)?;
            Expression::Union(u)
        }
        Expression::Intersect(mut i) => {
            i.left = transform_recursive(i.left, transform_fn)?;
            i.right = transform_recursive(i.right, transform_fn)?;
            Expression::Intersect(i)
        }
        Expression::Except(mut e) => {
            e.left = transform_recursive(e.left, transform_fn)?;
            e.right = transform_recursive(e.right, transform_fn)?;
            Expression::Except(e)
        }

        // ===== DML expressions =====
        Expression::Insert(mut ins) => {
            // Transform VALUES clause expressions
            let mut new_values = Vec::new();
            for row in ins.values {
                let mut new_row = Vec::new();
                for e in row {
                    new_row.push(transform_recursive(e, transform_fn)?);
                }
                new_values.push(new_row);
            }
            ins.values = new_values;

            // Transform query (for INSERT ... SELECT)
            if let Some(query) = ins.query {
                ins.query = Some(transform_recursive(query, transform_fn)?);
            }

            // Transform RETURNING clause
            let mut new_returning = Vec::new();
            for e in ins.returning {
                new_returning.push(transform_recursive(e, transform_fn)?);
            }
            ins.returning = new_returning;

            // Transform ON CONFLICT clause
            if let Some(on_conflict) = ins.on_conflict {
                ins.on_conflict = Some(Box::new(transform_recursive(*on_conflict, transform_fn)?));
            }

            Expression::Insert(ins)
        }
        Expression::Update(mut upd) => {
            upd.set = upd
                .set
                .into_iter()
                .map(|(id, val)| {
                    let new_val = transform_recursive(val.clone(), transform_fn).unwrap_or(val);
                    (id, new_val)
                })
                .collect();
            if let Some(mut where_clause) = upd.where_clause.take() {
                where_clause.this = transform_recursive(where_clause.this, transform_fn)?;
                upd.where_clause = Some(where_clause);
            }
            Expression::Update(upd)
        }
        Expression::Delete(mut del) => {
            if let Some(mut where_clause) = del.where_clause.take() {
                where_clause.this = transform_recursive(where_clause.this, transform_fn)?;
                del.where_clause = Some(where_clause);
            }
            Expression::Delete(del)
        }

        // ===== CTE expressions =====
        Expression::With(mut w) => {
            w.ctes = w
                .ctes
                .into_iter()
                .map(|mut cte| {
                    let original = cte.this.clone();
                    cte.this = transform_recursive(cte.this, transform_fn).unwrap_or(original);
                    cte
                })
                .collect();
            Expression::With(w)
        }
        Expression::Cte(mut c) => {
            c.this = transform_recursive(c.this, transform_fn)?;
            Expression::Cte(c)
        }

        // ===== Order expressions =====
        Expression::Ordered(mut o) => {
            o.this = transform_recursive(o.this, transform_fn)?;
            Expression::Ordered(o)
        }

        // ===== Negation =====
        Expression::Neg(mut n) => {
            n.this = transform_recursive(n.this, transform_fn)?;
            Expression::Neg(n)
        }

        // ===== Between =====
        Expression::Between(mut b) => {
            b.this = transform_recursive(b.this, transform_fn)?;
            b.low = transform_recursive(b.low, transform_fn)?;
            b.high = transform_recursive(b.high, transform_fn)?;
            Expression::Between(b)
        }

        // ===== Like expressions =====
        Expression::Like(mut l) => {
            l.left = transform_recursive(l.left, transform_fn)?;
            l.right = transform_recursive(l.right, transform_fn)?;
            Expression::Like(l)
        }
        Expression::ILike(mut l) => {
            l.left = transform_recursive(l.left, transform_fn)?;
            l.right = transform_recursive(l.right, transform_fn)?;
            Expression::ILike(l)
        }

        // ===== Additional binary ops not covered by macro =====
        Expression::Neq(op) => transform_binary!(Neq, *op),
        Expression::Lte(op) => transform_binary!(Lte, *op),
        Expression::Gte(op) => transform_binary!(Gte, *op),
        Expression::Mod(op) => transform_binary!(Mod, *op),
        Expression::Concat(op) => transform_binary!(Concat, *op),
        Expression::BitwiseAnd(op) => transform_binary!(BitwiseAnd, *op),
        Expression::BitwiseOr(op) => transform_binary!(BitwiseOr, *op),
        Expression::BitwiseXor(op) => transform_binary!(BitwiseXor, *op),
        Expression::Is(op) => transform_binary!(Is, *op),

        // ===== TryCast / SafeCast =====
        Expression::TryCast(mut c) => {
            c.this = transform_recursive(c.this, transform_fn)?;
            c.to = transform_data_type_recursive(c.to, transform_fn)?;
            Expression::TryCast(c)
        }
        Expression::SafeCast(mut c) => {
            c.this = transform_recursive(c.this, transform_fn)?;
            c.to = transform_data_type_recursive(c.to, transform_fn)?;
            Expression::SafeCast(c)
        }

        // ===== Misc =====
        Expression::Unnest(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            f.expressions = f
                .expressions
                .into_iter()
                .map(|e| transform_recursive(e, transform_fn))
                .collect::<Result<Vec<_>>>()?;
            Expression::Unnest(f)
        }
        Expression::Explode(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::Explode(f)
        }
        Expression::GroupConcat(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::GroupConcat(f)
        }
        Expression::StringAgg(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::StringAgg(f)
        }
        Expression::ListAgg(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::ListAgg(f)
        }
        Expression::ArrayAgg(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::ArrayAgg(f)
        }
        Expression::ParseJson(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::ParseJson(f)
        }
        Expression::ToJson(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::ToJson(f)
        }
        Expression::JSONExtract(mut e) => {
            e.this = Box::new(transform_recursive(*e.this, transform_fn)?);
            e.expression = Box::new(transform_recursive(*e.expression, transform_fn)?);
            Expression::JSONExtract(e)
        }
        Expression::JSONExtractScalar(mut e) => {
            e.this = Box::new(transform_recursive(*e.this, transform_fn)?);
            e.expression = Box::new(transform_recursive(*e.expression, transform_fn)?);
            Expression::JSONExtractScalar(e)
        }

        // StrToTime: recurse into this
        Expression::StrToTime(mut e) => {
            e.this = Box::new(transform_recursive(*e.this, transform_fn)?);
            Expression::StrToTime(e)
        }

        // UnixToTime: recurse into this
        Expression::UnixToTime(mut e) => {
            e.this = Box::new(transform_recursive(*e.this, transform_fn)?);
            Expression::UnixToTime(e)
        }

        // CreateTable: recurse into column defaults, on_update expressions, and data types
        Expression::CreateTable(mut ct) => {
            for col in &mut ct.columns {
                if let Some(default_expr) = col.default.take() {
                    col.default = Some(transform_recursive(default_expr, transform_fn)?);
                }
                if let Some(on_update_expr) = col.on_update.take() {
                    col.on_update = Some(transform_recursive(on_update_expr, transform_fn)?);
                }
                // Note: Column data type transformations (INT -> INT64 for BigQuery, etc.)
                // are NOT applied here because per-dialect transforms are designed for CAST/expression
                // contexts and may not produce correct results for DDL column definitions.
                // The DDL type mappings would need dedicated handling per source/target pair.
            }
            if let Some(as_select) = ct.as_select.take() {
                ct.as_select = Some(transform_recursive(as_select, transform_fn)?);
            }
            Expression::CreateTable(ct)
        }

        // CreateProcedure: recurse into body expressions
        Expression::CreateProcedure(mut cp) => {
            if let Some(body) = cp.body.take() {
                cp.body = Some(match body {
                    FunctionBody::Expression(expr) => {
                        FunctionBody::Expression(transform_recursive(expr, transform_fn)?)
                    }
                    FunctionBody::Return(expr) => {
                        FunctionBody::Return(transform_recursive(expr, transform_fn)?)
                    }
                    FunctionBody::Statements(stmts) => {
                        let transformed_stmts = stmts
                            .into_iter()
                            .map(|s| transform_recursive(s, transform_fn))
                            .collect::<Result<Vec<_>>>()?;
                        FunctionBody::Statements(transformed_stmts)
                    }
                    other => other,
                });
            }
            Expression::CreateProcedure(cp)
        }

        // CreateFunction: recurse into body expressions
        Expression::CreateFunction(mut cf) => {
            if let Some(body) = cf.body.take() {
                cf.body = Some(match body {
                    FunctionBody::Expression(expr) => {
                        FunctionBody::Expression(transform_recursive(expr, transform_fn)?)
                    }
                    FunctionBody::Return(expr) => {
                        FunctionBody::Return(transform_recursive(expr, transform_fn)?)
                    }
                    FunctionBody::Statements(stmts) => {
                        let transformed_stmts = stmts
                            .into_iter()
                            .map(|s| transform_recursive(s, transform_fn))
                            .collect::<Result<Vec<_>>>()?;
                        FunctionBody::Statements(transformed_stmts)
                    }
                    other => other,
                });
            }
            Expression::CreateFunction(cf)
        }

        // MemberOf: recurse into left and right operands
        Expression::MemberOf(op) => transform_binary!(MemberOf, *op),
        // ArrayContainsAll (@>): recurse into left and right operands
        Expression::ArrayContainsAll(op) => transform_binary!(ArrayContainsAll, *op),
        // ArrayContainedBy (<@): recurse into left and right operands
        Expression::ArrayContainedBy(op) => transform_binary!(ArrayContainedBy, *op),
        // ArrayOverlaps (&&): recurse into left and right operands
        Expression::ArrayOverlaps(op) => transform_binary!(ArrayOverlaps, *op),
        // TsMatch (@@): recurse into left and right operands
        Expression::TsMatch(op) => transform_binary!(TsMatch, *op),
        // Adjacent (-|-): recurse into left and right operands
        Expression::Adjacent(op) => transform_binary!(Adjacent, *op),

        // Table: recurse into when (HistoricalData) and changes fields
        Expression::Table(mut t) => {
            if let Some(when) = t.when.take() {
                let transformed =
                    transform_recursive(Expression::HistoricalData(when), transform_fn)?;
                if let Expression::HistoricalData(hd) = transformed {
                    t.when = Some(hd);
                }
            }
            if let Some(changes) = t.changes.take() {
                let transformed = transform_recursive(Expression::Changes(changes), transform_fn)?;
                if let Expression::Changes(c) = transformed {
                    t.changes = Some(c);
                }
            }
            Expression::Table(t)
        }

        // HistoricalData (Snowflake time travel): recurse into expression
        Expression::HistoricalData(mut hd) => {
            *hd.expression = transform_recursive(*hd.expression, transform_fn)?;
            Expression::HistoricalData(hd)
        }

        // Changes (Snowflake CHANGES clause): recurse into at_before and end
        Expression::Changes(mut c) => {
            if let Some(at_before) = c.at_before.take() {
                c.at_before = Some(Box::new(transform_recursive(*at_before, transform_fn)?));
            }
            if let Some(end) = c.end.take() {
                c.end = Some(Box::new(transform_recursive(*end, transform_fn)?));
            }
            Expression::Changes(c)
        }

        // TableArgument: TABLE(expr) or MODEL(expr)
        Expression::TableArgument(mut ta) => {
            ta.this = transform_recursive(ta.this, transform_fn)?;
            Expression::TableArgument(ta)
        }

        // JoinedTable: (tbl1 JOIN tbl2 ON ...) - recurse into left and join tables
        Expression::JoinedTable(mut jt) => {
            jt.left = transform_recursive(jt.left, transform_fn)?;
            for join in &mut jt.joins {
                join.this = transform_recursive(
                    std::mem::replace(&mut join.this, Expression::Null(crate::expressions::Null)),
                    transform_fn,
                )?;
                if let Some(on) = join.on.take() {
                    join.on = Some(transform_recursive(on, transform_fn)?);
                }
            }
            jt.lateral_views = jt
                .lateral_views
                .into_iter()
                .map(|mut lv| {
                    lv.this = transform_recursive(lv.this, transform_fn)?;
                    Ok(lv)
                })
                .collect::<Result<Vec<_>>>()?;
            Expression::JoinedTable(jt)
        }

        // Lateral: LATERAL func() - recurse into the function expression
        Expression::Lateral(mut lat) => {
            *lat.this = transform_recursive(*lat.this, transform_fn)?;
            Expression::Lateral(lat)
        }

        // WithinGroup: recurse into order_by items (for NULLS FIRST/LAST etc.)
        // but NOT into wg.this - the inner function is handled by StringAggConvert/GroupConcatConvert
        // as a unit together with the WithinGroup wrapper
        Expression::WithinGroup(mut wg) => {
            wg.order_by = wg
                .order_by
                .into_iter()
                .map(|mut o| {
                    let original = o.this.clone();
                    o.this = transform_recursive(o.this, transform_fn).unwrap_or(original);
                    match transform_fn(Expression::Ordered(Box::new(o.clone()))) {
                        Ok(Expression::Ordered(transformed)) => *transformed,
                        Ok(_) | Err(_) => o,
                    }
                })
                .collect();
            Expression::WithinGroup(wg)
        }

        // Filter: recurse into both the aggregate and the filter condition
        Expression::Filter(mut f) => {
            f.this = Box::new(transform_recursive(*f.this, transform_fn)?);
            f.expression = Box::new(transform_recursive(*f.expression, transform_fn)?);
            Expression::Filter(f)
        }

        // BitwiseOrAgg/BitwiseAndAgg/BitwiseXorAgg: recurse into the aggregate argument
        Expression::BitwiseOrAgg(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::BitwiseOrAgg(f)
        }
        Expression::BitwiseAndAgg(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::BitwiseAndAgg(f)
        }
        Expression::BitwiseXorAgg(mut f) => {
            f.this = transform_recursive(f.this, transform_fn)?;
            Expression::BitwiseXorAgg(f)
        }
        Expression::PipeOperator(mut pipe) => {
            pipe.this = transform_recursive(pipe.this, transform_fn)?;
            pipe.expression = transform_recursive(pipe.expression, transform_fn)?;
            Expression::PipeOperator(pipe)
        }

        // Pass through leaf nodes unchanged
        other => other,
    };

    // Then apply the transform function
    transform_fn(expr)
}

/// Returns the tokenizer config, generator config, and expression transform closure
/// for a built-in dialect type. This is the shared implementation used by both
/// `Dialect::get()` and custom dialect construction.
fn configs_for_dialect_type(
    dt: DialectType,
) -> (
    TokenizerConfig,
    GeneratorConfig,
    Box<dyn Fn(Expression) -> Result<Expression> + Send + Sync>,
) {
    macro_rules! dialect_configs {
        ($dialect_struct:ident) => {{
            let d = $dialect_struct;
            (
                d.tokenizer_config(),
                d.generator_config(),
                Box::new(move |e| $dialect_struct.transform_expr(e)),
            )
        }};
    }
    match dt {
        #[cfg(feature = "dialect-postgresql")]
        DialectType::PostgreSQL => dialect_configs!(PostgresDialect),
        #[cfg(feature = "dialect-mysql")]
        DialectType::MySQL => dialect_configs!(MySQLDialect),
        #[cfg(feature = "dialect-bigquery")]
        DialectType::BigQuery => dialect_configs!(BigQueryDialect),
        #[cfg(feature = "dialect-snowflake")]
        DialectType::Snowflake => dialect_configs!(SnowflakeDialect),
        #[cfg(feature = "dialect-duckdb")]
        DialectType::DuckDB => dialect_configs!(DuckDBDialect),
        #[cfg(feature = "dialect-tsql")]
        DialectType::TSQL => dialect_configs!(TSQLDialect),
        #[cfg(feature = "dialect-oracle")]
        DialectType::Oracle => dialect_configs!(OracleDialect),
        #[cfg(feature = "dialect-hive")]
        DialectType::Hive => dialect_configs!(HiveDialect),
        #[cfg(feature = "dialect-spark")]
        DialectType::Spark => dialect_configs!(SparkDialect),
        #[cfg(feature = "dialect-sqlite")]
        DialectType::SQLite => dialect_configs!(SQLiteDialect),
        #[cfg(feature = "dialect-presto")]
        DialectType::Presto => dialect_configs!(PrestoDialect),
        #[cfg(feature = "dialect-trino")]
        DialectType::Trino => dialect_configs!(TrinoDialect),
        #[cfg(feature = "dialect-redshift")]
        DialectType::Redshift => dialect_configs!(RedshiftDialect),
        #[cfg(feature = "dialect-clickhouse")]
        DialectType::ClickHouse => dialect_configs!(ClickHouseDialect),
        #[cfg(feature = "dialect-databricks")]
        DialectType::Databricks => dialect_configs!(DatabricksDialect),
        #[cfg(feature = "dialect-athena")]
        DialectType::Athena => dialect_configs!(AthenaDialect),
        #[cfg(feature = "dialect-teradata")]
        DialectType::Teradata => dialect_configs!(TeradataDialect),
        #[cfg(feature = "dialect-doris")]
        DialectType::Doris => dialect_configs!(DorisDialect),
        #[cfg(feature = "dialect-starrocks")]
        DialectType::StarRocks => dialect_configs!(StarRocksDialect),
        #[cfg(feature = "dialect-materialize")]
        DialectType::Materialize => dialect_configs!(MaterializeDialect),
        #[cfg(feature = "dialect-risingwave")]
        DialectType::RisingWave => dialect_configs!(RisingWaveDialect),
        #[cfg(feature = "dialect-singlestore")]
        DialectType::SingleStore => dialect_configs!(SingleStoreDialect),
        #[cfg(feature = "dialect-cockroachdb")]
        DialectType::CockroachDB => dialect_configs!(CockroachDBDialect),
        #[cfg(feature = "dialect-tidb")]
        DialectType::TiDB => dialect_configs!(TiDBDialect),
        #[cfg(feature = "dialect-druid")]
        DialectType::Druid => dialect_configs!(DruidDialect),
        #[cfg(feature = "dialect-solr")]
        DialectType::Solr => dialect_configs!(SolrDialect),
        #[cfg(feature = "dialect-tableau")]
        DialectType::Tableau => dialect_configs!(TableauDialect),
        #[cfg(feature = "dialect-dune")]
        DialectType::Dune => dialect_configs!(DuneDialect),
        #[cfg(feature = "dialect-fabric")]
        DialectType::Fabric => dialect_configs!(FabricDialect),
        #[cfg(feature = "dialect-drill")]
        DialectType::Drill => dialect_configs!(DrillDialect),
        #[cfg(feature = "dialect-dremio")]
        DialectType::Dremio => dialect_configs!(DremioDialect),
        #[cfg(feature = "dialect-exasol")]
        DialectType::Exasol => dialect_configs!(ExasolDialect),
        #[cfg(feature = "dialect-datafusion")]
        DialectType::DataFusion => dialect_configs!(DataFusionDialect),
        _ => dialect_configs!(GenericDialect),
    }
}

// ---------------------------------------------------------------------------
// Custom dialect registry
// ---------------------------------------------------------------------------

static CUSTOM_DIALECT_REGISTRY: LazyLock<RwLock<HashMap<String, Arc<CustomDialectConfig>>>> =
    LazyLock::new(|| RwLock::new(HashMap::new()));

struct CustomDialectConfig {
    name: String,
    base_dialect: DialectType,
    tokenizer_config: TokenizerConfig,
    generator_config: GeneratorConfig,
    transform: Option<Arc<dyn Fn(Expression) -> Result<Expression> + Send + Sync>>,
    preprocess: Option<Arc<dyn Fn(Expression) -> Result<Expression> + Send + Sync>>,
}

/// Fluent builder for creating and registering custom SQL dialects.
///
/// A custom dialect is based on an existing built-in dialect and allows selective
/// overrides of tokenizer configuration, generator configuration, and expression
/// transforms.
///
/// # Example
///
/// ```rust,ignore
/// use polyglot_sql::dialects::{CustomDialectBuilder, DialectType, Dialect};
/// use polyglot_sql::generator::NormalizeFunctions;
///
/// CustomDialectBuilder::new("my_postgres")
///     .based_on(DialectType::PostgreSQL)
///     .generator_config_modifier(|gc| {
///         gc.normalize_functions = NormalizeFunctions::Lower;
///     })
///     .register()
///     .unwrap();
///
/// let d = Dialect::get_by_name("my_postgres").unwrap();
/// let exprs = d.parse("SELECT COUNT(*)").unwrap();
/// let sql = d.generate(&exprs[0]).unwrap();
/// assert_eq!(sql, "select count(*)");
///
/// polyglot_sql::unregister_custom_dialect("my_postgres");
/// ```
pub struct CustomDialectBuilder {
    name: String,
    base_dialect: DialectType,
    tokenizer_modifier: Option<Box<dyn FnOnce(&mut TokenizerConfig)>>,
    generator_modifier: Option<Box<dyn FnOnce(&mut GeneratorConfig)>>,
    transform: Option<Arc<dyn Fn(Expression) -> Result<Expression> + Send + Sync>>,
    preprocess: Option<Arc<dyn Fn(Expression) -> Result<Expression> + Send + Sync>>,
}

impl CustomDialectBuilder {
    /// Create a new builder with the given name. Defaults to `Generic` as the base dialect.
    pub fn new(name: impl Into<String>) -> Self {
        Self {
            name: name.into(),
            base_dialect: DialectType::Generic,
            tokenizer_modifier: None,
            generator_modifier: None,
            transform: None,
            preprocess: None,
        }
    }

    /// Set the base built-in dialect to inherit configuration from.
    pub fn based_on(mut self, dialect: DialectType) -> Self {
        self.base_dialect = dialect;
        self
    }

    /// Provide a closure that modifies the tokenizer configuration inherited from the base dialect.
    pub fn tokenizer_config_modifier<F>(mut self, f: F) -> Self
    where
        F: FnOnce(&mut TokenizerConfig) + 'static,
    {
        self.tokenizer_modifier = Some(Box::new(f));
        self
    }

    /// Provide a closure that modifies the generator configuration inherited from the base dialect.
    pub fn generator_config_modifier<F>(mut self, f: F) -> Self
    where
        F: FnOnce(&mut GeneratorConfig) + 'static,
    {
        self.generator_modifier = Some(Box::new(f));
        self
    }

    /// Set a custom per-node expression transform function.
    ///
    /// This replaces the base dialect's transform. It is called on every expression
    /// node during the recursive transform pass.
    pub fn transform_fn<F>(mut self, f: F) -> Self
    where
        F: Fn(Expression) -> Result<Expression> + Send + Sync + 'static,
    {
        self.transform = Some(Arc::new(f));
        self
    }

    /// Set a custom whole-tree preprocessing function.
    ///
    /// This replaces the base dialect's built-in preprocessing. It is called once
    /// on the entire expression tree before the recursive per-node transform.
    pub fn preprocess_fn<F>(mut self, f: F) -> Self
    where
        F: Fn(Expression) -> Result<Expression> + Send + Sync + 'static,
    {
        self.preprocess = Some(Arc::new(f));
        self
    }

    /// Build the custom dialect configuration and register it in the global registry.
    ///
    /// Returns an error if:
    /// - The name collides with a built-in dialect name
    /// - A custom dialect with the same name is already registered
    pub fn register(self) -> Result<()> {
        // Reject names that collide with built-in dialects
        if DialectType::from_str(&self.name).is_ok() {
            return Err(crate::error::Error::parse(
                format!(
                    "Cannot register custom dialect '{}': name collides with built-in dialect",
                    self.name
                ),
                0,
                0,
            ));
        }

        // Get base configs
        let (mut tok_config, mut gen_config, _base_transform) =
            configs_for_dialect_type(self.base_dialect);

        // Apply modifiers
        if let Some(tok_mod) = self.tokenizer_modifier {
            tok_mod(&mut tok_config);
        }
        if let Some(gen_mod) = self.generator_modifier {
            gen_mod(&mut gen_config);
        }

        let config = CustomDialectConfig {
            name: self.name.clone(),
            base_dialect: self.base_dialect,
            tokenizer_config: tok_config,
            generator_config: gen_config,
            transform: self.transform,
            preprocess: self.preprocess,
        };

        register_custom_dialect(config)
    }
}

use std::str::FromStr;

fn register_custom_dialect(config: CustomDialectConfig) -> Result<()> {
    let mut registry = CUSTOM_DIALECT_REGISTRY
        .write()
        .map_err(|e| crate::error::Error::parse(format!("Registry lock poisoned: {}", e), 0, 0))?;

    if registry.contains_key(&config.name) {
        return Err(crate::error::Error::parse(
            format!("Custom dialect '{}' is already registered", config.name),
            0,
            0,
        ));
    }

    registry.insert(config.name.clone(), Arc::new(config));
    Ok(())
}

/// Remove a custom dialect from the global registry.
///
/// Returns `true` if a dialect with that name was found and removed,
/// `false` if no such custom dialect existed.
pub fn unregister_custom_dialect(name: &str) -> bool {
    if let Ok(mut registry) = CUSTOM_DIALECT_REGISTRY.write() {
        registry.remove(name).is_some()
    } else {
        false
    }
}

fn get_custom_dialect_config(name: &str) -> Option<Arc<CustomDialectConfig>> {
    CUSTOM_DIALECT_REGISTRY
        .read()
        .ok()
        .and_then(|registry| registry.get(name).cloned())
}

/// Main entry point for dialect-specific SQL operations.
///
/// A `Dialect` bundles together a tokenizer, generator configuration, and expression
/// transformer for a specific SQL database engine. It is the high-level API through
/// which callers parse, generate, transform, and transpile SQL.
///
/// # Usage
///
/// ```rust,ignore
/// use polyglot_sql::dialects::{Dialect, DialectType};
///
/// // Parse PostgreSQL SQL into an AST
/// let pg = Dialect::get(DialectType::PostgreSQL);
/// let exprs = pg.parse("SELECT id, name FROM users WHERE active")?;
///
/// // Transpile from PostgreSQL to BigQuery
/// let results = pg.transpile_to("SELECT NOW()", DialectType::BigQuery)?;
/// assert_eq!(results[0], "SELECT CURRENT_TIMESTAMP()");
/// ```
///
/// Obtain an instance via [`Dialect::get`] or [`Dialect::get_by_name`].
/// The struct is `Send + Sync` safe so it can be shared across threads.
pub struct Dialect {
    dialect_type: DialectType,
    tokenizer: Tokenizer,
    generator_config: GeneratorConfig,
    transformer: Box<dyn Fn(Expression) -> Result<Expression> + Send + Sync>,
    /// Optional function to get expression-specific generator config (for hybrid dialects like Athena).
    generator_config_for_expr: Option<Box<dyn Fn(&Expression) -> GeneratorConfig + Send + Sync>>,
    /// Optional custom preprocessing function (overrides built-in preprocess for custom dialects).
    custom_preprocess: Option<Box<dyn Fn(Expression) -> Result<Expression> + Send + Sync>>,
}

impl Dialect {
    /// Creates a fully configured [`Dialect`] instance for the given [`DialectType`].
    ///
    /// This is the primary constructor. It initializes the tokenizer, generator config,
    /// and expression transformer based on the dialect's [`DialectImpl`] implementation.
    /// For hybrid dialects like Athena, it also sets up expression-specific generator
    /// config routing.
    pub fn get(dialect_type: DialectType) -> Self {
        let (tokenizer_config, generator_config, transformer) =
            configs_for_dialect_type(dialect_type);

        // Set up expression-specific generator config for hybrid dialects
        let generator_config_for_expr: Option<
            Box<dyn Fn(&Expression) -> GeneratorConfig + Send + Sync>,
        > = match dialect_type {
            #[cfg(feature = "dialect-athena")]
            DialectType::Athena => Some(Box::new(|expr| {
                AthenaDialect.generator_config_for_expr(expr)
            })),
            _ => None,
        };

        Self {
            dialect_type,
            tokenizer: Tokenizer::new(tokenizer_config),
            generator_config,
            transformer,
            generator_config_for_expr,
            custom_preprocess: None,
        }
    }

    /// Look up a dialect by string name.
    ///
    /// Checks built-in dialect names first (via [`DialectType::from_str`]), then
    /// falls back to the custom dialect registry. Returns `None` if no dialect
    /// with the given name exists.
    pub fn get_by_name(name: &str) -> Option<Self> {
        // Try built-in first
        if let Ok(dt) = DialectType::from_str(name) {
            return Some(Self::get(dt));
        }

        // Try custom registry
        let config = get_custom_dialect_config(name)?;
        Some(Self::from_custom_config(&config))
    }

    /// Construct a `Dialect` from a custom dialect configuration.
    fn from_custom_config(config: &CustomDialectConfig) -> Self {
        // Build the transformer: use custom if provided, else use base dialect's
        let transformer: Box<dyn Fn(Expression) -> Result<Expression> + Send + Sync> =
            if let Some(ref custom_transform) = config.transform {
                let t = Arc::clone(custom_transform);
                Box::new(move |e| t(e))
            } else {
                let (_, _, base_transform) = configs_for_dialect_type(config.base_dialect);
                base_transform
            };

        // Build the custom preprocess: use custom if provided
        let custom_preprocess: Option<Box<dyn Fn(Expression) -> Result<Expression> + Send + Sync>> =
            config.preprocess.as_ref().map(|p| {
                let p = Arc::clone(p);
                Box::new(move |e: Expression| p(e))
                    as Box<dyn Fn(Expression) -> Result<Expression> + Send + Sync>
            });

        Self {
            dialect_type: config.base_dialect,
            tokenizer: Tokenizer::new(config.tokenizer_config.clone()),
            generator_config: config.generator_config.clone(),
            transformer,
            generator_config_for_expr: None,
            custom_preprocess,
        }
    }

    /// Get the dialect type
    pub fn dialect_type(&self) -> DialectType {
        self.dialect_type
    }

    /// Get the generator configuration
    pub fn generator_config(&self) -> &GeneratorConfig {
        &self.generator_config
    }

    /// Parses a SQL string into a list of [`Expression`] AST nodes.
    ///
    /// The input may contain multiple semicolon-separated statements; each one
    /// produces a separate element in the returned vector. Tokenization uses
    /// this dialect's configured tokenizer, and parsing uses the dialect-aware parser.
    pub fn parse(&self, sql: &str) -> Result<Vec<Expression>> {
        let tokens = self.tokenizer.tokenize(sql)?;
        let config = crate::parser::ParserConfig {
            dialect: Some(self.dialect_type),
            ..Default::default()
        };
        let mut parser = Parser::with_source(tokens, config, sql.to_string());
        parser.parse()
    }

    /// Tokenize SQL using this dialect's tokenizer configuration.
    pub fn tokenize(&self, sql: &str) -> Result<Vec<Token>> {
        self.tokenizer.tokenize(sql)
    }

    /// Get the generator config for a specific expression (supports hybrid dialects)
    fn get_config_for_expr(&self, expr: &Expression) -> GeneratorConfig {
        if let Some(ref config_fn) = self.generator_config_for_expr {
            config_fn(expr)
        } else {
            self.generator_config.clone()
        }
    }

    /// Generates a SQL string from an [`Expression`] AST node.
    ///
    /// The output uses this dialect's generator configuration for identifier quoting,
    /// keyword casing, function name normalization, and syntax style. The result is
    /// a single-line (non-pretty) SQL string.
    pub fn generate(&self, expr: &Expression) -> Result<String> {
        let config = self.get_config_for_expr(expr);
        let mut generator = Generator::with_config(config);
        generator.generate(expr)
    }

    /// Generate SQL from an expression with pretty printing enabled
    pub fn generate_pretty(&self, expr: &Expression) -> Result<String> {
        let mut config = self.get_config_for_expr(expr);
        config.pretty = true;
        let mut generator = Generator::with_config(config);
        generator.generate(expr)
    }

    /// Generate SQL from an expression with source dialect info (for transpilation)
    pub fn generate_with_source(&self, expr: &Expression, source: DialectType) -> Result<String> {
        let mut config = self.get_config_for_expr(expr);
        config.source_dialect = Some(source);
        let mut generator = Generator::with_config(config);
        generator.generate(expr)
    }

    /// Generate SQL from an expression with pretty printing and source dialect info
    pub fn generate_pretty_with_source(
        &self,
        expr: &Expression,
        source: DialectType,
    ) -> Result<String> {
        let mut config = self.get_config_for_expr(expr);
        config.pretty = true;
        config.source_dialect = Some(source);
        let mut generator = Generator::with_config(config);
        generator.generate(expr)
    }

    /// Generate SQL from an expression with forced identifier quoting (identify=True)
    pub fn generate_with_identify(&self, expr: &Expression) -> Result<String> {
        let mut config = self.get_config_for_expr(expr);
        config.always_quote_identifiers = true;
        let mut generator = Generator::with_config(config);
        generator.generate(expr)
    }

    /// Generate SQL from an expression with pretty printing and forced identifier quoting
    pub fn generate_pretty_with_identify(&self, expr: &Expression) -> Result<String> {
        let mut config = self.generator_config.clone();
        config.pretty = true;
        config.always_quote_identifiers = true;
        let mut generator = Generator::with_config(config);
        generator.generate(expr)
    }

    /// Generate SQL from an expression with caller-specified config overrides
    pub fn generate_with_overrides(
        &self,
        expr: &Expression,
        overrides: impl FnOnce(&mut GeneratorConfig),
    ) -> Result<String> {
        let mut config = self.get_config_for_expr(expr);
        overrides(&mut config);
        let mut generator = Generator::with_config(config);
        generator.generate(expr)
    }

    /// Transforms an expression tree to conform to this dialect's syntax and semantics.
    ///
    /// The transformation proceeds in two phases:
    /// 1. **Preprocessing** -- whole-tree structural rewrites such as eliminating QUALIFY,
    ///    ensuring boolean predicates, or converting DISTINCT ON to a window-function pattern.
    /// 2. **Recursive per-node transform** -- a bottom-up pass via [`transform_recursive`]
    ///    that applies this dialect's [`DialectImpl::transform_expr`] to every node.
    ///
    /// This method is used both during transpilation (to rewrite an AST for a target dialect)
    /// and for identity transforms (normalizing SQL within the same dialect).
    pub fn transform(&self, expr: Expression) -> Result<Expression> {
        // Apply preprocessing transforms based on dialect
        let preprocessed = self.preprocess(expr)?;
        // Then apply recursive transformation
        transform_recursive(preprocessed, &self.transformer)
    }

    /// Apply dialect-specific preprocessing transforms
    fn preprocess(&self, expr: Expression) -> Result<Expression> {
        // If a custom preprocess function is set, use it instead of the built-in logic
        if let Some(ref custom_preprocess) = self.custom_preprocess {
            return custom_preprocess(expr);
        }

        #[cfg(any(
            feature = "dialect-mysql",
            feature = "dialect-postgresql",
            feature = "dialect-bigquery",
            feature = "dialect-snowflake",
            feature = "dialect-tsql",
            feature = "dialect-spark",
            feature = "dialect-databricks",
            feature = "dialect-hive",
            feature = "dialect-sqlite",
            feature = "dialect-trino",
            feature = "dialect-presto",
            feature = "dialect-duckdb",
            feature = "dialect-redshift",
            feature = "dialect-starrocks",
            feature = "dialect-oracle",
            feature = "dialect-clickhouse",
        ))]
        use crate::transforms;

        match self.dialect_type {
            // MySQL doesn't support QUALIFY, DISTINCT ON, FULL OUTER JOIN
            // MySQL doesn't natively support GENERATE_DATE_ARRAY (expand to recursive CTE)
            #[cfg(feature = "dialect-mysql")]
            DialectType::MySQL => {
                let expr = transforms::eliminate_qualify(expr)?;
                let expr = transforms::eliminate_full_outer_join(expr)?;
                let expr = transforms::eliminate_semi_and_anti_joins(expr)?;
                let expr = transforms::unnest_generate_date_array_using_recursive_cte(expr)?;
                Ok(expr)
            }
            // PostgreSQL doesn't support QUALIFY
            // PostgreSQL: UNNEST(GENERATE_SERIES) -> subquery wrapping
            // PostgreSQL: Normalize SET ... TO to SET ... = in CREATE FUNCTION
            #[cfg(feature = "dialect-postgresql")]
            DialectType::PostgreSQL => {
                let expr = transforms::eliminate_qualify(expr)?;
                let expr = transforms::eliminate_semi_and_anti_joins(expr)?;
                let expr = transforms::unwrap_unnest_generate_series_for_postgres(expr)?;
                // Normalize SET ... TO to SET ... = in CREATE FUNCTION
                // Only normalize when sqlglot would fully parse (no body) 
                // sqlglot falls back to Command for complex function bodies,
                // preserving the original text including TO.
                let expr = if let Expression::CreateFunction(mut cf) = expr {
                    if cf.body.is_none() {
                        for opt in &mut cf.set_options {
                            if let crate::expressions::FunctionSetValue::Value { use_to, .. } =
                                &mut opt.value
                            {
                                *use_to = false;
                            }
                        }
                    }
                    Expression::CreateFunction(cf)
                } else {
                    expr
                };
                Ok(expr)
            }
            // BigQuery doesn't support DISTINCT ON or CTE column aliases
            #[cfg(feature = "dialect-bigquery")]
            DialectType::BigQuery => {
                let expr = transforms::eliminate_semi_and_anti_joins(expr)?;
                let expr = transforms::pushdown_cte_column_names(expr)?;
                let expr = transforms::explode_projection_to_unnest(expr, DialectType::BigQuery)?;
                Ok(expr)
            }
            // Snowflake
            #[cfg(feature = "dialect-snowflake")]
            DialectType::Snowflake => {
                let expr = transforms::eliminate_semi_and_anti_joins(expr)?;
                let expr = transforms::eliminate_window_clause(expr)?;
                let expr = transforms::snowflake_flatten_projection_to_unnest(expr)?;
                Ok(expr)
            }
            // TSQL doesn't support QUALIFY
            // TSQL requires boolean expressions in WHERE/HAVING (no implicit truthiness)
            // TSQL doesn't support CTEs in subqueries (hoist to top level)
            // NOTE: no_limit_order_by_union is handled in cross_dialect_normalize (not preprocess)
            // to avoid breaking TSQL identity tests where ORDER BY on UNION is valid
            #[cfg(feature = "dialect-tsql")]
            DialectType::TSQL => {
                let expr = transforms::eliminate_qualify(expr)?;
                let expr = transforms::eliminate_semi_and_anti_joins(expr)?;
                let expr = transforms::ensure_bools(expr)?;
                let expr = transforms::unnest_generate_date_array_using_recursive_cte(expr)?;
                let expr = transforms::move_ctes_to_top_level(expr)?;
                let expr = transforms::qualify_derived_table_outputs(expr)?;
                Ok(expr)
            }
            // Spark doesn't support QUALIFY (but Databricks does)
            // Spark doesn't support CTEs in subqueries (hoist to top level)
            #[cfg(feature = "dialect-spark")]
            DialectType::Spark => {
                let expr = transforms::eliminate_qualify(expr)?;
                let expr = transforms::add_auto_table_alias(expr)?;
                let expr = transforms::simplify_nested_paren_values(expr)?;
                let expr = transforms::move_ctes_to_top_level(expr)?;
                Ok(expr)
            }
            // Databricks supports QUALIFY natively
            // Databricks doesn't support CTEs in subqueries (hoist to top level)
            #[cfg(feature = "dialect-databricks")]
            DialectType::Databricks => {
                let expr = transforms::add_auto_table_alias(expr)?;
                let expr = transforms::simplify_nested_paren_values(expr)?;
                let expr = transforms::move_ctes_to_top_level(expr)?;
                Ok(expr)
            }
            // Hive doesn't support QUALIFY or CTEs in subqueries
            #[cfg(feature = "dialect-hive")]
            DialectType::Hive => {
                let expr = transforms::eliminate_qualify(expr)?;
                let expr = transforms::move_ctes_to_top_level(expr)?;
                Ok(expr)
            }
            // SQLite doesn't support QUALIFY
            #[cfg(feature = "dialect-sqlite")]
            DialectType::SQLite => {
                let expr = transforms::eliminate_qualify(expr)?;
                Ok(expr)
            }
            // Trino doesn't support QUALIFY
            #[cfg(feature = "dialect-trino")]
            DialectType::Trino => {
                let expr = transforms::eliminate_qualify(expr)?;
                let expr = transforms::explode_projection_to_unnest(expr, DialectType::Trino)?;
                Ok(expr)
            }
            // Presto doesn't support QUALIFY or WINDOW clause
            #[cfg(feature = "dialect-presto")]
            DialectType::Presto => {
                let expr = transforms::eliminate_qualify(expr)?;
                let expr = transforms::eliminate_window_clause(expr)?;
                let expr = transforms::explode_projection_to_unnest(expr, DialectType::Presto)?;
                Ok(expr)
            }
            // DuckDB supports QUALIFY - no elimination needed
            // Expand POSEXPLODE to GENERATE_SUBSCRIPTS + UNNEST
            // Expand LIKE ANY / ILIKE ANY to OR chains (DuckDB doesn't support quantifiers)
            #[cfg(feature = "dialect-duckdb")]
            DialectType::DuckDB => {
                let expr = transforms::expand_posexplode_duckdb(expr)?;
                let expr = transforms::expand_like_any(expr)?;
                Ok(expr)
            }
            // Redshift doesn't support QUALIFY, WINDOW clause, or GENERATE_DATE_ARRAY
            #[cfg(feature = "dialect-redshift")]
            DialectType::Redshift => {
                let expr = transforms::eliminate_qualify(expr)?;
                let expr = transforms::eliminate_window_clause(expr)?;
                let expr = transforms::unnest_generate_date_array_using_recursive_cte(expr)?;
                Ok(expr)
            }
            // StarRocks doesn't support BETWEEN in DELETE statements or QUALIFY
            #[cfg(feature = "dialect-starrocks")]
            DialectType::StarRocks => {
                let expr = transforms::eliminate_qualify(expr)?;
                let expr = transforms::expand_between_in_delete(expr)?;
                Ok(expr)
            }
            // DataFusion supports QUALIFY and semi/anti joins natively
            #[cfg(feature = "dialect-datafusion")]
            DialectType::DataFusion => Ok(expr),
            // Oracle doesn't support QUALIFY
            #[cfg(feature = "dialect-oracle")]
            DialectType::Oracle => {
                let expr = transforms::eliminate_qualify(expr)?;
                Ok(expr)
            }
            // Drill - no special preprocessing needed
            #[cfg(feature = "dialect-drill")]
            DialectType::Drill => Ok(expr),
            // Teradata - no special preprocessing needed
            #[cfg(feature = "dialect-teradata")]
            DialectType::Teradata => Ok(expr),
            // ClickHouse doesn't support ORDER BY/LIMIT directly on UNION
            #[cfg(feature = "dialect-clickhouse")]
            DialectType::ClickHouse => {
                let expr = transforms::no_limit_order_by_union(expr)?;
                Ok(expr)
            }
            // Other dialects - no preprocessing
            _ => Ok(expr),
        }
    }

    /// Transpile SQL from this dialect to another
    pub fn transpile_to(&self, sql: &str, target: DialectType) -> Result<Vec<String>> {
        self.transpile_to_inner(sql, target, false)
    }

    /// Transpile SQL from this dialect to another with pretty printing enabled
    pub fn transpile_to_pretty(&self, sql: &str, target: DialectType) -> Result<Vec<String>> {
        self.transpile_to_inner(sql, target, true)
    }

    #[cfg(not(feature = "transpile"))]
    fn transpile_to_inner(
        &self,
        sql: &str,
        target: DialectType,
        pretty: bool,
    ) -> Result<Vec<String>> {
        // Without the transpile feature, only same-dialect or to/from generic is supported
        if self.dialect_type != target
            && self.dialect_type != DialectType::Generic
            && target != DialectType::Generic
        {
            return Err(crate::error::Error::parse(
                "Cross-dialect transpilation not available in this build",
                0,
                0,
            ));
        }

        let expressions = self.parse(sql)?;
        let target_dialect = Dialect::get(target);
        let generic_identity =
            self.dialect_type == DialectType::Generic && target == DialectType::Generic;

        if generic_identity {
            return expressions
                .into_iter()
                .map(|expr| {
                    if pretty {
                        target_dialect.generate_pretty_with_source(&expr, self.dialect_type)
                    } else {
                        target_dialect.generate_with_source(&expr, self.dialect_type)
                    }
                })
                .collect();
        }

        expressions
            .into_iter()
            .map(|expr| {
                let transformed = target_dialect.transform(expr)?;
                if pretty {
                    target_dialect.generate_pretty_with_source(&transformed, self.dialect_type)
                } else {
                    target_dialect.generate_with_source(&transformed, self.dialect_type)
                }
            })
            .collect()
    }

    #[cfg(feature = "transpile")]
    fn transpile_to_inner(
        &self,
        sql: &str,
        target: DialectType,
        pretty: bool,
    ) -> Result<Vec<String>> {
        let expressions = self.parse(sql)?;
        let target_dialect = Dialect::get(target);
        let generic_identity =
            self.dialect_type == DialectType::Generic && target == DialectType::Generic;

        if generic_identity {
            return expressions
                .into_iter()
                .map(|expr| {
                    if pretty {
                        target_dialect.generate_pretty_with_source(&expr, self.dialect_type)
                    } else {
                        target_dialect.generate_with_source(&expr, self.dialect_type)
                    }
                })
                .collect();
        }

        expressions
            .into_iter()
            .map(|expr| {
                // DuckDB source: normalize VARCHAR/CHAR to TEXT (DuckDB doesn't support
                // VARCHAR length constraints). This emulates Python sqlglot's DuckDB parser
                // where VARCHAR_LENGTH = None and VARCHAR maps to TEXT.
                let expr = if matches!(self.dialect_type, DialectType::DuckDB) {
                    use crate::expressions::DataType as DT;
                    transform_recursive(expr, &|e| match e {
                        Expression::DataType(DT::VarChar { .. }) => {
                            Ok(Expression::DataType(DT::Text))
                        }
                        Expression::DataType(DT::Char { .. }) => Ok(Expression::DataType(DT::Text)),
                        _ => Ok(e),
                    })?
                } else {
                    expr
                };

                // When source and target differ, first normalize the source dialect's
                // AST constructs to standard SQL, so that the target dialect can handle them.
                // This handles cases like Snowflake's SQUARE -> POWER, DIV0 -> CASE, etc.
                let normalized =
                    if self.dialect_type != target && self.dialect_type != DialectType::Generic {
                        self.transform(expr)?
                    } else {
                        expr
                    };

                // For TSQL source targeting non-TSQL: unwrap ISNULL(JSON_QUERY(...), JSON_VALUE(...))
                // to just JSON_QUERY(...) so cross_dialect_normalize can convert it cleanly.
                // The TSQL read transform wraps JsonQuery in ISNULL for identity, but for
                // cross-dialect transpilation we need the unwrapped JSON_QUERY.
                let normalized =
                    if matches!(self.dialect_type, DialectType::TSQL | DialectType::Fabric)
                        && !matches!(target, DialectType::TSQL | DialectType::Fabric)
                    {
                        transform_recursive(normalized, &|e| {
                            if let Expression::Function(ref f) = e {
                                if f.name.eq_ignore_ascii_case("ISNULL") && f.args.len() == 2 {
                                    // Check if first arg is JSON_QUERY and second is JSON_VALUE
                                    if let (
                                        Expression::Function(ref jq),
                                        Expression::Function(ref jv),
                                    ) = (&f.args[0], &f.args[1])
                                    {
                                        if jq.name.eq_ignore_ascii_case("JSON_QUERY")
                                            && jv.name.eq_ignore_ascii_case("JSON_VALUE")
                                        {
                                            // Unwrap: return just JSON_QUERY(...)
                                            return Ok(f.args[0].clone());
                                        }
                                    }
                                }
                            }
                            Ok(e)
                        })?
                    } else {
                        normalized
                    };

                // Snowflake source to non-Snowflake target: CURRENT_TIME -> LOCALTIME
                // Snowflake's CURRENT_TIME is equivalent to LOCALTIME in other dialects.
                // Python sqlglot parses Snowflake's CURRENT_TIME as Localtime expression.
                let normalized = if matches!(self.dialect_type, DialectType::Snowflake)
                    && !matches!(target, DialectType::Snowflake)
                {
                    transform_recursive(normalized, &|e| {
                        if let Expression::Function(ref f) = e {
                            if f.name.eq_ignore_ascii_case("CURRENT_TIME") {
                                return Ok(Expression::Localtime(Box::new(
                                    crate::expressions::Localtime { this: None },
                                )));
                            }
                        }
                        Ok(e)
                    })?
                } else {
                    normalized
                };

                // Snowflake source to DuckDB target: REPEAT(' ', n) -> REPEAT(' ', CAST(n AS BIGINT))
                // Snowflake's SPACE(n) is converted to REPEAT(' ', n) by the Snowflake source
                // transform. DuckDB requires the count argument to be BIGINT.
                let normalized = if matches!(self.dialect_type, DialectType::Snowflake)
                    && matches!(target, DialectType::DuckDB)
                {
                    transform_recursive(normalized, &|e| {
                        if let Expression::Function(ref f) = e {
                            if f.name.eq_ignore_ascii_case("REPEAT") && f.args.len() == 2 {
                                // Check if first arg is space string literal
                                if let Expression::Literal(crate::expressions::Literal::String(
                                    ref s,
                                )) = f.args[0]
                                {
                                    if s == " " {
                                        // Wrap second arg in CAST(... AS BIGINT) if not already
                                        if !matches!(f.args[1], Expression::Cast(_)) {
                                            let mut new_args = f.args.clone();
                                            new_args[1] = Expression::Cast(Box::new(
                                                crate::expressions::Cast {
                                                    this: new_args[1].clone(),
                                                    to: crate::expressions::DataType::BigInt {
                                                        length: None,
                                                    },
                                                    trailing_comments: Vec::new(),
                                                    double_colon_syntax: false,
                                                    format: None,
                                                    default: None,
                                                },
                                            ));
                                            return Ok(Expression::Function(Box::new(
                                                crate::expressions::Function {
                                                    name: f.name.clone(),
                                                    args: new_args,
                                                    distinct: f.distinct,
                                                    trailing_comments: f.trailing_comments.clone(),
                                                    use_bracket_syntax: f.use_bracket_syntax,
                                                    no_parens: f.no_parens,
                                                    quoted: f.quoted,
                                                },
                                            )));
                                        }
                                    }
                                }
                            }
                        }
                        Ok(e)
                    })?
                } else {
                    normalized
                };

                // Propagate struct field names in arrays (for BigQuery source to non-BigQuery target)
                // BigQuery->BigQuery should NOT propagate names (BigQuery handles implicit inheritance)
                let normalized = if matches!(self.dialect_type, DialectType::BigQuery)
                    && !matches!(target, DialectType::BigQuery)
                {
                    crate::transforms::propagate_struct_field_names(normalized)?
                } else {
                    normalized
                };

                // Apply cross-dialect semantic normalizations
                let normalized =
                    Self::cross_dialect_normalize(normalized, self.dialect_type, target)?;

                // For DuckDB target from BigQuery source: wrap UNNEST of struct arrays in
                // (SELECT UNNEST(..., max_depth => 2)) subquery
                // Must run BEFORE unnest_alias_to_column_alias since it changes alias structure
                let normalized = if matches!(self.dialect_type, DialectType::BigQuery)
                    && matches!(target, DialectType::DuckDB)
                {
                    crate::transforms::wrap_duckdb_unnest_struct(normalized)?
                } else {
                    normalized
                };

                // Convert BigQuery UNNEST aliases to column-alias format for DuckDB/Presto/Spark
                // UNNEST(arr) AS x -> UNNEST(arr) AS _t0(x)
                let normalized = if matches!(self.dialect_type, DialectType::BigQuery)
                    && matches!(
                        target,
                        DialectType::DuckDB
                            | DialectType::Presto
                            | DialectType::Trino
                            | DialectType::Athena
                            | DialectType::Spark
                            | DialectType::Databricks
                    ) {
                    crate::transforms::unnest_alias_to_column_alias(normalized)?
                } else if matches!(self.dialect_type, DialectType::BigQuery)
                    && matches!(target, DialectType::BigQuery | DialectType::Redshift)
                {
                    // For BigQuery/Redshift targets: move UNNEST FROM items to CROSS JOINs
                    // but don't convert alias format (no _t0 wrapper)
                    let result = crate::transforms::unnest_from_to_cross_join(normalized)?;
                    // For Redshift: strip UNNEST when arg is a column reference path
                    if matches!(target, DialectType::Redshift) {
                        crate::transforms::strip_unnest_column_refs(result)?
                    } else {
                        result
                    }
                } else {
                    normalized
                };

                // For Presto/Trino targets from PostgreSQL/Redshift source:
                // Wrap UNNEST aliases from GENERATE_SERIES conversion: AS s -> AS _u(s)
                let normalized = if matches!(
                    self.dialect_type,
                    DialectType::PostgreSQL | DialectType::Redshift
                ) && matches!(
                    target,
                    DialectType::Presto | DialectType::Trino | DialectType::Athena
                ) {
                    crate::transforms::wrap_unnest_join_aliases(normalized)?
                } else {
                    normalized
                };

                // Eliminate DISTINCT ON with target-dialect awareness
                // This must happen after source transform (which may produce DISTINCT ON)
                // and before target transform, with knowledge of the target dialect's NULL ordering behavior
                let normalized =
                    crate::transforms::eliminate_distinct_on_for_dialect(normalized, Some(target))?;

                // GENERATE_DATE_ARRAY in UNNEST -> Snowflake ARRAY_GENERATE_RANGE + DATEADD
                let normalized = if matches!(target, DialectType::Snowflake) {
                    Self::transform_generate_date_array_snowflake(normalized)?
                } else {
                    normalized
                };

                // CROSS JOIN UNNEST -> LATERAL VIEW EXPLODE/INLINE for Spark/Hive/Databricks
                let normalized = if matches!(
                    target,
                    DialectType::Spark | DialectType::Databricks | DialectType::Hive
                ) {
                    crate::transforms::unnest_to_explode_select(normalized)?
                } else {
                    normalized
                };

                // Wrap UNION with ORDER BY/LIMIT in a subquery for dialects that require it
                let normalized = if matches!(target, DialectType::ClickHouse | DialectType::TSQL) {
                    crate::transforms::no_limit_order_by_union(normalized)?
                } else {
                    normalized
                };

                // TSQL: Convert COUNT(*) -> COUNT_BIG(*) when source is not TSQL/Fabric
                // Python sqlglot does this in the TSQL generator, but we can't do it there
                // because it would break TSQL -> TSQL identity
                let normalized = if matches!(target, DialectType::TSQL | DialectType::Fabric)
                    && !matches!(self.dialect_type, DialectType::TSQL | DialectType::Fabric)
                {
                    transform_recursive(normalized, &|e| {
                        if let Expression::Count(ref c) = e {
                            // Build COUNT_BIG(...) as an AggregateFunction
                            let args = if c.star {
                                vec![Expression::Star(crate::expressions::Star {
                                    table: None,
                                    except: None,
                                    replace: None,
                                    rename: None,
                                    trailing_comments: Vec::new(),
                                })]
                            } else if let Some(ref this) = c.this {
                                vec![this.clone()]
                            } else {
                                vec![]
                            };
                            Ok(Expression::AggregateFunction(Box::new(
                                crate::expressions::AggregateFunction {
                                    name: "COUNT_BIG".to_string(),
                                    args,
                                    distinct: c.distinct,
                                    filter: c.filter.clone(),
                                    order_by: Vec::new(),
                                    limit: None,
                                    ignore_nulls: None,
                                },
                            )))
                        } else {
                            Ok(e)
                        }
                    })?
                } else {
                    normalized
                };

                let transformed = target_dialect.transform(normalized)?;
                let mut sql = if pretty {
                    target_dialect.generate_pretty_with_source(&transformed, self.dialect_type)?
                } else {
                    target_dialect.generate_with_source(&transformed, self.dialect_type)?
                };

                // Align a known Snowflake pretty-print edge case with Python sqlglot output.
                if pretty && target == DialectType::Snowflake {
                    sql = Self::normalize_snowflake_pretty(sql);
                }

                Ok(sql)
            })
            .collect()
    }
}

// Transpile-only methods: cross-dialect normalization and helpers
#[cfg(feature = "transpile")]
impl Dialect {
    /// Transform BigQuery GENERATE_DATE_ARRAY in UNNEST for Snowflake target.
    /// Converts:
    ///   SELECT ..., alias, ... FROM t CROSS JOIN UNNEST(GENERATE_DATE_ARRAY(start, end, INTERVAL '1' unit)) AS alias
    /// To:
    ///   SELECT ..., DATEADD(unit, CAST(alias AS INT), CAST(start AS DATE)) AS alias, ...
    ///   FROM t, LATERAL FLATTEN(INPUT => ARRAY_GENERATE_RANGE(0, (DATEDIFF(unit, start, end) + 1 - 1) + 1)) AS _t0(seq, key, path, index, alias, this)
    fn transform_generate_date_array_snowflake(expr: Expression) -> Result<Expression> {
        use crate::expressions::*;
        transform_recursive(expr, &|e| {
            // Handle ARRAY_SIZE(GENERATE_DATE_ARRAY(...)) -> ARRAY_SIZE((SELECT ARRAY_AGG(*) FROM subquery))
            if let Expression::ArraySize(ref af) = e {
                if let Expression::Function(ref f) = af.this {
                    if f.name.eq_ignore_ascii_case("GENERATE_DATE_ARRAY") && f.args.len() >= 2 {
                        let result = Self::convert_array_size_gda_snowflake(f)?;
                        return Ok(result);
                    }
                }
            }

            let Expression::Select(mut sel) = e else {
                return Ok(e);
            };

            // Find joins with UNNEST containing GenerateSeries (from GENERATE_DATE_ARRAY conversion)
            let mut gda_info: Option<(String, Expression, Expression, String)> = None; // (alias_name, start_expr, end_expr, unit)
            let mut gda_join_idx: Option<usize> = None;

            for (idx, join) in sel.joins.iter().enumerate() {
                // The join.this may be:
                // 1. Unnest(UnnestFunc { alias: Some("mnth"), ... })
                // 2. Alias(Alias { this: Unnest(UnnestFunc { alias: None, ... }), alias: "mnth", ... })
                let (unnest_ref, alias_name) = match &join.this {
                    Expression::Unnest(ref unnest) => {
                        let alias = unnest.alias.as_ref().map(|id| id.name.clone());
                        (Some(unnest.as_ref()), alias)
                    }
                    Expression::Alias(ref a) => {
                        if let Expression::Unnest(ref unnest) = a.this {
                            (Some(unnest.as_ref()), Some(a.alias.name.clone()))
                        } else {
                            (None, None)
                        }
                    }
                    _ => (None, None),
                };

                if let (Some(unnest), Some(alias)) = (unnest_ref, alias_name) {
                    // Check the main expression (this) of the UNNEST for GENERATE_DATE_ARRAY function
                    if let Expression::Function(ref f) = unnest.this {
                        if f.name.eq_ignore_ascii_case("GENERATE_DATE_ARRAY") && f.args.len() >= 2 {
                            let start_expr = f.args[0].clone();
                            let end_expr = f.args[1].clone();
                            let step = f.args.get(2).cloned();

                            // Extract unit from step interval
                            let unit = if let Some(Expression::Interval(ref iv)) = step {
                                if let Some(IntervalUnitSpec::Simple { ref unit, .. }) = iv.unit {
                                    Some(format!("{:?}", unit).to_uppercase())
                                } else if let Some(ref this) = iv.this {
                                    // The interval may be stored as a string like "1 MONTH"
                                    if let Expression::Literal(Literal::String(ref s)) = this {
                                        let parts: Vec<&str> = s.split_whitespace().collect();
                                        if parts.len() == 2 {
                                            Some(parts[1].to_uppercase())
                                        } else if parts.len() == 1 {
                                            // Single word like "MONTH" or just "1"
                                            let upper = parts[0].to_uppercase();
                                            if matches!(
                                                upper.as_str(),
                                                "YEAR"
                                                    | "QUARTER"
                                                    | "MONTH"
                                                    | "WEEK"
                                                    | "DAY"
                                                    | "HOUR"
                                                    | "MINUTE"
                                                    | "SECOND"
                                            ) {
                                                Some(upper)
                                            } else {
                                                None
                                            }
                                        } else {
                                            None
                                        }
                                    } else {
                                        None
                                    }
                                } else {
                                    None
                                }
                            } else {
                                None
                            };

                            if let Some(unit_str) = unit {
                                gda_info = Some((alias, start_expr, end_expr, unit_str));
                                gda_join_idx = Some(idx);
                            }
                        }
                    }
                }
                if gda_info.is_some() {
                    break;
                }
            }

            let Some((alias_name, start_expr, end_expr, unit_str)) = gda_info else {
                // Also check FROM clause for UNNEST(GENERATE_DATE_ARRAY(...)) patterns
                // This handles Generic->Snowflake where GENERATE_DATE_ARRAY is in FROM, not in JOIN
                let result = Self::try_transform_from_gda_snowflake(sel);
                return result;
            };
            let join_idx = gda_join_idx.unwrap();

            // Build ARRAY_GENERATE_RANGE(0, (DATEDIFF(unit, start, end) + 1 - 1) + 1)
            let datediff = Expression::Function(Box::new(Function::new(
                "DATEDIFF".to_string(),
                vec![
                    Expression::Column(Column {
                        name: Identifier::new(&unit_str),
                        table: None,
                        join_mark: false,
                        trailing_comments: vec![],
                    }),
                    start_expr.clone(),
                    end_expr.clone(),
                ],
            )));
            // (DATEDIFF(...) + 1 - 1) + 1
            let plus_one = Expression::Add(Box::new(BinaryOp {
                left: datediff,
                right: Expression::Literal(Literal::Number("1".to_string())),
                left_comments: vec![],
                operator_comments: vec![],
                trailing_comments: vec![],
            }));
            let minus_one = Expression::Sub(Box::new(BinaryOp {
                left: plus_one,
                right: Expression::Literal(Literal::Number("1".to_string())),
                left_comments: vec![],
                operator_comments: vec![],
                trailing_comments: vec![],
            }));
            let paren_inner = Expression::Paren(Box::new(Paren {
                this: minus_one,
                trailing_comments: vec![],
            }));
            let outer_plus_one = Expression::Add(Box::new(BinaryOp {
                left: paren_inner,
                right: Expression::Literal(Literal::Number("1".to_string())),
                left_comments: vec![],
                operator_comments: vec![],
                trailing_comments: vec![],
            }));

            let array_gen_range = Expression::Function(Box::new(Function::new(
                "ARRAY_GENERATE_RANGE".to_string(),
                vec![
                    Expression::Literal(Literal::Number("0".to_string())),
                    outer_plus_one,
                ],
            )));

            // Build FLATTEN(INPUT => ARRAY_GENERATE_RANGE(...))
            let flatten_input = Expression::NamedArgument(Box::new(NamedArgument {
                name: Identifier::new("INPUT"),
                value: array_gen_range,
                separator: crate::expressions::NamedArgSeparator::DArrow,
            }));
            let flatten = Expression::Function(Box::new(Function::new(
                "FLATTEN".to_string(),
                vec![flatten_input],
            )));

            // Build LATERAL FLATTEN(...) AS _t0(seq, key, path, index, alias, this)
            let alias_table = Alias {
                this: flatten,
                alias: Identifier::new("_t0"),
                column_aliases: vec![
                    Identifier::new("seq"),
                    Identifier::new("key"),
                    Identifier::new("path"),
                    Identifier::new("index"),
                    Identifier::new(&alias_name),
                    Identifier::new("this"),
                ],
                pre_alias_comments: vec![],
                trailing_comments: vec![],
            };
            let lateral_expr = Expression::Lateral(Box::new(Lateral {
                this: Box::new(Expression::Alias(Box::new(alias_table))),
                view: None,
                outer: None,
                alias: None,
                alias_quoted: false,
                cross_apply: None,
                ordinality: None,
                column_aliases: vec![],
            }));

            // Remove the original join and add to FROM expressions
            sel.joins.remove(join_idx);
            if let Some(ref mut from) = sel.from {
                from.expressions.push(lateral_expr);
            }

            // Build DATEADD(unit, CAST(alias AS INT), CAST(start AS DATE))
            let dateadd_expr = Expression::Function(Box::new(Function::new(
                "DATEADD".to_string(),
                vec![
                    Expression::Column(Column {
                        name: Identifier::new(&unit_str),
                        table: None,
                        join_mark: false,
                        trailing_comments: vec![],
                    }),
                    Expression::Cast(Box::new(Cast {
                        this: Expression::Column(Column {
                            name: Identifier::new(&alias_name),
                            table: None,
                            join_mark: false,
                            trailing_comments: vec![],
                        }),
                        to: DataType::Int {
                            length: None,
                            integer_spelling: false,
                        },
                        trailing_comments: vec![],
                        double_colon_syntax: false,
                        format: None,
                        default: None,
                    })),
                    Expression::Cast(Box::new(Cast {
                        this: start_expr.clone(),
                        to: DataType::Date,
                        trailing_comments: vec![],
                        double_colon_syntax: false,
                        format: None,
                        default: None,
                    })),
                ],
            )));

            // Replace references to the alias in the SELECT list
            let new_exprs: Vec<Expression> = sel
                .expressions
                .iter()
                .map(|expr| Self::replace_column_ref_with_dateadd(expr, &alias_name, &dateadd_expr))
                .collect();
            sel.expressions = new_exprs;

            Ok(Expression::Select(sel))
        })
    }

    /// Helper: replace column references to `alias_name` with dateadd expression
    fn replace_column_ref_with_dateadd(
        expr: &Expression,
        alias_name: &str,
        dateadd: &Expression,
    ) -> Expression {
        use crate::expressions::*;
        match expr {
            Expression::Column(c) if c.name.name == alias_name && c.table.is_none() => {
                // Plain column reference -> DATEADD(...) AS alias_name
                Expression::Alias(Box::new(Alias {
                    this: dateadd.clone(),
                    alias: Identifier::new(alias_name),
                    column_aliases: vec![],
                    pre_alias_comments: vec![],
                    trailing_comments: vec![],
                }))
            }
            Expression::Alias(a) => {
                // Check if the inner expression references the alias
                let new_this = Self::replace_column_ref_inner(&a.this, alias_name, dateadd);
                Expression::Alias(Box::new(Alias {
                    this: new_this,
                    alias: a.alias.clone(),
                    column_aliases: a.column_aliases.clone(),
                    pre_alias_comments: a.pre_alias_comments.clone(),
                    trailing_comments: a.trailing_comments.clone(),
                }))
            }
            _ => expr.clone(),
        }
    }

    /// Helper: replace column references in inner expression (not top-level)
    fn replace_column_ref_inner(
        expr: &Expression,
        alias_name: &str,
        dateadd: &Expression,
    ) -> Expression {
        use crate::expressions::*;
        match expr {
            Expression::Column(c) if c.name.name == alias_name && c.table.is_none() => {
                dateadd.clone()
            }
            Expression::Add(op) => {
                let left = Self::replace_column_ref_inner(&op.left, alias_name, dateadd);
                let right = Self::replace_column_ref_inner(&op.right, alias_name, dateadd);
                Expression::Add(Box::new(BinaryOp {
                    left,
                    right,
                    left_comments: op.left_comments.clone(),
                    operator_comments: op.operator_comments.clone(),
                    trailing_comments: op.trailing_comments.clone(),
                }))
            }
            Expression::Sub(op) => {
                let left = Self::replace_column_ref_inner(&op.left, alias_name, dateadd);
                let right = Self::replace_column_ref_inner(&op.right, alias_name, dateadd);
                Expression::Sub(Box::new(BinaryOp {
                    left,
                    right,
                    left_comments: op.left_comments.clone(),
                    operator_comments: op.operator_comments.clone(),
                    trailing_comments: op.trailing_comments.clone(),
                }))
            }
            Expression::Mul(op) => {
                let left = Self::replace_column_ref_inner(&op.left, alias_name, dateadd);
                let right = Self::replace_column_ref_inner(&op.right, alias_name, dateadd);
                Expression::Mul(Box::new(BinaryOp {
                    left,
                    right,
                    left_comments: op.left_comments.clone(),
                    operator_comments: op.operator_comments.clone(),
                    trailing_comments: op.trailing_comments.clone(),
                }))
            }
            _ => expr.clone(),
        }
    }

    /// Handle UNNEST(GENERATE_DATE_ARRAY(...)) in FROM clause for Snowflake target.
    /// Converts to a subquery with DATEADD + TABLE(FLATTEN(ARRAY_GENERATE_RANGE(...))).
    fn try_transform_from_gda_snowflake(
        mut sel: Box<crate::expressions::Select>,
    ) -> Result<Expression> {
        use crate::expressions::*;

        // Extract GDA info from FROM clause
        let mut gda_info: Option<(
            usize,
            String,
            Expression,
            Expression,
            String,
            Option<(String, Vec<Identifier>)>,
        )> = None; // (from_idx, col_name, start, end, unit, outer_alias)

        if let Some(ref from) = sel.from {
            for (idx, table_expr) in from.expressions.iter().enumerate() {
                // Pattern 1: UNNEST(GENERATE_DATE_ARRAY(...))
                // Pattern 2: Alias(UNNEST(GENERATE_DATE_ARRAY(...))) AS _q(date_week)
                let (unnest_opt, outer_alias_info) = match table_expr {
                    Expression::Unnest(ref unnest) => (Some(unnest.as_ref()), None),
                    Expression::Alias(ref a) => {
                        if let Expression::Unnest(ref unnest) = a.this {
                            let alias_info = (a.alias.name.clone(), a.column_aliases.clone());
                            (Some(unnest.as_ref()), Some(alias_info))
                        } else {
                            (None, None)
                        }
                    }
                    _ => (None, None),
                };

                if let Some(unnest) = unnest_opt {
                    // Check for GENERATE_DATE_ARRAY function
                    let func_opt = match &unnest.this {
                        Expression::Function(ref f)
                            if f.name.eq_ignore_ascii_case("GENERATE_DATE_ARRAY")
                                && f.args.len() >= 2 =>
                        {
                            Some(f)
                        }
                        // Also check for GenerateSeries (from earlier normalization)
                        _ => None,
                    };

                    if let Some(f) = func_opt {
                        let start_expr = f.args[0].clone();
                        let end_expr = f.args[1].clone();
                        let step = f.args.get(2).cloned();

                        // Extract unit and column name
                        let unit = Self::extract_interval_unit_str(&step);
                        let col_name = outer_alias_info
                            .as_ref()
                            .and_then(|(_, cols)| cols.first().map(|id| id.name.clone()))
                            .unwrap_or_else(|| "value".to_string());

                        if let Some(unit_str) = unit {
                            gda_info = Some((
                                idx,
                                col_name,
                                start_expr,
                                end_expr,
                                unit_str,
                                outer_alias_info,
                            ));
                            break;
                        }
                    }
                }
            }
        }

        let Some((from_idx, col_name, start_expr, end_expr, unit_str, outer_alias_info)) = gda_info
        else {
            return Ok(Expression::Select(sel));
        };

        // Build the Snowflake subquery:
        // (SELECT DATEADD(unit, CAST(col_name AS INT), CAST(start AS DATE)) AS col_name
        //  FROM TABLE(FLATTEN(INPUT => ARRAY_GENERATE_RANGE(0, (DATEDIFF(unit, start, end) + 1 - 1) + 1))) AS _t0(seq, key, path, index, col_name, this))

        // DATEDIFF(unit, start, end)
        let datediff = Expression::Function(Box::new(Function::new(
            "DATEDIFF".to_string(),
            vec![
                Expression::Column(Column {
                    name: Identifier::new(&unit_str),
                    table: None,
                    join_mark: false,
                    trailing_comments: vec![],
                }),
                start_expr.clone(),
                end_expr.clone(),
            ],
        )));
        // (DATEDIFF(...) + 1 - 1) + 1
        let plus_one = Expression::Add(Box::new(BinaryOp {
            left: datediff,
            right: Expression::Literal(Literal::Number("1".to_string())),
            left_comments: vec![],
            operator_comments: vec![],
            trailing_comments: vec![],
        }));
        let minus_one = Expression::Sub(Box::new(BinaryOp {
            left: plus_one,
            right: Expression::Literal(Literal::Number("1".to_string())),
            left_comments: vec![],
            operator_comments: vec![],
            trailing_comments: vec![],
        }));
        let paren_inner = Expression::Paren(Box::new(Paren {
            this: minus_one,
            trailing_comments: vec![],
        }));
        let outer_plus_one = Expression::Add(Box::new(BinaryOp {
            left: paren_inner,
            right: Expression::Literal(Literal::Number("1".to_string())),
            left_comments: vec![],
            operator_comments: vec![],
            trailing_comments: vec![],
        }));

        let array_gen_range = Expression::Function(Box::new(Function::new(
            "ARRAY_GENERATE_RANGE".to_string(),
            vec![
                Expression::Literal(Literal::Number("0".to_string())),
                outer_plus_one,
            ],
        )));

        // TABLE(FLATTEN(INPUT => ...))
        let flatten_input = Expression::NamedArgument(Box::new(NamedArgument {
            name: Identifier::new("INPUT"),
            value: array_gen_range,
            separator: crate::expressions::NamedArgSeparator::DArrow,
        }));
        let flatten = Expression::Function(Box::new(Function::new(
            "FLATTEN".to_string(),
            vec![flatten_input],
        )));

        // Determine alias name for the table: use outer alias or _t0
        let table_alias_name = outer_alias_info
            .as_ref()
            .map(|(name, _)| name.clone())
            .unwrap_or_else(|| "_t0".to_string());

        // TABLE(FLATTEN(...)) AS _t0(seq, key, path, index, col_name, this)
        let table_func =
            Expression::Function(Box::new(Function::new("TABLE".to_string(), vec![flatten])));
        let flatten_aliased = Expression::Alias(Box::new(Alias {
            this: table_func,
            alias: Identifier::new(&table_alias_name),
            column_aliases: vec![
                Identifier::new("seq"),
                Identifier::new("key"),
                Identifier::new("path"),
                Identifier::new("index"),
                Identifier::new(&col_name),
                Identifier::new("this"),
            ],
            pre_alias_comments: vec![],
            trailing_comments: vec![],
        }));

        // SELECT DATEADD(unit, CAST(col_name AS INT), CAST(start AS DATE)) AS col_name
        let dateadd_expr = Expression::Function(Box::new(Function::new(
            "DATEADD".to_string(),
            vec![
                Expression::Column(Column {
                    name: Identifier::new(&unit_str),
                    table: None,
                    join_mark: false,
                    trailing_comments: vec![],
                }),
                Expression::Cast(Box::new(Cast {
                    this: Expression::Column(Column {
                        name: Identifier::new(&col_name),
                        table: None,
                        join_mark: false,
                        trailing_comments: vec![],
                    }),
                    to: DataType::Int {
                        length: None,
                        integer_spelling: false,
                    },
                    trailing_comments: vec![],
                    double_colon_syntax: false,
                    format: None,
                    default: None,
                })),
                // Use start_expr directly - it's already been normalized (DATE literal -> CAST)
                start_expr.clone(),
            ],
        )));
        let dateadd_aliased = Expression::Alias(Box::new(Alias {
            this: dateadd_expr,
            alias: Identifier::new(&col_name),
            column_aliases: vec![],
            pre_alias_comments: vec![],
            trailing_comments: vec![],
        }));

        // Build inner SELECT
        let mut inner_select = Select::new();
        inner_select.expressions = vec![dateadd_aliased];
        inner_select.from = Some(From {
            expressions: vec![flatten_aliased],
        });

        let inner_select_expr = Expression::Select(Box::new(inner_select));
        let subquery = Expression::Subquery(Box::new(Subquery {
            this: inner_select_expr,
            alias: None,
            column_aliases: vec![],
            order_by: None,
            limit: None,
            offset: None,
            distribute_by: None,
            sort_by: None,
            cluster_by: None,
            lateral: false,
            modifiers_inside: false,
            trailing_comments: vec![],
        }));

        // If there was an outer alias (e.g., AS _q(date_week)), wrap with alias
        let replacement = if let Some((alias_name, col_aliases)) = outer_alias_info {
            Expression::Alias(Box::new(Alias {
                this: subquery,
                alias: Identifier::new(&alias_name),
                column_aliases: col_aliases,
                pre_alias_comments: vec![],
                trailing_comments: vec![],
            }))
        } else {
            subquery
        };

        // Replace the FROM expression
        if let Some(ref mut from) = sel.from {
            from.expressions[from_idx] = replacement;
        }

        Ok(Expression::Select(sel))
    }

    /// Convert ARRAY_SIZE(GENERATE_DATE_ARRAY(start, end, step)) for Snowflake.
    /// Produces: ARRAY_SIZE((SELECT ARRAY_AGG(*) FROM (SELECT DATEADD(unit, CAST(value AS INT), start) AS value
    ///   FROM TABLE(FLATTEN(INPUT => ARRAY_GENERATE_RANGE(0, (DATEDIFF(unit, start, end) + 1 - 1) + 1))) AS _t0(...))))
    fn convert_array_size_gda_snowflake(f: &crate::expressions::Function) -> Result<Expression> {
        use crate::expressions::*;

        let start_expr = f.args[0].clone();
        let end_expr = f.args[1].clone();
        let step = f.args.get(2).cloned();
        let unit_str = Self::extract_interval_unit_str(&step).unwrap_or_else(|| "DAY".to_string());
        let col_name = "value";

        // Build the inner subquery: same as try_transform_from_gda_snowflake
        let datediff = Expression::Function(Box::new(Function::new(
            "DATEDIFF".to_string(),
            vec![
                Expression::Column(Column {
                    name: Identifier::new(&unit_str),
                    table: None,
                    join_mark: false,
                    trailing_comments: vec![],
                }),
                start_expr.clone(),
                end_expr.clone(),
            ],
        )));
        let plus_one = Expression::Add(Box::new(BinaryOp {
            left: datediff,
            right: Expression::Literal(Literal::Number("1".to_string())),
            left_comments: vec![],
            operator_comments: vec![],
            trailing_comments: vec![],
        }));
        let minus_one = Expression::Sub(Box::new(BinaryOp {
            left: plus_one,
            right: Expression::Literal(Literal::Number("1".to_string())),
            left_comments: vec![],
            operator_comments: vec![],
            trailing_comments: vec![],
        }));
        let paren_inner = Expression::Paren(Box::new(Paren {
            this: minus_one,
            trailing_comments: vec![],
        }));
        let outer_plus_one = Expression::Add(Box::new(BinaryOp {
            left: paren_inner,
            right: Expression::Literal(Literal::Number("1".to_string())),
            left_comments: vec![],
            operator_comments: vec![],
            trailing_comments: vec![],
        }));

        let array_gen_range = Expression::Function(Box::new(Function::new(
            "ARRAY_GENERATE_RANGE".to_string(),
            vec![
                Expression::Literal(Literal::Number("0".to_string())),
                outer_plus_one,
            ],
        )));

        let flatten_input = Expression::NamedArgument(Box::new(NamedArgument {
            name: Identifier::new("INPUT"),
            value: array_gen_range,
            separator: crate::expressions::NamedArgSeparator::DArrow,
        }));
        let flatten = Expression::Function(Box::new(Function::new(
            "FLATTEN".to_string(),
            vec![flatten_input],
        )));

        let table_func =
            Expression::Function(Box::new(Function::new("TABLE".to_string(), vec![flatten])));
        let flatten_aliased = Expression::Alias(Box::new(Alias {
            this: table_func,
            alias: Identifier::new("_t0"),
            column_aliases: vec![
                Identifier::new("seq"),
                Identifier::new("key"),
                Identifier::new("path"),
                Identifier::new("index"),
                Identifier::new(col_name),
                Identifier::new("this"),
            ],
            pre_alias_comments: vec![],
            trailing_comments: vec![],
        }));

        let dateadd_expr = Expression::Function(Box::new(Function::new(
            "DATEADD".to_string(),
            vec![
                Expression::Column(Column {
                    name: Identifier::new(&unit_str),
                    table: None,
                    join_mark: false,
                    trailing_comments: vec![],
                }),
                Expression::Cast(Box::new(Cast {
                    this: Expression::Column(Column {
                        name: Identifier::new(col_name),
                        table: None,
                        join_mark: false,
                        trailing_comments: vec![],
                    }),
                    to: DataType::Int {
                        length: None,
                        integer_spelling: false,
                    },
                    trailing_comments: vec![],
                    double_colon_syntax: false,
                    format: None,
                    default: None,
                })),
                start_expr.clone(),
            ],
        )));
        let dateadd_aliased = Expression::Alias(Box::new(Alias {
            this: dateadd_expr,
            alias: Identifier::new(col_name),
            column_aliases: vec![],
            pre_alias_comments: vec![],
            trailing_comments: vec![],
        }));

        // Inner SELECT: SELECT DATEADD(...) AS value FROM TABLE(FLATTEN(...)) AS _t0(...)
        let mut inner_select = Select::new();
        inner_select.expressions = vec![dateadd_aliased];
        inner_select.from = Some(From {
            expressions: vec![flatten_aliased],
        });

        // Wrap in subquery for the inner part
        let inner_subquery = Expression::Subquery(Box::new(Subquery {
            this: Expression::Select(Box::new(inner_select)),
            alias: None,
            column_aliases: vec![],
            order_by: None,
            limit: None,
            offset: None,
            distribute_by: None,
            sort_by: None,
            cluster_by: None,
            lateral: false,
            modifiers_inside: false,
            trailing_comments: vec![],
        }));

        // Outer: SELECT ARRAY_AGG(*) FROM (inner_subquery)
        let star = Expression::Star(Star {
            table: None,
            except: None,
            replace: None,
            rename: None,
            trailing_comments: vec![],
        });
        let array_agg = Expression::ArrayAgg(Box::new(AggFunc {
            this: star,
            distinct: false,
            filter: None,
            order_by: vec![],
            name: Some("ARRAY_AGG".to_string()),
            ignore_nulls: None,
            having_max: None,
            limit: None,
        }));

        let mut outer_select = Select::new();
        outer_select.expressions = vec![array_agg];
        outer_select.from = Some(From {
            expressions: vec![inner_subquery],
        });

        // Wrap in a subquery
        let outer_subquery = Expression::Subquery(Box::new(Subquery {
            this: Expression::Select(Box::new(outer_select)),
            alias: None,
            column_aliases: vec![],
            order_by: None,
            limit: None,
            offset: None,
            distribute_by: None,
            sort_by: None,
            cluster_by: None,
            lateral: false,
            modifiers_inside: false,
            trailing_comments: vec![],
        }));

        // ARRAY_SIZE(subquery)
        Ok(Expression::ArraySize(Box::new(UnaryFunc::new(
            outer_subquery,
        ))))
    }

    /// Extract interval unit string from an optional step expression.
    fn extract_interval_unit_str(step: &Option<Expression>) -> Option<String> {
        use crate::expressions::*;
        if let Some(Expression::Interval(ref iv)) = step {
            if let Some(IntervalUnitSpec::Simple { ref unit, .. }) = iv.unit {
                return Some(format!("{:?}", unit).to_uppercase());
            }
            if let Some(ref this) = iv.this {
                if let Expression::Literal(Literal::String(ref s)) = this {
                    let parts: Vec<&str> = s.split_whitespace().collect();
                    if parts.len() == 2 {
                        return Some(parts[1].to_uppercase());
                    } else if parts.len() == 1 {
                        let upper = parts[0].to_uppercase();
                        if matches!(
                            upper.as_str(),
                            "YEAR"
                                | "QUARTER"
                                | "MONTH"
                                | "WEEK"
                                | "DAY"
                                | "HOUR"
                                | "MINUTE"
                                | "SECOND"
                        ) {
                            return Some(upper);
                        }
                    }
                }
            }
        }
        // Default to DAY if no step or no interval
        if step.is_none() {
            return Some("DAY".to_string());
        }
        None
    }

    fn normalize_snowflake_pretty(mut sql: String) -> String {
        if sql.contains("LATERAL IFF(_u.pos = _u_2.pos_2, _u_2.entity, NULL) AS datasource(SEQ, KEY, PATH, INDEX, VALUE, THIS)")
            && sql.contains("ARRAY_GENERATE_RANGE(0, (GREATEST(ARRAY_SIZE(INPUT => PARSE_JSON(flags))) - 1) + 1)")
        {
            sql = sql.replace(
                "AND uc.user_id <> ALL (SELECT DISTINCT\n      _id\n    FROM users, LATERAL IFF(_u.pos = _u_2.pos_2, _u_2.entity, NULL) AS datasource(SEQ, KEY, PATH, INDEX, VALUE, THIS)\n    WHERE\n      GET_PATH(datasource.value, 'name') = 'something')",
                "AND uc.user_id <> ALL (\n      SELECT DISTINCT\n        _id\n      FROM users, LATERAL IFF(_u.pos = _u_2.pos_2, _u_2.entity, NULL) AS datasource(SEQ, KEY, PATH, INDEX, VALUE, THIS)\n      WHERE\n        GET_PATH(datasource.value, 'name') = 'something'\n    )",
            );

            sql = sql.replace(
                "CROSS JOIN TABLE(FLATTEN(INPUT => ARRAY_GENERATE_RANGE(0, (GREATEST(ARRAY_SIZE(INPUT => PARSE_JSON(flags))) - 1) + 1))) AS _u(seq, key, path, index, pos, this)",
                "CROSS JOIN TABLE(FLATTEN(INPUT => ARRAY_GENERATE_RANGE(0, (\n  GREATEST(ARRAY_SIZE(INPUT => PARSE_JSON(flags))) - 1\n) + 1))) AS _u(seq, key, path, index, pos, this)",
            );

            sql = sql.replace(
                "OR (_u.pos > (ARRAY_SIZE(INPUT => PARSE_JSON(flags)) - 1)\n  AND _u_2.pos_2 = (ARRAY_SIZE(INPUT => PARSE_JSON(flags)) - 1))",
                "OR (\n    _u.pos > (\n      ARRAY_SIZE(INPUT => PARSE_JSON(flags)) - 1\n    )\n    AND _u_2.pos_2 = (\n      ARRAY_SIZE(INPUT => PARSE_JSON(flags)) - 1\n    )\n  )",
            );
        }

        sql
    }

    /// Apply cross-dialect semantic normalizations that depend on knowing both source and target.
    /// This handles cases where the same syntax has different semantics across dialects.
    fn cross_dialect_normalize(
        expr: Expression,
        source: DialectType,
        target: DialectType,
    ) -> Result<Expression> {
        use crate::expressions::{
            AggFunc, BinaryOp, Case, Cast, ConvertTimezone, DataType, DateTimeField, DateTruncFunc,
            Function, Identifier, IsNull, Literal, Null, Paren,
        };

        // Helper to tag which kind of transform to apply
        #[derive(Debug)]
        enum Action {
            None,
            GreatestLeastNull,
            ArrayGenerateRange,
            Div0TypedDivision,
            ArrayAggCollectList,
            ArrayAggWithinGroupFilter,
            ArrayAggFilter,
            CastTimestampToDatetime,
            DateTruncWrapCast,
            ToDateToCast,
            ConvertTimezoneToExpr,
            SetToVariable,
            RegexpReplaceSnowflakeToDuckDB,
            BigQueryFunctionNormalize,
            BigQuerySafeDivide,
            BigQueryCastType,
            BigQueryToHexBare,        // _BQ_TO_HEX(x) with no LOWER/UPPER wrapper
            BigQueryToHexLower,       // LOWER(_BQ_TO_HEX(x))
            BigQueryToHexUpper,       // UPPER(_BQ_TO_HEX(x))
            BigQueryLastDayStripUnit, // LAST_DAY(date, MONTH) -> LAST_DAY(date)
            BigQueryCastFormat, // CAST(x AS type FORMAT 'fmt') -> PARSE_DATE/PARSE_TIMESTAMP etc.
            BigQueryAnyValueHaving, // ANY_VALUE(x HAVING MAX/MIN y) -> ARG_MAX_NULL/ARG_MIN_NULL for DuckDB
            BigQueryApproxQuantiles, // APPROX_QUANTILES(x, n) -> APPROX_QUANTILE(x, [quantiles]) for DuckDB
            GenericFunctionNormalize, // Cross-dialect function renaming (non-BigQuery sources)
            RegexpLikeToDuckDB, // RegexpLike -> REGEXP_MATCHES for DuckDB target (partial match)
            EpochConvert,       // Expression::Epoch -> target-specific epoch function
            EpochMsConvert,     // Expression::EpochMs -> target-specific epoch ms function
            TSQLTypeNormalize,  // TSQL types (MONEY, SMALLMONEY, REAL, DATETIME2) -> standard types
            MySQLSafeDivide,    // MySQL a/b -> a / NULLIF(b, 0) with optional CAST
            NullsOrdering,      // Add NULLS FIRST/LAST for ORDER BY
            AlterTableRenameStripSchema, // ALTER TABLE db.t1 RENAME TO db.t2 -> ALTER TABLE db.t1 RENAME TO t2
            StringAggConvert,            // STRING_AGG/WITHIN GROUP -> target-specific aggregate
            GroupConcatConvert,          // GROUP_CONCAT -> target-specific aggregate
            TempTableHash,               // TSQL #table -> temp table normalization
            ArrayLengthConvert,          // CARDINALITY/ARRAY_LENGTH/ARRAY_SIZE -> target-specific
            DatePartUnquote, // DATE_PART('month', x) -> DATE_PART(month, x) for Snowflake target
            NvlClearOriginal, // Clear NVL original_name for cross-dialect transpilation
            HiveCastToTryCast, // Hive/Spark CAST -> TRY_CAST for targets that support it
            XorExpand,       // MySQL XOR -> (a AND NOT b) OR (NOT a AND b) for non-XOR targets
            CastTimestampStripTz, // CAST(x AS TIMESTAMP WITH TIME ZONE) -> CAST(x AS TIMESTAMP) for Hive/Spark
            JsonExtractToGetJsonObject, // JSON_EXTRACT/JSON_EXTRACT_SCALAR -> GET_JSON_OBJECT for Hive/Spark
            JsonExtractScalarToGetJsonObject, // JSON_EXTRACT_SCALAR -> GET_JSON_OBJECT for Hive/Spark
            JsonQueryValueConvert, // JsonQuery/JsonValue -> target-specific (ISNULL wrapper for TSQL, GET_JSON_OBJECT for Spark, etc.)
            JsonLiteralToJsonParse, // JSON 'x' -> JSON_PARSE('x') for Presto, PARSE_JSON for Snowflake
            ArraySyntaxConvert,     // ARRAY[x] -> ARRAY(x) for Spark, [x] for BigQuery/DuckDB
            AtTimeZoneConvert, // AT TIME ZONE -> AT_TIMEZONE (Presto) / FROM_UTC_TIMESTAMP (Spark)
            DayOfWeekConvert,  // DAY_OF_WEEK -> dialect-specific
            MaxByMinByConvert, // MAX_BY/MIN_BY -> argMax/argMin for ClickHouse
            ArrayAggToCollectList, // ARRAY_AGG(x ORDER BY ...) -> COLLECT_LIST(x) for Hive/Spark
            ElementAtConvert, // ELEMENT_AT(arr, idx) -> arr[idx] for PostgreSQL, arr[SAFE_ORDINAL(idx)] for BigQuery
            CurrentUserParens, // CURRENT_USER -> CURRENT_USER() for Snowflake
            CastToJsonForSpark, // CAST(x AS JSON) -> TO_JSON(x) for Spark
            CastJsonToFromJson, // CAST(JSON_PARSE(literal) AS ARRAY/MAP) -> FROM_JSON(literal, type_string)
            ToJsonConvert,      // TO_JSON(x) -> JSON_FORMAT(CAST(x AS JSON)) for Presto etc.
            ArrayAggNullFilter, // ARRAY_AGG(x) FILTER(WHERE cond) -> add AND NOT x IS NULL for DuckDB
            ArrayAggIgnoreNullsDuckDB, // ARRAY_AGG(x IGNORE NULLS ORDER BY ...) -> ARRAY_AGG(x ORDER BY a NULLS FIRST, ...) for DuckDB
            BigQueryPercentileContToDuckDB, // PERCENTILE_CONT(x, frac RESPECT NULLS) -> QUANTILE_CONT(x, frac) for DuckDB
            BigQueryArraySelectAsStructToSnowflake, // ARRAY(SELECT AS STRUCT ...) -> (SELECT ARRAY_AGG(OBJECT_CONSTRUCT(...)))
            CountDistinctMultiArg, // COUNT(DISTINCT a, b) -> COUNT(DISTINCT CASE WHEN ... END)
            VarianceToClickHouse,  // Expression::Variance -> varSamp for ClickHouse
            StddevToClickHouse,    // Expression::Stddev -> stddevSamp for ClickHouse
            ApproxQuantileConvert, // Expression::ApproxQuantile -> APPROX_PERCENTILE for Snowflake
            ArrayIndexConvert,     // array[1] -> array[0] for BigQuery (1-based to 0-based)
            DollarParamConvert,    // $foo -> @foo for BigQuery
            TablesampleReservoir, // TABLESAMPLE (n ROWS) -> TABLESAMPLE RESERVOIR (n ROWS) for DuckDB
            BitAggFloatCast, // BIT_OR/BIT_AND/BIT_XOR float arg -> CAST(ROUND(CAST(arg)) AS INT) for DuckDB
            BitAggSnowflakeRename, // BIT_OR -> BITORAGG, BIT_AND -> BITANDAGG etc. for Snowflake
            StrftimeCastTimestamp, // CAST TIMESTAMP -> TIMESTAMP_NTZ for Spark in STRFTIME
            AnyValueIgnoreNulls, // ANY_VALUE(x) -> ANY_VALUE(x) IGNORE NULLS for Spark
            CreateTableStripComment, // Strip COMMENT column constraint, USING, PARTITIONED BY for DuckDB
            EscapeStringNormalize,   // e'Hello\nworld' literal newline -> \n
            AnyToExists,             // PostgreSQL x <op> ANY(array) -> EXISTS(array, x -> ...)
            ArrayConcatBracketConvert, // [1,2] -> ARRAY[1,2] for PostgreSQL in ARRAY_CAT
            SnowflakeIntervalFormat, // INTERVAL '2' HOUR -> INTERVAL '2 HOUR' for Snowflake
            AlterTableToSpRename,    // ALTER TABLE RENAME -> EXEC sp_rename for TSQL
            StraightJoinCase,        // STRAIGHT_JOIN -> straight_join for DuckDB
            RespectNullsConvert,     // RESPECT NULLS window function handling
            MysqlNullsOrdering,      // MySQL doesn't support NULLS ordering
            MysqlNullsLastRewrite, // Add CASE WHEN to ORDER BY for DuckDB -> MySQL (NULLS LAST simulation)
            BigQueryNullsOrdering, // BigQuery doesn't support NULLS FIRST/LAST - strip
            SnowflakeFloatProtect, // Protect FLOAT from being converted to DOUBLE by Snowflake target transform
            JsonToGetPath,         // JSON arrow -> GET_PATH/PARSE_JSON for Snowflake
            FilterToIff,           // FILTER(WHERE) -> IFF wrapping for Snowflake
            AggFilterToIff, // AggFunc.filter -> IFF wrapping for Snowflake (e.g., AVG(x) FILTER(WHERE cond))
            StructToRow,    // DuckDB struct -> Presto ROW / BigQuery STRUCT
            SparkStructConvert, // Spark STRUCT(x AS col1, ...) -> ROW/DuckDB struct
            DecimalDefaultPrecision, // DECIMAL -> DECIMAL(18, 3) for Snowflake in BIT agg
            ApproxCountDistinctToApproxDistinct, // APPROX_COUNT_DISTINCT -> APPROX_DISTINCT for Presto/Trino
            CollectListToArrayAgg,               // COLLECT_LIST -> ARRAY_AGG for Presto/DuckDB
            CollectSetConvert, // COLLECT_SET -> SET_AGG/ARRAY_AGG(DISTINCT)/ARRAY_UNIQUE_AGG
            PercentileConvert, // PERCENTILE -> QUANTILE/APPROX_PERCENTILE
            CorrIsnanWrap, // CORR(a,b) -> CASE WHEN ISNAN(CORR(a,b)) THEN NULL ELSE CORR(a,b) END
            TruncToDateTrunc, // TRUNC(ts, unit) -> DATE_TRUNC(unit, ts)
            ArrayContainsConvert, // ARRAY_CONTAINS -> CONTAINS/target-specific
            StrPositionExpand, // StrPosition with position -> complex STRPOS expansion for Presto/DuckDB
            TablesampleSnowflakeStrip, // Strip method and PERCENT for Snowflake target
            FirstToAnyValue,   // FIRST(col) IGNORE NULLS -> ANY_VALUE(col) for DuckDB
            MonthsBetweenConvert, // Expression::MonthsBetween -> target-specific
            CurrentUserSparkParens, // CURRENT_USER -> CURRENT_USER() for Spark
            SparkDateFuncCast, // MONTH/YEAR/DAY('str') -> MONTH/YEAR/DAY(CAST('str' AS DATE)) from Spark
            MapFromArraysConvert, // Expression::MapFromArrays -> MAP/OBJECT_CONSTRUCT/MAP_FROM_ARRAYS
            AddMonthsConvert,     // Expression::AddMonths -> target-specific DATEADD/DATE_ADD
            PercentileContConvert, // PERCENTILE_CONT/DISC WITHIN GROUP -> APPROX_PERCENTILE/PERCENTILE_APPROX
            GenerateSeriesConvert, // GENERATE_SERIES -> SEQUENCE/UNNEST(SEQUENCE)/EXPLODE(SEQUENCE)
            ConcatCoalesceWrap, // CONCAT(a, b) -> CONCAT(COALESCE(CAST(a), ''), ...) for Presto/ClickHouse
            PipeConcatToConcat, // a || b -> CONCAT(CAST(a), CAST(b)) for Presto
            DivFuncConvert,     // DIV(a, b) -> a // b for DuckDB, CAST for BigQuery
            JsonObjectAggConvert, // JSON_OBJECT_AGG -> JSON_GROUP_OBJECT for DuckDB
            JsonbExistsConvert, // JSONB_EXISTS -> JSON_EXISTS for DuckDB
            DateBinConvert,     // DATE_BIN -> TIME_BUCKET for DuckDB
            MysqlCastCharToText, // MySQL CAST(x AS CHAR) -> CAST(x AS TEXT/VARCHAR/STRING) for targets
            SparkCastVarcharToString, // Spark CAST(x AS VARCHAR/CHAR) -> CAST(x AS STRING) for Spark targets
            JsonExtractToArrow,       // JSON_EXTRACT(x, path) -> x -> path for SQLite/DuckDB
            JsonExtractToTsql, // JSON_EXTRACT/JSON_EXTRACT_SCALAR -> ISNULL(JSON_QUERY, JSON_VALUE) for TSQL
            JsonExtractToClickHouse, // JSON_EXTRACT/JSON_EXTRACT_SCALAR -> JSONExtractString for ClickHouse
            JsonExtractScalarConvert, // JSON_EXTRACT_SCALAR -> target-specific (PostgreSQL, Snowflake, SQLite)
            JsonPathNormalize, // Normalize JSON path format (brackets, wildcards, quotes) for various dialects
            MinMaxToLeastGreatest, // Multi-arg MIN(a,b,c) -> LEAST(a,b,c), MAX(a,b,c) -> GREATEST(a,b,c)
            ClickHouseUniqToApproxCountDistinct, // uniq(x) -> APPROX_COUNT_DISTINCT(x) for non-ClickHouse targets
            ClickHouseAnyToAnyValue, // any(x) -> ANY_VALUE(x) for non-ClickHouse targets
            OracleVarchar2ToVarchar, // VARCHAR2(N CHAR/BYTE) -> VARCHAR(N) for non-Oracle targets
            Nvl2Expand,              // NVL2(a, b, c) -> CASE WHEN NOT a IS NULL THEN b ELSE c END
            IfnullToCoalesce,        // IFNULL(a, b) -> COALESCE(a, b)
            IsAsciiConvert,          // IS_ASCII(x) -> dialect-specific ASCII check
            StrPositionConvert,      // STR_POSITION(haystack, needle[, pos]) -> dialect-specific
            DecodeSimplify,          // DECODE with null-safe -> simple = comparison
            ArraySumConvert,         // ARRAY_SUM -> target-specific
            ArraySizeConvert,        // ARRAY_SIZE -> target-specific
            ArrayAnyConvert,         // ARRAY_ANY -> target-specific
            CastTimestamptzToFunc,   // CAST(x AS TIMESTAMPTZ) -> TIMESTAMP(x) for MySQL/StarRocks
            TsOrDsToDateConvert,     // TS_OR_DS_TO_DATE(x[, fmt]) -> dialect-specific
            TsOrDsToDateStrConvert,  // TS_OR_DS_TO_DATE_STR(x) -> SUBSTRING(CAST(x AS type), 1, 10)
            DateStrToDateConvert,    // DATE_STR_TO_DATE(x) -> CAST(x AS DATE)
            TimeStrToDateConvert,    // TIME_STR_TO_DATE(x) -> CAST(x AS DATE)
            TimeStrToTimeConvert,    // TIME_STR_TO_TIME(x) -> CAST(x AS TIMESTAMP)
            DateToDateStrConvert,    // DATE_TO_DATE_STR(x) -> CAST(x AS TEXT/VARCHAR/STRING)
            DateToDiConvert, // DATE_TO_DI(x) -> dialect-specific (CAST date to YYYYMMDD integer)
            DiToDateConvert, // DI_TO_DATE(x) -> dialect-specific (integer YYYYMMDD to date)
            TsOrDiToDiConvert, // TS_OR_DI_TO_DI(x) -> dialect-specific
            UnixToStrConvert, // UNIX_TO_STR(x, fmt) -> dialect-specific
            UnixToTimeConvert, // UNIX_TO_TIME(x) -> dialect-specific
            UnixToTimeStrConvert, // UNIX_TO_TIME_STR(x) -> dialect-specific
            TimeToUnixConvert, // TIME_TO_UNIX(x) -> dialect-specific
            TimeToStrConvert, // TIME_TO_STR(x, fmt) -> dialect-specific
            StrToUnixConvert, // STR_TO_UNIX(x, fmt) -> dialect-specific
            DateTruncSwapArgs, // DATE_TRUNC('unit', x) -> DATE_TRUNC(x, unit) / TRUNC(x, unit)
            TimestampTruncConvert, // TIMESTAMP_TRUNC(x, UNIT[, tz]) -> dialect-specific
            StrToDateConvert, // STR_TO_DATE(x, fmt) from Generic -> CAST(StrToTime(x,fmt) AS DATE)
            TsOrDsAddConvert, // TS_OR_DS_ADD(x, n, 'UNIT') from Generic -> DATE_ADD per dialect
            DateFromUnixDateConvert, // DATE_FROM_UNIX_DATE(n) -> DATEADD(DAY, n, '1970-01-01')
            TimeStrToUnixConvert, // TIME_STR_TO_UNIX(x) -> dialect-specific
            TimeToTimeStrConvert, // TIME_TO_TIME_STR(x) -> CAST(x AS type)
            CreateTableLikeToCtas, // CREATE TABLE a LIKE b -> CREATE TABLE a AS SELECT * FROM b LIMIT 0
            CreateTableLikeToSelectInto, // CREATE TABLE a LIKE b -> SELECT TOP 0 * INTO a FROM b AS temp
            CreateTableLikeToAs, // CREATE TABLE a LIKE b -> CREATE TABLE a AS b (ClickHouse)
            ArrayRemoveConvert, // ARRAY_REMOVE(arr, target) -> LIST_FILTER/arrayFilter/ARRAY subquery
            ArrayReverseConvert, // ARRAY_REVERSE(x) -> arrayReverse(x) for ClickHouse
            JsonKeysConvert,    // JSON_KEYS -> JSON_OBJECT_KEYS/OBJECT_KEYS
            ParseJsonStrip,     // PARSE_JSON(x) -> x (strip wrapper)
            ArraySizeDrill,     // ARRAY_SIZE -> REPEATED_COUNT for Drill
            WeekOfYearToWeekIso, // WEEKOFYEAR -> WEEKISO for Snowflake cross-dialect
        }

        // Handle SELECT INTO -> CREATE TABLE AS for DuckDB/Snowflake/etc.
        let expr = if matches!(source, DialectType::TSQL | DialectType::Fabric) {
            Self::transform_select_into(expr, source, target)
        } else {
            expr
        };

        // Strip OFFSET ROWS for non-TSQL/Oracle targets
        let expr = if !matches!(
            target,
            DialectType::TSQL | DialectType::Oracle | DialectType::Fabric
        ) {
            if let Expression::Select(mut select) = expr {
                if let Some(ref mut offset) = select.offset {
                    offset.rows = None;
                }
                Expression::Select(select)
            } else {
                expr
            }
        } else {
            expr
        };

        // Oracle: LIMIT -> FETCH FIRST, OFFSET -> OFFSET ROWS
        let expr = if matches!(target, DialectType::Oracle) {
            if let Expression::Select(mut select) = expr {
                if let Some(limit) = select.limit.take() {
                    // Convert LIMIT to FETCH FIRST n ROWS ONLY
                    select.fetch = Some(crate::expressions::Fetch {
                        direction: "FIRST".to_string(),
                        count: Some(limit.this),
                        percent: false,
                        rows: true,
                        with_ties: false,
                    });
                }
                // Add ROWS to OFFSET if present
                if let Some(ref mut offset) = select.offset {
                    offset.rows = Some(true);
                }
                Expression::Select(select)
            } else {
                expr
            }
        } else {
            expr
        };

        // Handle CreateTable WITH properties transformation before recursive transforms
        let expr = if let Expression::CreateTable(mut ct) = expr {
            Self::transform_create_table_properties(&mut ct, source, target);

            // Handle Hive-style PARTITIONED BY (col_name type, ...) -> target-specific
            // When the PARTITIONED BY clause contains column definitions, merge them into the
            // main column list and adjust the PARTITIONED BY clause for the target dialect.
            if matches!(
                source,
                DialectType::Hive | DialectType::Spark | DialectType::Databricks
            ) {
                let mut partition_col_names: Vec<String> = Vec::new();
                let mut partition_col_defs: Vec<crate::expressions::ColumnDef> = Vec::new();
                let mut has_col_def_partitions = false;

                // Check if any PARTITIONED BY property contains ColumnDef expressions
                for prop in &ct.properties {
                    if let Expression::PartitionedByProperty(ref pbp) = prop {
                        if let Expression::Tuple(ref tuple) = *pbp.this {
                            for expr in &tuple.expressions {
                                if let Expression::ColumnDef(ref cd) = expr {
                                    has_col_def_partitions = true;
                                    partition_col_names.push(cd.name.name.clone());
                                    partition_col_defs.push(*cd.clone());
                                }
                            }
                        }
                    }
                }

                if has_col_def_partitions && !matches!(target, DialectType::Hive) {
                    // Merge partition columns into main column list
                    for cd in partition_col_defs {
                        ct.columns.push(cd);
                    }

                    // Replace PARTITIONED BY property with column-name-only version
                    ct.properties
                        .retain(|p| !matches!(p, Expression::PartitionedByProperty(_)));

                    if matches!(
                        target,
                        DialectType::Presto | DialectType::Trino | DialectType::Athena
                    ) {
                        // Presto: WITH (PARTITIONED_BY=ARRAY['y', 'z'])
                        let array_elements: Vec<String> = partition_col_names
                            .iter()
                            .map(|n| format!("'{}'", n))
                            .collect();
                        let array_value = format!("ARRAY[{}]", array_elements.join(", "));
                        ct.with_properties
                            .push(("PARTITIONED_BY".to_string(), array_value));
                    } else if matches!(target, DialectType::Spark | DialectType::Databricks) {
                        // Spark: PARTITIONED BY (y, z) - just column names
                        let name_exprs: Vec<Expression> = partition_col_names
                            .iter()
                            .map(|n| {
                                Expression::Column(crate::expressions::Column {
                                    name: crate::expressions::Identifier::new(n.clone()),
                                    table: None,
                                    join_mark: false,
                                    trailing_comments: Vec::new(),
                                })
                            })
                            .collect();
                        ct.properties.insert(
                            0,
                            Expression::PartitionedByProperty(Box::new(
                                crate::expressions::PartitionedByProperty {
                                    this: Box::new(Expression::Tuple(Box::new(
                                        crate::expressions::Tuple {
                                            expressions: name_exprs,
                                        },
                                    ))),
                                },
                            )),
                        );
                    }
                    // For DuckDB and other targets, just drop the PARTITIONED BY (already retained above)
                }

                // Note: Non-ColumnDef partitions (e.g., function expressions like MONTHS(y))
                // are handled by transform_create_table_properties which runs first
            }

            // Strip LOCATION property for Presto/Trino (not supported)
            if matches!(
                target,
                DialectType::Presto | DialectType::Trino | DialectType::Athena
            ) {
                ct.properties
                    .retain(|p| !matches!(p, Expression::LocationProperty(_)));
            }

            // Strip table-level constraints for Spark/Hive/Databricks
            // Keep PRIMARY KEY and LIKE constraints but strip TSQL-specific modifiers; remove all others
            if matches!(
                target,
                DialectType::Spark | DialectType::Databricks | DialectType::Hive
            ) {
                ct.constraints.retain(|c| {
                    matches!(
                        c,
                        crate::expressions::TableConstraint::PrimaryKey { .. }
                            | crate::expressions::TableConstraint::Like { .. }
                    )
                });
                for constraint in &mut ct.constraints {
                    if let crate::expressions::TableConstraint::PrimaryKey {
                        columns,
                        modifiers,
                        ..
                    } = constraint
                    {
                        // Strip ASC/DESC from column names
                        for col in columns.iter_mut() {
                            if col.name.ends_with(" ASC") {
                                col.name = col.name[..col.name.len() - 4].to_string();
                            } else if col.name.ends_with(" DESC") {
                                col.name = col.name[..col.name.len() - 5].to_string();
                            }
                        }
                        // Strip TSQL-specific modifiers
                        modifiers.clustered = None;
                        modifiers.with_options.clear();
                        modifiers.on_filegroup = None;
                    }
                }
            }

            // Databricks: IDENTITY columns with INT/INTEGER -> BIGINT
            if matches!(target, DialectType::Databricks) {
                for col in &mut ct.columns {
                    if col.auto_increment {
                        if matches!(col.data_type, crate::expressions::DataType::Int { .. }) {
                            col.data_type = crate::expressions::DataType::BigInt { length: None };
                        }
                    }
                }
            }

            // Spark/Databricks: INTEGER -> INT in column definitions
            // Python sqlglot always outputs INT for Spark/Databricks
            if matches!(target, DialectType::Spark | DialectType::Databricks) {
                for col in &mut ct.columns {
                    if let crate::expressions::DataType::Int {
                        integer_spelling, ..
                    } = &mut col.data_type
                    {
                        *integer_spelling = false;
                    }
                }
            }

            // Strip explicit NULL constraints for Hive/Spark (B INTEGER NULL -> B INTEGER)
            if matches!(target, DialectType::Hive | DialectType::Spark) {
                for col in &mut ct.columns {
                    // If nullable is explicitly true (NULL), change to None (omit it)
                    if col.nullable == Some(true) {
                        col.nullable = None;
                    }
                    // Also remove from constraints if stored there
                    col.constraints
                        .retain(|c| !matches!(c, crate::expressions::ColumnConstraint::Null));
                }
            }

            // Strip TSQL ON filegroup for non-TSQL/Fabric targets
            if ct.on_property.is_some()
                && !matches!(target, DialectType::TSQL | DialectType::Fabric)
            {
                ct.on_property = None;
            }

            // Snowflake: strip ARRAY type parameters (ARRAY<INT> -> ARRAY, ARRAY<ARRAY<INT>> -> ARRAY)
            // Snowflake doesn't support typed arrays in DDL
            if matches!(target, DialectType::Snowflake) {
                fn strip_array_type_params(dt: &mut crate::expressions::DataType) {
                    if let crate::expressions::DataType::Array { .. } = dt {
                        *dt = crate::expressions::DataType::Custom {
                            name: "ARRAY".to_string(),
                        };
                    }
                }
                for col in &mut ct.columns {
                    strip_array_type_params(&mut col.data_type);
                }
            }

            // PostgreSQL target: ensure IDENTITY columns have NOT NULL
            // If NOT NULL was explicit in source (present in constraint_order), preserve original order.
            // If NOT NULL was not explicit, add it after IDENTITY (GENERATED BY DEFAULT AS IDENTITY NOT NULL).
            if matches!(target, DialectType::PostgreSQL) {
                for col in &mut ct.columns {
                    if col.auto_increment && !col.constraint_order.is_empty() {
                        use crate::expressions::ConstraintType;
                        let has_explicit_not_null = col
                            .constraint_order
                            .iter()
                            .any(|ct| *ct == ConstraintType::NotNull);

                        if has_explicit_not_null {
                            // Source had explicit NOT NULL - preserve original order
                            // Just ensure nullable is set
                            if col.nullable != Some(false) {
                                col.nullable = Some(false);
                            }
                        } else {
                            // Source didn't have explicit NOT NULL - build order with
                            // AutoIncrement + NotNull first, then remaining constraints
                            let mut new_order = Vec::new();
                            // Put AutoIncrement (IDENTITY) first, followed by synthetic NotNull
                            new_order.push(ConstraintType::AutoIncrement);
                            new_order.push(ConstraintType::NotNull);
                            // Add remaining constraints in original order (except AutoIncrement)
                            for ct_type in &col.constraint_order {
                                if *ct_type != ConstraintType::AutoIncrement {
                                    new_order.push(ct_type.clone());
                                }
                            }
                            col.constraint_order = new_order;
                            col.nullable = Some(false);
                        }
                    }
                }
            }

            Expression::CreateTable(ct)
        } else {
            expr
        };

        // Handle CreateView column stripping for Presto/Trino target
        let expr = if let Expression::CreateView(mut cv) = expr {
            // Presto/Trino: drop column list when view has a SELECT body
            if matches!(target, DialectType::Presto | DialectType::Trino) && !cv.columns.is_empty()
            {
                if !matches!(&cv.query, Expression::Null(_)) {
                    cv.columns.clear();
                }
            }
            Expression::CreateView(cv)
        } else {
            expr
        };

        // Wrap bare VALUES in CTE bodies with SELECT * FROM (...) AS _values for generic/non-Presto targets
        let expr = if !matches!(
            target,
            DialectType::Presto | DialectType::Trino | DialectType::Athena
        ) {
            if let Expression::Select(mut select) = expr {
                if let Some(ref mut with) = select.with {
                    for cte in &mut with.ctes {
                        if let Expression::Values(ref vals) = cte.this {
                            // Build: SELECT * FROM (VALUES ...) AS _values
                            let values_subquery =
                                Expression::Subquery(Box::new(crate::expressions::Subquery {
                                    this: Expression::Values(vals.clone()),
                                    alias: Some(Identifier::new("_values".to_string())),
                                    column_aliases: Vec::new(),
                                    order_by: None,
                                    limit: None,
                                    offset: None,
                                    distribute_by: None,
                                    sort_by: None,
                                    cluster_by: None,
                                    lateral: false,
                                    modifiers_inside: false,
                                    trailing_comments: Vec::new(),
                                }));
                            let mut new_select = crate::expressions::Select::new();
                            new_select.expressions =
                                vec![Expression::Star(crate::expressions::Star {
                                    table: None,
                                    except: None,
                                    replace: None,
                                    rename: None,
                                    trailing_comments: Vec::new(),
                                })];
                            new_select.from = Some(crate::expressions::From {
                                expressions: vec![values_subquery],
                            });
                            cte.this = Expression::Select(Box::new(new_select));
                        }
                    }
                }
                Expression::Select(select)
            } else {
                expr
            }
        } else {
            expr
        };

        // PostgreSQL CREATE INDEX: add NULLS FIRST to index columns that don't have nulls ordering
        let expr = if matches!(target, DialectType::PostgreSQL) {
            if let Expression::CreateIndex(mut ci) = expr {
                for col in &mut ci.columns {
                    if col.nulls_first.is_none() {
                        col.nulls_first = Some(true);
                    }
                }
                Expression::CreateIndex(ci)
            } else {
                expr
            }
        } else {
            expr
        };

        transform_recursive(expr, &|e| {
            // BigQuery CAST(ARRAY[STRUCT(...)] AS STRUCT_TYPE[]) -> DuckDB: convert unnamed Structs to ROW()
            // This converts auto-named struct literals {'_0': x, '_1': y} inside typed arrays to ROW(x, y)
            if matches!(source, DialectType::BigQuery) && matches!(target, DialectType::DuckDB) {
                if let Expression::Cast(ref c) = e {
                    // Check if this is a CAST of an array to a struct array type
                    let is_struct_array_cast =
                        matches!(&c.to, crate::expressions::DataType::Array { .. });
                    if is_struct_array_cast {
                        let has_auto_named_structs = match &c.this {
                            Expression::Array(arr) => arr.expressions.iter().any(|elem| {
                                if let Expression::Struct(s) = elem {
                                    s.fields.iter().all(|(name, _)| {
                                        name.as_ref().map_or(true, |n| {
                                            n.starts_with('_') && n[1..].parse::<usize>().is_ok()
                                        })
                                    })
                                } else {
                                    false
                                }
                            }),
                            Expression::ArrayFunc(arr) => arr.expressions.iter().any(|elem| {
                                if let Expression::Struct(s) = elem {
                                    s.fields.iter().all(|(name, _)| {
                                        name.as_ref().map_or(true, |n| {
                                            n.starts_with('_') && n[1..].parse::<usize>().is_ok()
                                        })
                                    })
                                } else {
                                    false
                                }
                            }),
                            _ => false,
                        };
                        if has_auto_named_structs {
                            let convert_struct_to_row = |elem: Expression| -> Expression {
                                if let Expression::Struct(s) = elem {
                                    let row_args: Vec<Expression> =
                                        s.fields.into_iter().map(|(_, v)| v).collect();
                                    Expression::Function(Box::new(Function::new(
                                        "ROW".to_string(),
                                        row_args,
                                    )))
                                } else {
                                    elem
                                }
                            };
                            let mut c_clone = c.as_ref().clone();
                            match &mut c_clone.this {
                                Expression::Array(arr) => {
                                    arr.expressions = arr
                                        .expressions
                                        .drain(..)
                                        .map(convert_struct_to_row)
                                        .collect();
                                }
                                Expression::ArrayFunc(arr) => {
                                    arr.expressions = arr
                                        .expressions
                                        .drain(..)
                                        .map(convert_struct_to_row)
                                        .collect();
                                }
                                _ => {}
                            }
                            return Ok(Expression::Cast(Box::new(c_clone)));
                        }
                    }
                }
            }

            // BigQuery SELECT AS STRUCT -> DuckDB struct literal {'key': value, ...}
            if matches!(source, DialectType::BigQuery) && matches!(target, DialectType::DuckDB) {
                if let Expression::Select(ref sel) = e {
                    if sel.kind.as_deref() == Some("STRUCT") {
                        let mut fields = Vec::new();
                        for expr in &sel.expressions {
                            match expr {
                                Expression::Alias(a) => {
                                    fields.push((Some(a.alias.name.clone()), a.this.clone()));
                                }
                                Expression::Column(c) => {
                                    fields.push((Some(c.name.name.clone()), expr.clone()));
                                }
                                _ => {
                                    fields.push((None, expr.clone()));
                                }
                            }
                        }
                        let struct_lit =
                            Expression::Struct(Box::new(crate::expressions::Struct { fields }));
                        let mut new_select = sel.as_ref().clone();
                        new_select.kind = None;
                        new_select.expressions = vec![struct_lit];
                        return Ok(Expression::Select(Box::new(new_select)));
                    }
                }
            }

            // Convert @variable -> ${variable} for Spark/Hive/Databricks
            if matches!(source, DialectType::TSQL | DialectType::Fabric)
                && matches!(
                    target,
                    DialectType::Spark | DialectType::Databricks | DialectType::Hive
                )
            {
                if let Expression::Parameter(ref p) = e {
                    if p.style == crate::expressions::ParameterStyle::At {
                        if let Some(ref name) = p.name {
                            return Ok(Expression::Parameter(Box::new(
                                crate::expressions::Parameter {
                                    name: Some(name.clone()),
                                    index: p.index,
                                    style: crate::expressions::ParameterStyle::DollarBrace,
                                    quoted: p.quoted,
                                    string_quoted: p.string_quoted,
                                    expression: None,
                                },
                            )));
                        }
                    }
                }
                // Also handle Column("@x") -> Parameter("x", DollarBrace) for TSQL vars
                if let Expression::Column(ref col) = e {
                    if col.name.name.starts_with('@') && col.table.is_none() {
                        let var_name = col.name.name.trim_start_matches('@').to_string();
                        return Ok(Expression::Parameter(Box::new(
                            crate::expressions::Parameter {
                                name: Some(var_name),
                                index: None,
                                style: crate::expressions::ParameterStyle::DollarBrace,
                                quoted: false,
                                string_quoted: false,
                                expression: None,
                            },
                        )));
                    }
                }
            }

            // Convert @variable -> variable in SET statements for Spark/Databricks
            if matches!(source, DialectType::TSQL | DialectType::Fabric)
                && matches!(target, DialectType::Spark | DialectType::Databricks)
            {
                if let Expression::SetStatement(ref s) = e {
                    let mut new_items = s.items.clone();
                    let mut changed = false;
                    for item in &mut new_items {
                        // Strip @ from the SET name (Parameter style)
                        if let Expression::Parameter(ref p) = item.name {
                            if p.style == crate::expressions::ParameterStyle::At {
                                if let Some(ref name) = p.name {
                                    item.name = Expression::Identifier(Identifier::new(name));
                                    changed = true;
                                }
                            }
                        }
                        // Strip @ from the SET name (Identifier style - SET parser)
                        if let Expression::Identifier(ref id) = item.name {
                            if id.name.starts_with('@') {
                                let var_name = id.name.trim_start_matches('@').to_string();
                                item.name = Expression::Identifier(Identifier::new(&var_name));
                                changed = true;
                            }
                        }
                        // Strip @ from the SET name (Column style - alternative parsing)
                        if let Expression::Column(ref col) = item.name {
                            if col.name.name.starts_with('@') && col.table.is_none() {
                                let var_name = col.name.name.trim_start_matches('@').to_string();
                                item.name = Expression::Identifier(Identifier::new(&var_name));
                                changed = true;
                            }
                        }
                    }
                    if changed {
                        let mut new_set = (**s).clone();
                        new_set.items = new_items;
                        return Ok(Expression::SetStatement(Box::new(new_set)));
                    }
                }
            }

            // Strip NOLOCK hint for non-TSQL targets
            if matches!(source, DialectType::TSQL | DialectType::Fabric)
                && !matches!(target, DialectType::TSQL | DialectType::Fabric)
            {
                if let Expression::Table(ref tr) = e {
                    if !tr.hints.is_empty() {
                        let mut new_tr = tr.clone();
                        new_tr.hints.clear();
                        return Ok(Expression::Table(new_tr));
                    }
                }
            }

            // Snowflake: TRUE IS TRUE -> TRUE, FALSE IS FALSE -> FALSE
            // Snowflake simplifies IS TRUE/IS FALSE on boolean literals
            if matches!(target, DialectType::Snowflake) {
                if let Expression::IsTrue(ref itf) = e {
                    if let Expression::Boolean(ref b) = itf.this {
                        if !itf.not {
                            return Ok(Expression::Boolean(crate::expressions::BooleanLiteral {
                                value: b.value,
                            }));
                        } else {
                            return Ok(Expression::Boolean(crate::expressions::BooleanLiteral {
                                value: !b.value,
                            }));
                        }
                    }
                }
                if let Expression::IsFalse(ref itf) = e {
                    if let Expression::Boolean(ref b) = itf.this {
                        if !itf.not {
                            return Ok(Expression::Boolean(crate::expressions::BooleanLiteral {
                                value: !b.value,
                            }));
                        } else {
                            return Ok(Expression::Boolean(crate::expressions::BooleanLiteral {
                                value: b.value,
                            }));
                        }
                    }
                }
            }

            // BigQuery: split dotted backtick identifiers in table names
            // e.g., `a.b.c` -> "a"."b"."c" when source is BigQuery and target is not BigQuery
            if matches!(source, DialectType::BigQuery) && !matches!(target, DialectType::BigQuery) {
                if let Expression::CreateTable(ref ct) = e {
                    let mut changed = false;
                    let mut new_ct = ct.clone();
                    // Split the table name
                    if ct.name.schema.is_none() && ct.name.name.name.contains('.') {
                        let parts: Vec<&str> = ct.name.name.name.split('.').collect();
                        // Use quoted identifiers when the original was quoted (backtick in BigQuery)
                        let was_quoted = ct.name.name.quoted;
                        let mk_id = |s: &str| {
                            if was_quoted {
                                Identifier::quoted(s)
                            } else {
                                Identifier::new(s)
                            }
                        };
                        if parts.len() == 3 {
                            new_ct.name.catalog = Some(mk_id(parts[0]));
                            new_ct.name.schema = Some(mk_id(parts[1]));
                            new_ct.name.name = mk_id(parts[2]);
                            changed = true;
                        } else if parts.len() == 2 {
                            new_ct.name.schema = Some(mk_id(parts[0]));
                            new_ct.name.name = mk_id(parts[1]);
                            changed = true;
                        }
                    }
                    // Split the clone source name
                    if let Some(ref clone_src) = ct.clone_source {
                        if clone_src.schema.is_none() && clone_src.name.name.contains('.') {
                            let parts: Vec<&str> = clone_src.name.name.split('.').collect();
                            let was_quoted = clone_src.name.quoted;
                            let mk_id = |s: &str| {
                                if was_quoted {
                                    Identifier::quoted(s)
                                } else {
                                    Identifier::new(s)
                                }
                            };
                            let mut new_src = clone_src.clone();
                            if parts.len() == 3 {
                                new_src.catalog = Some(mk_id(parts[0]));
                                new_src.schema = Some(mk_id(parts[1]));
                                new_src.name = mk_id(parts[2]);
                                new_ct.clone_source = Some(new_src);
                                changed = true;
                            } else if parts.len() == 2 {
                                new_src.schema = Some(mk_id(parts[0]));
                                new_src.name = mk_id(parts[1]);
                                new_ct.clone_source = Some(new_src);
                                changed = true;
                            }
                        }
                    }
                    if changed {
                        return Ok(Expression::CreateTable(new_ct));
                    }
                }
            }

            // BigQuery array subscript: a[1], b[OFFSET(1)], c[ORDINAL(1)], d[SAFE_OFFSET(1)], e[SAFE_ORDINAL(1)]
            // -> DuckDB/Presto: convert 0-based to 1-based, handle SAFE_* -> ELEMENT_AT for Presto
            if matches!(source, DialectType::BigQuery)
                && matches!(
                    target,
                    DialectType::DuckDB
                        | DialectType::Presto
                        | DialectType::Trino
                        | DialectType::Athena
                )
            {
                if let Expression::Subscript(ref sub) = e {
                    let (new_index, is_safe) = match &sub.index {
                        // a[1] -> a[1+1] = a[2] (plain index is 0-based in BQ)
                        Expression::Literal(Literal::Number(n)) => {
                            if let Ok(val) = n.parse::<i64>() {
                                (
                                    Some(Expression::Literal(Literal::Number(
                                        (val + 1).to_string(),
                                    ))),
                                    false,
                                )
                            } else {
                                (None, false)
                            }
                        }
                        // OFFSET(n) -> n+1 (0-based)
                        Expression::Function(ref f)
                            if f.name.eq_ignore_ascii_case("OFFSET") && f.args.len() == 1 =>
                        {
                            if let Expression::Literal(Literal::Number(n)) = &f.args[0] {
                                if let Ok(val) = n.parse::<i64>() {
                                    (
                                        Some(Expression::Literal(Literal::Number(
                                            (val + 1).to_string(),
                                        ))),
                                        false,
                                    )
                                } else {
                                    (
                                        Some(Expression::Add(Box::new(
                                            crate::expressions::BinaryOp::new(
                                                f.args[0].clone(),
                                                Expression::number(1),
                                            ),
                                        ))),
                                        false,
                                    )
                                }
                            } else {
                                (
                                    Some(Expression::Add(Box::new(
                                        crate::expressions::BinaryOp::new(
                                            f.args[0].clone(),
                                            Expression::number(1),
                                        ),
                                    ))),
                                    false,
                                )
                            }
                        }
                        // ORDINAL(n) -> n (already 1-based)
                        Expression::Function(ref f)
                            if f.name.eq_ignore_ascii_case("ORDINAL") && f.args.len() == 1 =>
                        {
                            (Some(f.args[0].clone()), false)
                        }
                        // SAFE_OFFSET(n) -> n+1 (0-based, safe)
                        Expression::Function(ref f)
                            if f.name.eq_ignore_ascii_case("SAFE_OFFSET") && f.args.len() == 1 =>
                        {
                            if let Expression::Literal(Literal::Number(n)) = &f.args[0] {
                                if let Ok(val) = n.parse::<i64>() {
                                    (
                                        Some(Expression::Literal(Literal::Number(
                                            (val + 1).to_string(),
                                        ))),
                                        true,
                                    )
                                } else {
                                    (
                                        Some(Expression::Add(Box::new(
                                            crate::expressions::BinaryOp::new(
                                                f.args[0].clone(),
                                                Expression::number(1),
                                            ),
                                        ))),
                                        true,
                                    )
                                }
                            } else {
                                (
                                    Some(Expression::Add(Box::new(
                                        crate::expressions::BinaryOp::new(
                                            f.args[0].clone(),
                                            Expression::number(1),
                                        ),
                                    ))),
                                    true,
                                )
                            }
                        }
                        // SAFE_ORDINAL(n) -> n (already 1-based, safe)
                        Expression::Function(ref f)
                            if f.name.eq_ignore_ascii_case("SAFE_ORDINAL") && f.args.len() == 1 =>
                        {
                            (Some(f.args[0].clone()), true)
                        }
                        _ => (None, false),
                    };
                    if let Some(idx) = new_index {
                        if is_safe
                            && matches!(
                                target,
                                DialectType::Presto | DialectType::Trino | DialectType::Athena
                            )
                        {
                            // Presto: SAFE_OFFSET/SAFE_ORDINAL -> ELEMENT_AT(arr, idx)
                            return Ok(Expression::Function(Box::new(Function::new(
                                "ELEMENT_AT".to_string(),
                                vec![sub.this.clone(), idx],
                            ))));
                        } else {
                            // DuckDB or non-safe: just use subscript with converted index
                            return Ok(Expression::Subscript(Box::new(
                                crate::expressions::Subscript {
                                    this: sub.this.clone(),
                                    index: idx,
                                },
                            )));
                        }
                    }
                }
            }

            // BigQuery LENGTH(x) -> DuckDB CASE TYPEOF(x) WHEN 'BLOB' THEN OCTET_LENGTH(...) ELSE LENGTH(...) END
            if matches!(source, DialectType::BigQuery) && matches!(target, DialectType::DuckDB) {
                if let Expression::Length(ref uf) = e {
                    let arg = uf.this.clone();
                    let typeof_func = Expression::Function(Box::new(Function::new(
                        "TYPEOF".to_string(),
                        vec![arg.clone()],
                    )));
                    let blob_cast = Expression::Cast(Box::new(Cast {
                        this: arg.clone(),
                        to: DataType::VarBinary { length: None },
                        trailing_comments: vec![],
                        double_colon_syntax: false,
                        format: None,
                        default: None,
                    }));
                    let octet_length = Expression::Function(Box::new(Function::new(
                        "OCTET_LENGTH".to_string(),
                        vec![blob_cast],
                    )));
                    let text_cast = Expression::Cast(Box::new(Cast {
                        this: arg,
                        to: DataType::Text,
                        trailing_comments: vec![],
                        double_colon_syntax: false,
                        format: None,
                        default: None,
                    }));
                    let length_text = Expression::Length(Box::new(crate::expressions::UnaryFunc {
                        this: text_cast,
                        original_name: None,
                    }));
                    return Ok(Expression::Case(Box::new(Case {
                        operand: Some(typeof_func),
                        whens: vec![(
                            Expression::Literal(Literal::String("BLOB".to_string())),
                            octet_length,
                        )],
                        else_: Some(length_text),
                        comments: Vec::new(),
                    })));
                }
            }

            // BigQuery UNNEST alias handling (only for non-BigQuery sources):
            // UNNEST(...) AS x -> UNNEST(...) (drop unused table alias)
            // UNNEST(...) AS x(y) -> UNNEST(...) AS y (use column alias as main alias)
            if matches!(target, DialectType::BigQuery) && !matches!(source, DialectType::BigQuery) {
                if let Expression::Alias(ref a) = e {
                    if matches!(&a.this, Expression::Unnest(_)) {
                        if a.column_aliases.is_empty() {
                            // Drop the entire alias, return just the UNNEST expression
                            return Ok(a.this.clone());
                        } else {
                            // Use first column alias as the main alias
                            let mut new_alias = a.as_ref().clone();
                            new_alias.alias = a.column_aliases[0].clone();
                            new_alias.column_aliases.clear();
                            return Ok(Expression::Alias(Box::new(new_alias)));
                        }
                    }
                }
            }

            // BigQuery IN UNNEST(expr) -> IN (SELECT UNNEST/EXPLODE(expr)) for non-BigQuery targets
            if matches!(source, DialectType::BigQuery) && !matches!(target, DialectType::BigQuery) {
                if let Expression::In(ref in_expr) = e {
                    if let Some(ref unnest_inner) = in_expr.unnest {
                        // Build the function call for the target dialect
                        let func_expr = if matches!(
                            target,
                            DialectType::Hive | DialectType::Spark | DialectType::Databricks
                        ) {
                            // Use EXPLODE for Hive/Spark
                            Expression::Function(Box::new(Function::new(
                                "EXPLODE".to_string(),
                                vec![*unnest_inner.clone()],
                            )))
                        } else {
                            // Use UNNEST for Presto/Trino/DuckDB/etc.
                            Expression::Unnest(Box::new(crate::expressions::UnnestFunc {
                                this: *unnest_inner.clone(),
                                expressions: Vec::new(),
                                with_ordinality: false,
                                alias: None,
                                offset_alias: None,
                            }))
                        };

                        // Wrap in SELECT
                        let mut inner_select = crate::expressions::Select::new();
                        inner_select.expressions = vec![func_expr];

                        let subquery_expr = Expression::Select(Box::new(inner_select));

                        return Ok(Expression::In(Box::new(crate::expressions::In {
                            this: in_expr.this.clone(),
                            expressions: Vec::new(),
                            query: Some(subquery_expr),
                            not: in_expr.not,
                            global: in_expr.global,
                            unnest: None,
                            is_field: false,
                        })));
                    }
                }
            }

            // SQLite: GENERATE_SERIES AS t(i) -> (SELECT value AS i FROM GENERATE_SERIES(...)) AS t
            // This handles the subquery wrapping for RANGE -> GENERATE_SERIES in FROM context
            if matches!(target, DialectType::SQLite) && matches!(source, DialectType::DuckDB) {
                if let Expression::Alias(ref a) = e {
                    if let Expression::Function(ref f) = a.this {
                        if f.name.eq_ignore_ascii_case("GENERATE_SERIES")
                            && !a.column_aliases.is_empty()
                        {
                            // Build: (SELECT value AS col_alias FROM GENERATE_SERIES(start, end)) AS table_alias
                            let col_alias = a.column_aliases[0].clone();
                            let mut inner_select = crate::expressions::Select::new();
                            inner_select.expressions =
                                vec![Expression::Alias(Box::new(crate::expressions::Alias::new(
                                    Expression::Identifier(Identifier::new("value".to_string())),
                                    col_alias,
                                )))];
                            inner_select.from = Some(crate::expressions::From {
                                expressions: vec![a.this.clone()],
                            });
                            let subquery =
                                Expression::Subquery(Box::new(crate::expressions::Subquery {
                                    this: Expression::Select(Box::new(inner_select)),
                                    alias: Some(a.alias.clone()),
                                    column_aliases: Vec::new(),
                                    order_by: None,
                                    limit: None,
                                    offset: None,
                                    lateral: false,
                                    modifiers_inside: false,
                                    trailing_comments: Vec::new(),
                                    distribute_by: None,
                                    sort_by: None,
                                    cluster_by: None,
                                }));
                            return Ok(subquery);
                        }
                    }
                }
            }

            // BigQuery implicit UNNEST: comma-join on array path -> CROSS JOIN UNNEST
            // e.g., SELECT results FROM Coordinates, Coordinates.position AS results
            //     -> SELECT results FROM Coordinates CROSS JOIN UNNEST(Coordinates.position) AS results
            if matches!(source, DialectType::BigQuery) {
                if let Expression::Select(ref s) = e {
                    if let Some(ref from) = s.from {
                        if from.expressions.len() >= 2 {
                            // Collect table names from first expression
                            let first_tables: Vec<String> = from
                                .expressions
                                .iter()
                                .take(1)
                                .filter_map(|expr| {
                                    if let Expression::Table(t) = expr {
                                        Some(t.name.name.to_lowercase())
                                    } else {
                                        None
                                    }
                                })
                                .collect();

                            // Check if any subsequent FROM expressions are schema-qualified with a matching table name
                            // or have a dotted name matching a table
                            let mut needs_rewrite = false;
                            for expr in from.expressions.iter().skip(1) {
                                if let Expression::Table(t) = expr {
                                    if let Some(ref schema) = t.schema {
                                        if first_tables.contains(&schema.name.to_lowercase()) {
                                            needs_rewrite = true;
                                            break;
                                        }
                                    }
                                    // Also check dotted names in quoted identifiers (e.g., `Coordinates.position`)
                                    if t.schema.is_none() && t.name.name.contains('.') {
                                        let parts: Vec<&str> = t.name.name.split('.').collect();
                                        if parts.len() >= 2
                                            && first_tables.contains(&parts[0].to_lowercase())
                                        {
                                            needs_rewrite = true;
                                            break;
                                        }
                                    }
                                }
                            }

                            if needs_rewrite {
                                let mut new_select = s.clone();
                                let mut new_from_exprs = vec![from.expressions[0].clone()];
                                let mut new_joins = s.joins.clone();

                                for expr in from.expressions.iter().skip(1) {
                                    if let Expression::Table(ref t) = expr {
                                        if let Some(ref schema) = t.schema {
                                            if first_tables.contains(&schema.name.to_lowercase()) {
                                                // This is an array path reference, convert to CROSS JOIN UNNEST
                                                let col_expr = Expression::Column(
                                                    crate::expressions::Column {
                                                        name: t.name.clone(),
                                                        table: Some(schema.clone()),
                                                        join_mark: false,
                                                        trailing_comments: vec![],
                                                    },
                                                );
                                                let unnest_expr = Expression::Unnest(Box::new(
                                                    crate::expressions::UnnestFunc {
                                                        this: col_expr,
                                                        expressions: Vec::new(),
                                                        with_ordinality: false,
                                                        alias: None,
                                                        offset_alias: None,
                                                    },
                                                ));
                                                let join_this = if let Some(ref alias) = t.alias {
                                                    if matches!(
                                                        target,
                                                        DialectType::Presto
                                                            | DialectType::Trino
                                                            | DialectType::Athena
                                                    ) {
                                                        // Presto: UNNEST(x) AS _t0(results)
                                                        Expression::Alias(Box::new(
                                                            crate::expressions::Alias {
                                                                this: unnest_expr,
                                                                alias: Identifier::new("_t0"),
                                                                column_aliases: vec![alias.clone()],
                                                                pre_alias_comments: vec![],
                                                                trailing_comments: vec![],
                                                            },
                                                        ))
                                                    } else {
                                                        // BigQuery: UNNEST(x) AS results
                                                        Expression::Alias(Box::new(
                                                            crate::expressions::Alias {
                                                                this: unnest_expr,
                                                                alias: alias.clone(),
                                                                column_aliases: vec![],
                                                                pre_alias_comments: vec![],
                                                                trailing_comments: vec![],
                                                            },
                                                        ))
                                                    }
                                                } else {
                                                    unnest_expr
                                                };
                                                new_joins.push(crate::expressions::Join {
                                                    kind: crate::expressions::JoinKind::Cross,
                                                    this: join_this,
                                                    on: None,
                                                    using: Vec::new(),
                                                    use_inner_keyword: false,
                                                    use_outer_keyword: false,
                                                    deferred_condition: false,
                                                    join_hint: None,
                                                    match_condition: None,
                                                    pivots: Vec::new(),
                                                    comments: Vec::new(),
                                                    nesting_group: 0,
                                                    directed: false,
                                                });
                                            } else {
                                                new_from_exprs.push(expr.clone());
                                            }
                                        } else if t.schema.is_none() && t.name.name.contains('.') {
                                            // Dotted name in quoted identifier: `Coordinates.position`
                                            let parts: Vec<&str> = t.name.name.split('.').collect();
                                            if parts.len() >= 2
                                                && first_tables.contains(&parts[0].to_lowercase())
                                            {
                                                let join_this =
                                                    if matches!(target, DialectType::BigQuery) {
                                                        // BigQuery: keep as single quoted identifier, just convert comma -> CROSS JOIN
                                                        Expression::Table(t.clone())
                                                    } else {
                                                        // Other targets: split into "schema"."name"
                                                        let mut new_t = t.clone();
                                                        new_t.schema =
                                                            Some(Identifier::quoted(parts[0]));
                                                        new_t.name = Identifier::quoted(parts[1]);
                                                        Expression::Table(new_t)
                                                    };
                                                new_joins.push(crate::expressions::Join {
                                                    kind: crate::expressions::JoinKind::Cross,
                                                    this: join_this,
                                                    on: None,
                                                    using: Vec::new(),
                                                    use_inner_keyword: false,
                                                    use_outer_keyword: false,
                                                    deferred_condition: false,
                                                    join_hint: None,
                                                    match_condition: None,
                                                    pivots: Vec::new(),
                                                    comments: Vec::new(),
                                                    nesting_group: 0,
                                                    directed: false,
                                                });
                                            } else {
                                                new_from_exprs.push(expr.clone());
                                            }
                                        } else {
                                            new_from_exprs.push(expr.clone());
                                        }
                                    } else {
                                        new_from_exprs.push(expr.clone());
                                    }
                                }

                                new_select.from = Some(crate::expressions::From {
                                    expressions: new_from_exprs,
                                    ..from.clone()
                                });
                                new_select.joins = new_joins;
                                return Ok(Expression::Select(new_select));
                            }
                        }
                    }
                }
            }

            // CROSS JOIN UNNEST -> LATERAL VIEW EXPLODE for Hive/Spark
            if matches!(
                target,
                DialectType::Hive | DialectType::Spark | DialectType::Databricks
            ) {
                if let Expression::Select(ref s) = e {
                    // Check if any joins are CROSS JOIN with UNNEST/EXPLODE
                    let is_unnest_or_explode_expr = |expr: &Expression| -> bool {
                        matches!(expr, Expression::Unnest(_))
                            || matches!(expr, Expression::Function(f) if f.name.eq_ignore_ascii_case("EXPLODE"))
                    };
                    let has_unnest_join = s.joins.iter().any(|j| {
                        j.kind == crate::expressions::JoinKind::Cross && (
                            matches!(&j.this, Expression::Alias(a) if is_unnest_or_explode_expr(&a.this))
                            || is_unnest_or_explode_expr(&j.this)
                        )
                    });
                    if has_unnest_join {
                        let mut select = s.clone();
                        let mut new_joins = Vec::new();
                        for join in select.joins.drain(..) {
                            if join.kind == crate::expressions::JoinKind::Cross {
                                // Extract the UNNEST/EXPLODE from the join
                                let (func_expr, table_alias, col_aliases) = match &join.this {
                                    Expression::Alias(a) => {
                                        let ta = if a.alias.is_empty() {
                                            None
                                        } else {
                                            Some(a.alias.clone())
                                        };
                                        let cas = a.column_aliases.clone();
                                        match &a.this {
                                            Expression::Unnest(u) => {
                                                // Multi-arg UNNEST(y, z) -> INLINE(ARRAYS_ZIP(y, z))
                                                if !u.expressions.is_empty() {
                                                    let mut all_args = vec![u.this.clone()];
                                                    all_args.extend(u.expressions.clone());
                                                    let arrays_zip =
                                                        Expression::Function(Box::new(
                                                            crate::expressions::Function::new(
                                                                "ARRAYS_ZIP".to_string(),
                                                                all_args,
                                                            ),
                                                        ));
                                                    let inline = Expression::Function(Box::new(
                                                        crate::expressions::Function::new(
                                                            "INLINE".to_string(),
                                                            vec![arrays_zip],
                                                        ),
                                                    ));
                                                    (Some(inline), ta, a.column_aliases.clone())
                                                } else {
                                                    // Convert UNNEST(x) to EXPLODE(x) or POSEXPLODE(x)
                                                    let func_name = if u.with_ordinality {
                                                        "POSEXPLODE"
                                                    } else {
                                                        "EXPLODE"
                                                    };
                                                    let explode = Expression::Function(Box::new(
                                                        crate::expressions::Function::new(
                                                            func_name.to_string(),
                                                            vec![u.this.clone()],
                                                        ),
                                                    ));
                                                    // For POSEXPLODE, add 'pos' to column aliases
                                                    let cas = if u.with_ordinality {
                                                        let mut pos_aliases =
                                                            vec![Identifier::new(
                                                                "pos".to_string(),
                                                            )];
                                                        pos_aliases
                                                            .extend(a.column_aliases.clone());
                                                        pos_aliases
                                                    } else {
                                                        a.column_aliases.clone()
                                                    };
                                                    (Some(explode), ta, cas)
                                                }
                                            }
                                            Expression::Function(f)
                                                if f.name.eq_ignore_ascii_case("EXPLODE") =>
                                            {
                                                (Some(Expression::Function(f.clone())), ta, cas)
                                            }
                                            _ => (None, None, Vec::new()),
                                        }
                                    }
                                    Expression::Unnest(u) => {
                                        let func_name = if u.with_ordinality {
                                            "POSEXPLODE"
                                        } else {
                                            "EXPLODE"
                                        };
                                        let explode = Expression::Function(Box::new(
                                            crate::expressions::Function::new(
                                                func_name.to_string(),
                                                vec![u.this.clone()],
                                            ),
                                        ));
                                        let ta = u.alias.clone();
                                        let col_aliases = if u.with_ordinality {
                                            vec![Identifier::new("pos".to_string())]
                                        } else {
                                            Vec::new()
                                        };
                                        (Some(explode), ta, col_aliases)
                                    }
                                    _ => (None, None, Vec::new()),
                                };
                                if let Some(func) = func_expr {
                                    select.lateral_views.push(crate::expressions::LateralView {
                                        this: func,
                                        table_alias,
                                        column_aliases: col_aliases,
                                        outer: false,
                                    });
                                } else {
                                    new_joins.push(join);
                                }
                            } else {
                                new_joins.push(join);
                            }
                        }
                        select.joins = new_joins;
                        return Ok(Expression::Select(select));
                    }
                }
            }

            // UNNEST expansion: DuckDB SELECT UNNEST(arr) in SELECT list -> expanded query
            // for BigQuery, Presto/Trino, Snowflake
            if matches!(source, DialectType::DuckDB | DialectType::PostgreSQL)
                && matches!(
                    target,
                    DialectType::BigQuery
                        | DialectType::Presto
                        | DialectType::Trino
                        | DialectType::Snowflake
                )
            {
                if let Expression::Select(ref s) = e {
                    // Check if any SELECT expressions contain UNNEST
                    // Note: UNNEST can appear as Expression::Unnest OR Expression::Function("UNNEST")
                    let has_unnest_in_select = s.expressions.iter().any(|expr| {
                        fn contains_unnest(e: &Expression) -> bool {
                            match e {
                                Expression::Unnest(_) => true,
                                Expression::Function(f)
                                    if f.name.eq_ignore_ascii_case("UNNEST") =>
                                {
                                    true
                                }
                                Expression::Alias(a) => contains_unnest(&a.this),
                                Expression::Add(op)
                                | Expression::Sub(op)
                                | Expression::Mul(op)
                                | Expression::Div(op) => {
                                    contains_unnest(&op.left) || contains_unnest(&op.right)
                                }
                                _ => false,
                            }
                        }
                        contains_unnest(expr)
                    });

                    if has_unnest_in_select {
                        let rewritten = Self::rewrite_unnest_expansion(s, target);
                        if let Some(new_select) = rewritten {
                            return Ok(Expression::Select(Box::new(new_select)));
                        }
                    }
                }
            }

            // BigQuery -> PostgreSQL: convert escape sequences in string literals to actual characters
            // BigQuery '\n' -> PostgreSQL literal newline in string
            if matches!(source, DialectType::BigQuery) && matches!(target, DialectType::PostgreSQL)
            {
                if let Expression::Literal(Literal::String(ref s)) = e {
                    if s.contains("\\n")
                        || s.contains("\\t")
                        || s.contains("\\r")
                        || s.contains("\\\\")
                    {
                        let converted = s
                            .replace("\\n", "\n")
                            .replace("\\t", "\t")
                            .replace("\\r", "\r")
                            .replace("\\\\", "\\");
                        return Ok(Expression::Literal(Literal::String(converted)));
                    }
                }
            }

            // Cross-dialect: convert Literal::Timestamp to target-specific CAST form
            // when source != target (identity tests keep the Literal::Timestamp for native handling)
            if source != target {
                if let Expression::Literal(Literal::Timestamp(ref s)) = e {
                    let s = s.clone();
                    // MySQL: TIMESTAMP handling depends on source dialect
                    // BigQuery TIMESTAMP is timezone-aware -> TIMESTAMP() function in MySQL
                    // Other sources' TIMESTAMP is non-timezone -> CAST('x' AS DATETIME) in MySQL
                    if matches!(target, DialectType::MySQL) {
                        if matches!(source, DialectType::BigQuery) {
                            // BigQuery TIMESTAMP is timezone-aware -> MySQL TIMESTAMP() function
                            return Ok(Expression::Function(Box::new(Function::new(
                                "TIMESTAMP".to_string(),
                                vec![Expression::Literal(Literal::String(s))],
                            ))));
                        } else {
                            // Non-timezone TIMESTAMP -> CAST('x' AS DATETIME) in MySQL
                            return Ok(Expression::Cast(Box::new(Cast {
                                this: Expression::Literal(Literal::String(s)),
                                to: DataType::Custom {
                                    name: "DATETIME".to_string(),
                                },
                                trailing_comments: Vec::new(),
                                double_colon_syntax: false,
                                format: None,
                                default: None,
                            })));
                        }
                    }
                    let dt = match target {
                        DialectType::BigQuery | DialectType::StarRocks => DataType::Custom {
                            name: "DATETIME".to_string(),
                        },
                        DialectType::Snowflake => {
                            // BigQuery TIMESTAMP is timezone-aware -> use TIMESTAMPTZ for Snowflake
                            if matches!(source, DialectType::BigQuery) {
                                DataType::Custom {
                                    name: "TIMESTAMPTZ".to_string(),
                                }
                            } else if matches!(
                                source,
                                DialectType::PostgreSQL
                                    | DialectType::Redshift
                                    | DialectType::Snowflake
                            ) {
                                DataType::Timestamp {
                                    precision: None,
                                    timezone: false,
                                }
                            } else {
                                DataType::Custom {
                                    name: "TIMESTAMPNTZ".to_string(),
                                }
                            }
                        }
                        DialectType::Spark | DialectType::Databricks => {
                            // BigQuery TIMESTAMP is timezone-aware -> use plain TIMESTAMP for Spark/Databricks
                            if matches!(source, DialectType::BigQuery) {
                                DataType::Timestamp {
                                    precision: None,
                                    timezone: false,
                                }
                            } else {
                                DataType::Custom {
                                    name: "TIMESTAMP_NTZ".to_string(),
                                }
                            }
                        }
                        DialectType::ClickHouse => DataType::Nullable {
                            inner: Box::new(DataType::Custom {
                                name: "DateTime".to_string(),
                            }),
                        },
                        DialectType::TSQL | DialectType::Fabric => DataType::Custom {
                            name: "DATETIME2".to_string(),
                        },
                        DialectType::DuckDB => {
                            // DuckDB: use TIMESTAMPTZ when source is BigQuery (BQ TIMESTAMP is always UTC/tz-aware)
                            // or when the timestamp string explicitly has timezone info
                            if matches!(source, DialectType::BigQuery)
                                || Self::timestamp_string_has_timezone(&s)
                            {
                                DataType::Custom {
                                    name: "TIMESTAMPTZ".to_string(),
                                }
                            } else {
                                DataType::Timestamp {
                                    precision: None,
                                    timezone: false,
                                }
                            }
                        }
                        _ => DataType::Timestamp {
                            precision: None,
                            timezone: false,
                        },
                    };
                    return Ok(Expression::Cast(Box::new(Cast {
                        this: Expression::Literal(Literal::String(s)),
                        to: dt,
                        trailing_comments: vec![],
                        double_colon_syntax: false,
                        format: None,
                        default: None,
                    })));
                }
            }

            // PostgreSQL DELETE requires explicit AS for table aliases
            if matches!(target, DialectType::PostgreSQL | DialectType::Redshift) {
                if let Expression::Delete(ref del) = e {
                    if del.alias.is_some() && !del.alias_explicit_as {
                        let mut new_del = del.clone();
                        new_del.alias_explicit_as = true;
                        return Ok(Expression::Delete(new_del));
                    }
                }
            }

            // UNION/INTERSECT/EXCEPT DISTINCT handling:
            // Some dialects require explicit DISTINCT (BigQuery, ClickHouse),
            // while others don't support it (Presto, Spark, DuckDB, etc.)
            {
                let needs_distinct =
                    matches!(target, DialectType::BigQuery | DialectType::ClickHouse);
                let drop_distinct = matches!(
                    target,
                    DialectType::Presto
                        | DialectType::Trino
                        | DialectType::Athena
                        | DialectType::Spark
                        | DialectType::Databricks
                        | DialectType::DuckDB
                        | DialectType::Hive
                        | DialectType::MySQL
                        | DialectType::PostgreSQL
                        | DialectType::SQLite
                        | DialectType::TSQL
                        | DialectType::Redshift
                        | DialectType::Snowflake
                        | DialectType::Oracle
                        | DialectType::Teradata
                        | DialectType::Drill
                        | DialectType::Doris
                        | DialectType::StarRocks
                );
                match &e {
                    Expression::Union(u) if !u.all && needs_distinct && !u.distinct => {
                        let mut new_u = (**u).clone();
                        new_u.distinct = true;
                        return Ok(Expression::Union(Box::new(new_u)));
                    }
                    Expression::Intersect(i) if !i.all && needs_distinct && !i.distinct => {
                        let mut new_i = (**i).clone();
                        new_i.distinct = true;
                        return Ok(Expression::Intersect(Box::new(new_i)));
                    }
                    Expression::Except(ex) if !ex.all && needs_distinct && !ex.distinct => {
                        let mut new_ex = (**ex).clone();
                        new_ex.distinct = true;
                        return Ok(Expression::Except(Box::new(new_ex)));
                    }
                    Expression::Union(u) if u.distinct && drop_distinct => {
                        let mut new_u = (**u).clone();
                        new_u.distinct = false;
                        return Ok(Expression::Union(Box::new(new_u)));
                    }
                    Expression::Intersect(i) if i.distinct && drop_distinct => {
                        let mut new_i = (**i).clone();
                        new_i.distinct = false;
                        return Ok(Expression::Intersect(Box::new(new_i)));
                    }
                    Expression::Except(ex) if ex.distinct && drop_distinct => {
                        let mut new_ex = (**ex).clone();
                        new_ex.distinct = false;
                        return Ok(Expression::Except(Box::new(new_ex)));
                    }
                    _ => {}
                }
            }

            // ClickHouse: MAP('a', '1') -> map('a', '1') (lowercase function name)
            if matches!(target, DialectType::ClickHouse) {
                if let Expression::Function(ref f) = e {
                    if f.name.eq_ignore_ascii_case("MAP") && !f.args.is_empty() {
                        let mut new_f = f.as_ref().clone();
                        new_f.name = "map".to_string();
                        return Ok(Expression::Function(Box::new(new_f)));
                    }
                }
            }

            // ClickHouse: INTERSECT ALL -> INTERSECT (ClickHouse doesn't support ALL on INTERSECT)
            if matches!(target, DialectType::ClickHouse) {
                if let Expression::Intersect(ref i) = e {
                    if i.all {
                        let mut new_i = (**i).clone();
                        new_i.all = false;
                        return Ok(Expression::Intersect(Box::new(new_i)));
                    }
                }
            }

            // Integer division: a / b -> CAST(a AS DOUBLE) / b for dialects that need it
            // Only from Generic source, to prevent double-wrapping
            if matches!(source, DialectType::Generic) {
                if let Expression::Div(ref op) = e {
                    let cast_type = match target {
                        DialectType::TSQL | DialectType::Fabric => Some(DataType::Float {
                            precision: None,
                            scale: None,
                            real_spelling: false,
                        }),
                        DialectType::Drill
                        | DialectType::Trino
                        | DialectType::Athena
                        | DialectType::Presto => Some(DataType::Double {
                            precision: None,
                            scale: None,
                        }),
                        DialectType::PostgreSQL
                        | DialectType::Redshift
                        | DialectType::Materialize
                        | DialectType::Teradata
                        | DialectType::RisingWave => Some(DataType::Double {
                            precision: None,
                            scale: None,
                        }),
                        _ => None,
                    };
                    if let Some(dt) = cast_type {
                        let cast_left = Expression::Cast(Box::new(Cast {
                            this: op.left.clone(),
                            to: dt,
                            double_colon_syntax: false,
                            trailing_comments: Vec::new(),
                            format: None,
                            default: None,
                        }));
                        let new_op = crate::expressions::BinaryOp {
                            left: cast_left,
                            right: op.right.clone(),
                            left_comments: op.left_comments.clone(),
                            operator_comments: op.operator_comments.clone(),
                            trailing_comments: op.trailing_comments.clone(),
                        };
                        return Ok(Expression::Div(Box::new(new_op)));
                    }
                }
            }

            // CREATE DATABASE -> CREATE SCHEMA for DuckDB target
            if matches!(target, DialectType::DuckDB) {
                if let Expression::CreateDatabase(db) = e {
                    let mut schema = crate::expressions::CreateSchema::new(db.name.name.clone());
                    schema.if_not_exists = db.if_not_exists;
                    return Ok(Expression::CreateSchema(Box::new(schema)));
                }
                if let Expression::DropDatabase(db) = e {
                    let mut schema = crate::expressions::DropSchema::new(db.name.name.clone());
                    schema.if_exists = db.if_exists;
                    return Ok(Expression::DropSchema(Box::new(schema)));
                }
            }

            // Strip ClickHouse Nullable(...) wrapper for non-ClickHouse targets
            if matches!(source, DialectType::ClickHouse)
                && !matches!(target, DialectType::ClickHouse)
            {
                if let Expression::Cast(ref c) = e {
                    if let DataType::Custom { ref name } = c.to {
                        let upper = name.to_uppercase();
                        if upper.starts_with("NULLABLE(") && upper.ends_with(")") {
                            let inner = &name[9..name.len() - 1]; // strip "Nullable(" and ")"
                            let inner_upper = inner.to_uppercase();
                            let new_dt = match inner_upper.as_str() {
                                "DATETIME" | "DATETIME64" => DataType::Timestamp {
                                    precision: None,
                                    timezone: false,
                                },
                                "DATE" => DataType::Date,
                                "INT64" | "BIGINT" => DataType::BigInt { length: None },
                                "INT32" | "INT" | "INTEGER" => DataType::Int {
                                    length: None,
                                    integer_spelling: false,
                                },
                                "FLOAT64" | "DOUBLE" => DataType::Double {
                                    precision: None,
                                    scale: None,
                                },
                                "STRING" => DataType::Text,
                                _ => DataType::Custom {
                                    name: inner.to_string(),
                                },
                            };
                            let mut new_cast = c.clone();
                            new_cast.to = new_dt;
                            return Ok(Expression::Cast(new_cast));
                        }
                    }
                }
            }

            // ARRAY_CONCAT_AGG -> Snowflake: ARRAY_FLATTEN(ARRAY_AGG(...))
            if matches!(target, DialectType::Snowflake) {
                if let Expression::ArrayConcatAgg(ref agg) = e {
                    let mut agg_clone = agg.as_ref().clone();
                    agg_clone.name = None; // Clear name so generator uses default "ARRAY_AGG"
                    let array_agg = Expression::ArrayAgg(Box::new(agg_clone));
                    let flatten = Expression::Function(Box::new(Function::new(
                        "ARRAY_FLATTEN".to_string(),
                        vec![array_agg],
                    )));
                    return Ok(flatten);
                }
            }

            // ARRAY_CONCAT_AGG -> others: keep as function for cross-dialect
            if !matches!(target, DialectType::BigQuery | DialectType::Snowflake) {
                if let Expression::ArrayConcatAgg(agg) = e {
                    let arg = agg.this;
                    return Ok(Expression::Function(Box::new(Function::new(
                        "ARRAY_CONCAT_AGG".to_string(),
                        vec![arg],
                    ))));
                }
            }

            // Determine what action to take by inspecting e immutably
            let action = {
                let source_propagates_nulls =
                    matches!(source, DialectType::Snowflake | DialectType::BigQuery);
                let target_ignores_nulls =
                    matches!(target, DialectType::DuckDB | DialectType::PostgreSQL);

                match &e {
                    Expression::Function(f) => {
                        let name = f.name.to_uppercase();
                        // DATE_PART: strip quotes from first arg when target is Snowflake (source != Snowflake)
                        if (name == "DATE_PART" || name == "DATEPART")
                            && f.args.len() == 2
                            && matches!(target, DialectType::Snowflake)
                            && !matches!(source, DialectType::Snowflake)
                            && matches!(
                                &f.args[0],
                                Expression::Literal(crate::expressions::Literal::String(_))
                            )
                        {
                            Action::DatePartUnquote
                        } else if source_propagates_nulls
                            && target_ignores_nulls
                            && (name == "GREATEST" || name == "LEAST")
                            && f.args.len() >= 2
                        {
                            Action::GreatestLeastNull
                        } else if matches!(source, DialectType::Snowflake)
                            && name == "ARRAY_GENERATE_RANGE"
                            && f.args.len() >= 2
                        {
                            Action::ArrayGenerateRange
                        } else if matches!(source, DialectType::Snowflake)
                            && matches!(target, DialectType::DuckDB)
                            && name == "DATE_TRUNC"
                            && f.args.len() == 2
                        {
                            // Determine if DuckDB DATE_TRUNC needs CAST wrapping to preserve input type.
                            // Logic based on Python sqlglot's input_type_preserved flag:
                            // - DATE + non-date-unit (HOUR, MINUTE, etc.) -> wrap
                            // - TIMESTAMP + date-unit (YEAR, QUARTER, MONTH, WEEK, DAY) -> wrap
                            // - TIMESTAMPTZ/TIMESTAMPLTZ/TIME -> always wrap
                            let unit_str = match &f.args[0] {
                                Expression::Literal(crate::expressions::Literal::String(s)) => {
                                    Some(s.to_uppercase())
                                }
                                _ => None,
                            };
                            let is_date_unit = unit_str.as_ref().map_or(false, |u| {
                                matches!(u.as_str(), "YEAR" | "QUARTER" | "MONTH" | "WEEK" | "DAY")
                            });
                            match &f.args[1] {
                                Expression::Cast(c) => match &c.to {
                                    DataType::Time { .. } => Action::DateTruncWrapCast,
                                    DataType::Custom { name }
                                        if name.eq_ignore_ascii_case("TIMESTAMPTZ")
                                            || name.eq_ignore_ascii_case("TIMESTAMPLTZ") =>
                                    {
                                        Action::DateTruncWrapCast
                                    }
                                    DataType::Timestamp { timezone: true, .. } => {
                                        Action::DateTruncWrapCast
                                    }
                                    DataType::Date if !is_date_unit => Action::DateTruncWrapCast,
                                    DataType::Timestamp {
                                        timezone: false, ..
                                    } if is_date_unit => Action::DateTruncWrapCast,
                                    _ => Action::None,
                                },
                                _ => Action::None,
                            }
                        } else if matches!(source, DialectType::Snowflake)
                            && matches!(target, DialectType::DuckDB)
                            && name == "TO_DATE"
                            && f.args.len() == 1
                            && !matches!(
                                &f.args[0],
                                Expression::Literal(crate::expressions::Literal::String(_))
                            )
                        {
                            Action::ToDateToCast
                        } else if !matches!(source, DialectType::Redshift)
                            && matches!(target, DialectType::Redshift)
                            && name == "CONVERT_TIMEZONE"
                            && (f.args.len() == 2 || f.args.len() == 3)
                        {
                            // Convert Function("CONVERT_TIMEZONE") to Expression::ConvertTimezone
                            // so Redshift's transform_expr won't expand 2-arg to 3-arg with 'UTC'.
                            // The Redshift parser adds 'UTC' as default source_tz, but when
                            // transpiling from other dialects, we should preserve the original form.
                            Action::ConvertTimezoneToExpr
                        } else if matches!(source, DialectType::Snowflake)
                            && matches!(target, DialectType::DuckDB)
                            && name == "REGEXP_REPLACE"
                            && f.args.len() == 4
                            && !matches!(
                                &f.args[3],
                                Expression::Literal(crate::expressions::Literal::String(_))
                            )
                        {
                            // Snowflake REGEXP_REPLACE with position arg -> DuckDB needs 'g' flag
                            Action::RegexpReplaceSnowflakeToDuckDB
                        } else if name == "_BQ_TO_HEX" {
                            // Internal marker from TO_HEX conversion - bare (no LOWER/UPPER wrapper)
                            Action::BigQueryToHexBare
                        } else if matches!(source, DialectType::BigQuery)
                            && !matches!(target, DialectType::BigQuery)
                        {
                            // BigQuery-specific functions that need to be converted to standard forms
                            match name.as_str() {
                                "TIMESTAMP_DIFF" | "DATETIME_DIFF" | "TIME_DIFF"
                                | "DATE_DIFF"
                                | "TIMESTAMP_ADD" | "TIMESTAMP_SUB"
                                | "DATETIME_ADD" | "DATETIME_SUB"
                                | "TIME_ADD" | "TIME_SUB"
                                | "DATE_ADD" | "DATE_SUB"
                                | "SAFE_DIVIDE"
                                | "GENERATE_UUID"
                                | "COUNTIF"
                                | "EDIT_DISTANCE"
                                | "TIMESTAMP_SECONDS" | "TIMESTAMP_MILLIS" | "TIMESTAMP_MICROS"
                                | "TIMESTAMP_TRUNC" | "DATETIME_TRUNC" | "DATE_TRUNC"
                                | "TO_HEX"
                                | "TO_JSON_STRING"
                                | "GENERATE_ARRAY" | "GENERATE_TIMESTAMP_ARRAY"
                                | "DIV"
                                | "UNIX_DATE" | "UNIX_SECONDS" | "UNIX_MILLIS" | "UNIX_MICROS"
                                | "LAST_DAY"
                                | "TIME" | "DATETIME" | "TIMESTAMP" | "STRING"
                                | "REGEXP_CONTAINS"
                                | "CONTAINS_SUBSTR"
                                | "SAFE_ADD" | "SAFE_SUBTRACT" | "SAFE_MULTIPLY"
                                | "SAFE_CAST"
                                | "GENERATE_DATE_ARRAY"
                                | "PARSE_DATE" | "PARSE_TIMESTAMP"
                                | "FORMAT_DATE" | "FORMAT_DATETIME" | "FORMAT_TIMESTAMP"
                                | "ARRAY_CONCAT"
                                | "JSON_QUERY" | "JSON_VALUE_ARRAY"
                                | "INSTR"
                                | "MD5" | "SHA1" | "SHA256" | "SHA512"
                                | "GENERATE_UUID()" // just in case
                                | "REGEXP_EXTRACT_ALL"
                                | "REGEXP_EXTRACT"
                                | "INT64"
                                | "ARRAY_CONCAT_AGG"
                                | "DATE_DIFF(" // just in case
                                | "TO_HEX_MD5" // internal
                                | "MOD"
                                | "CONCAT"
                                | "CURRENT_TIMESTAMP" | "CURRENT_DATE" | "CURRENT_DATETIME" | "CURRENT_TIME"
                                | "STRUCT"
                                | "ROUND"
                                | "MAKE_INTERVAL"
                                | "ARRAY_TO_STRING"
                                | "PERCENTILE_CONT"
                                    => Action::BigQueryFunctionNormalize,
                                "ARRAY" if matches!(target, DialectType::Snowflake)
                                    && f.args.len() == 1
                                    && matches!(&f.args[0], Expression::Select(s) if s.kind.as_deref() == Some("STRUCT"))
                                    => Action::BigQueryArraySelectAsStructToSnowflake,
                                _ => Action::None,
                            }
                        } else if matches!(source, DialectType::BigQuery)
                            && matches!(target, DialectType::BigQuery)
                        {
                            // BigQuery -> BigQuery normalizations
                            match name.as_str() {
                                "TIMESTAMP_DIFF"
                                | "DATETIME_DIFF"
                                | "TIME_DIFF"
                                | "DATE_DIFF"
                                | "DATE_ADD"
                                | "TO_HEX"
                                | "CURRENT_TIMESTAMP"
                                | "CURRENT_DATE"
                                | "CURRENT_TIME"
                                | "CURRENT_DATETIME"
                                | "GENERATE_DATE_ARRAY"
                                | "INSTR"
                                | "FORMAT_DATETIME"
                                | "DATETIME"
                                | "MAKE_INTERVAL" => Action::BigQueryFunctionNormalize,
                                _ => Action::None,
                            }
                        } else {
                            // Generic function normalization for non-BigQuery sources
                            match name.as_str() {
                                "ARBITRARY" | "AGGREGATE"
                                | "REGEXP_MATCHES" | "REGEXP_FULL_MATCH"
                                | "STRUCT_EXTRACT"
                                | "LIST_FILTER" | "LIST_TRANSFORM" | "LIST_SORT" | "LIST_REVERSE_SORT"
                                | "STRING_TO_ARRAY" | "STR_SPLIT" | "STR_SPLIT_REGEX" | "SPLIT_TO_ARRAY"
                                | "SUBSTRINGINDEX"
                                | "ARRAY_LENGTH" | "SIZE" | "CARDINALITY"
                                | "UNICODE"
                                | "XOR"
                                | "ARRAY_REVERSE_SORT"
                                | "ENCODE" | "DECODE"
                                | "QUANTILE"
                                | "EPOCH" | "EPOCH_MS"
                                | "HASHBYTES"
                                | "JSON_EXTRACT_PATH" | "JSON_EXTRACT_PATH_TEXT"
                                | "APPROX_DISTINCT"
                                | "DATE_PARSE" | "FORMAT_DATETIME"
                                | "REGEXP_EXTRACT" | "REGEXP_SUBSTR" | "TO_DAYS"
                                | "RLIKE"
                                | "DATEDIFF" | "DATE_DIFF" | "MONTHS_BETWEEN"
                                | "ADD_MONTHS" | "DATEADD" | "DATE_ADD" | "DATE_SUB" | "DATETRUNC"
                                | "LAST_DAY" | "LAST_DAY_OF_MONTH" | "EOMONTH"
                                | "ARRAY_CONSTRUCT" | "ARRAY_CAT" | "ARRAY_COMPACT"
                                | "ARRAY_FILTER" | "FILTER" | "REDUCE" | "ARRAY_REVERSE"
                                | "MAP" | "MAP_FROM_ENTRIES"
                                | "COLLECT_LIST" | "COLLECT_SET"
                                | "ISNAN" | "IS_NAN"
                                | "TO_UTC_TIMESTAMP" | "FROM_UTC_TIMESTAMP"
                                | "FORMAT_NUMBER"
                                | "TOMONDAY" | "TOSTARTOFWEEK" | "TOSTARTOFMONTH" | "TOSTARTOFYEAR"
                                | "ELEMENT_AT"
                                | "EXPLODE" | "EXPLODE_OUTER" | "POSEXPLODE"
                                | "SPLIT_PART"
                                // GENERATE_SERIES: handled separately below
                                | "JSON_EXTRACT" | "JSON_EXTRACT_SCALAR"
                                | "JSON_QUERY" | "JSON_VALUE"
                                | "JSON_EXTRACT_JSON" | "BSON_EXTRACT_BSON"
                                | "TO_UNIX_TIMESTAMP" | "UNIX_TIMESTAMP"
                                | "CURDATE" | "CURTIME"
                                | "ARRAY_TO_STRING"
                                | "ARRAY_SORT" | "SORT_ARRAY"
                                | "LEFT" | "RIGHT"
                                | "MAP_FROM_ARRAYS"
                                | "LIKE" | "ILIKE"
                                | "ARRAY_CONCAT" | "LIST_CONCAT"
                                | "QUANTILE_CONT" | "QUANTILE_DISC"
                                | "PERCENTILE_CONT" | "PERCENTILE_DISC"
                                | "PERCENTILE_APPROX" | "APPROX_PERCENTILE"
                                | "LOCATE" | "STRPOS" | "INSTR"
                                | "CHAR"
                                // CONCAT: handled separately for COALESCE wrapping
                                | "ARRAY_JOIN"
                                | "ARRAY_CONTAINS" | "HAS" | "CONTAINS"
                                | "ISNULL"
                                | "MONTHNAME"
                                | "TO_TIMESTAMP"
                                | "TO_DATE"
                                | "TO_JSON"
                                | "REGEXP_SPLIT"
                                | "SPLIT"
                                | "FORMATDATETIME"
                                | "ARRAYJOIN"
                                | "SPLITBYSTRING" | "SPLITBYREGEXP"
                                | "NVL"
                                | "TO_CHAR"
                                | "DBMS_RANDOM.VALUE"
                                | "REGEXP_LIKE"
                                | "REPLICATE"
                                | "LEN"
                                | "COUNT_BIG"
                                | "DATEFROMPARTS"
                                | "DATETIMEFROMPARTS"
                                | "CONVERT" | "TRY_CONVERT"
                                | "STRFTIME" | "STRPTIME"
                                | "DATE_FORMAT" | "FORMAT_DATE"
                                | "PARSE_TIMESTAMP" | "PARSE_DATE"
                                | "FROM_BASE64" | "TO_BASE64"
                                | "GETDATE"
                                | "TO_HEX" | "FROM_HEX" | "UNHEX" | "HEX"
                                | "TO_UTF8" | "FROM_UTF8"
                                | "STARTS_WITH" | "STARTSWITH"
                                | "APPROX_COUNT_DISTINCT"
                                | "JSON_FORMAT"
                                | "SYSDATE"
                                | "LOGICAL_OR" | "LOGICAL_AND"
                                | "MONTHS_ADD"
                                | "SCHEMA_NAME"
                                | "STRTOL"
                                | "EDITDIST3"
                                | "FORMAT"
                                | "LIST_CONTAINS" | "LIST_HAS"
                                | "VARIANCE" | "STDDEV"
                                | "ISINF"
                                | "TO_UNIXTIME"
                                | "FROM_UNIXTIME"
                                | "DATEPART" | "DATE_PART"
                                | "DATENAME"
                                | "STRING_AGG"
                                | "JSON_ARRAYAGG"
                                | "APPROX_QUANTILE"
                                | "MAKE_DATE"
                                | "LIST_HAS_ANY" | "ARRAY_HAS_ANY"
                                | "RANGE"
                                | "TRY_ELEMENT_AT"
                                | "STR_TO_MAP"
                                | "STRING"
                                | "STR_TO_TIME"
                                | "CURRENT_SCHEMA"
                                | "LTRIM" | "RTRIM"
                                | "UUID"
                                | "FARM_FINGERPRINT"
                                | "JSON_KEYS"
                                | "WEEKOFYEAR"
                                | "CONCAT_WS"
                                | "ARRAY_SLICE"
                                | "ARRAY_PREPEND"
                                | "ARRAY_REMOVE"
                                | "GENERATE_DATE_ARRAY"
                                | "PARSE_JSON"
                                | "JSON_REMOVE"
                                | "JSON_SET"
                                | "LEVENSHTEIN"
                                    => Action::GenericFunctionNormalize,
                                // Canonical date functions -> dialect-specific
                                "TS_OR_DS_TO_DATE" => Action::TsOrDsToDateConvert,
                                "TS_OR_DS_TO_DATE_STR" if f.args.len() == 1 => Action::TsOrDsToDateStrConvert,
                                "DATE_STR_TO_DATE" if f.args.len() == 1 => Action::DateStrToDateConvert,
                                "TIME_STR_TO_DATE" if f.args.len() == 1 => Action::TimeStrToDateConvert,
                                "TIME_STR_TO_TIME" if f.args.len() <= 2 => Action::TimeStrToTimeConvert,
                                "TIME_STR_TO_UNIX" if f.args.len() == 1 => Action::TimeStrToUnixConvert,
                                "TIME_TO_TIME_STR" if f.args.len() == 1 => Action::TimeToTimeStrConvert,
                                "DATE_TO_DATE_STR" if f.args.len() == 1 => Action::DateToDateStrConvert,
                                "DATE_TO_DI" if f.args.len() == 1 => Action::DateToDiConvert,
                                "DI_TO_DATE" if f.args.len() == 1 => Action::DiToDateConvert,
                                "TS_OR_DI_TO_DI" if f.args.len() == 1 => Action::TsOrDiToDiConvert,
                                "UNIX_TO_STR" if f.args.len() == 2 => Action::UnixToStrConvert,
                                "UNIX_TO_TIME" if f.args.len() == 1 => Action::UnixToTimeConvert,
                                "UNIX_TO_TIME_STR" if f.args.len() == 1 => Action::UnixToTimeStrConvert,
                                "TIME_TO_UNIX" if f.args.len() == 1 => Action::TimeToUnixConvert,
                                "TIME_TO_STR" if f.args.len() == 2 => Action::TimeToStrConvert,
                                "STR_TO_UNIX" if f.args.len() == 2 => Action::StrToUnixConvert,
                                // STR_TO_DATE(x, fmt) -> dialect-specific
                                "STR_TO_DATE" if f.args.len() == 2
                                    && matches!(source, DialectType::Generic) => Action::StrToDateConvert,
                                "STR_TO_DATE" => Action::GenericFunctionNormalize,
                                // TS_OR_DS_ADD(x, n, 'UNIT') from Generic -> dialect-specific DATE_ADD
                                "TS_OR_DS_ADD" if f.args.len() == 3
                                    && matches!(source, DialectType::Generic) => Action::TsOrDsAddConvert,
                                // DATE_FROM_UNIX_DATE(n) -> DATEADD(DAY, n, '1970-01-01')
                                "DATE_FROM_UNIX_DATE" if f.args.len() == 1 => Action::DateFromUnixDateConvert,
                                // NVL2(a, b, c) -> CASE WHEN NOT a IS NULL THEN b [ELSE c] END
                                "NVL2" if (f.args.len() == 2 || f.args.len() == 3) => Action::Nvl2Expand,
                                // IFNULL(a, b) -> COALESCE(a, b) when coming from Generic source
                                "IFNULL" if f.args.len() == 2 => Action::IfnullToCoalesce,
                                // IS_ASCII(x) -> dialect-specific
                                "IS_ASCII" if f.args.len() == 1 => Action::IsAsciiConvert,
                                // STR_POSITION(haystack, needle[, pos[, occ]]) -> dialect-specific
                                "STR_POSITION" => Action::StrPositionConvert,
                                // ARRAY_SUM -> dialect-specific
                                "ARRAY_SUM" => Action::ArraySumConvert,
                                // ARRAY_SIZE -> dialect-specific (Drill only)
                                "ARRAY_SIZE" if matches!(target, DialectType::Drill) => Action::ArraySizeConvert,
                                // ARRAY_ANY -> dialect-specific
                                "ARRAY_ANY" if f.args.len() == 2 => Action::ArrayAnyConvert,
                                // Functions needing specific cross-dialect transforms
                                "MAX_BY" | "MIN_BY" if matches!(target, DialectType::ClickHouse | DialectType::Spark | DialectType::Databricks | DialectType::DuckDB) => Action::MaxByMinByConvert,
                                "STRUCT" if matches!(source, DialectType::Spark | DialectType::Databricks)
                                    && !matches!(target, DialectType::Spark | DialectType::Databricks | DialectType::Hive) => Action::SparkStructConvert,
                                "ARRAY" if matches!(source, DialectType::BigQuery)
                                    && matches!(target, DialectType::Snowflake)
                                    && f.args.len() == 1
                                    && matches!(&f.args[0], Expression::Select(s) if s.kind.as_deref() == Some("STRUCT")) => Action::BigQueryArraySelectAsStructToSnowflake,
                                "ARRAY" if matches!(target, DialectType::Presto | DialectType::Trino | DialectType::Athena | DialectType::BigQuery | DialectType::DuckDB | DialectType::ClickHouse | DialectType::StarRocks) => Action::ArraySyntaxConvert,
                                "TRUNC" if f.args.len() == 2 && matches!(target, DialectType::Presto | DialectType::Trino | DialectType::ClickHouse) => Action::TruncToDateTrunc,
                                // DATE_TRUNC('unit', x) from Generic source -> arg swap for BigQuery/Doris/Spark/MySQL
                                "DATE_TRUNC" if f.args.len() == 2
                                    && matches!(source, DialectType::Generic)
                                    && matches!(target, DialectType::BigQuery | DialectType::Doris | DialectType::StarRocks
                                        | DialectType::Spark | DialectType::Databricks | DialectType::MySQL) => Action::DateTruncSwapArgs,
                                // TIMESTAMP_TRUNC(x, UNIT) from Generic source -> convert to per-dialect
                                "TIMESTAMP_TRUNC" if f.args.len() >= 2
                                    && matches!(source, DialectType::Generic) => Action::TimestampTruncConvert,
                                "UNIFORM" if matches!(target, DialectType::Snowflake) => Action::GenericFunctionNormalize,
                                // GENERATE_SERIES -> SEQUENCE/UNNEST/EXPLODE for target dialects
                                "GENERATE_SERIES" if matches!(source, DialectType::PostgreSQL | DialectType::Redshift)
                                    && !matches!(target, DialectType::PostgreSQL | DialectType::Redshift | DialectType::TSQL | DialectType::Fabric) => Action::GenerateSeriesConvert,
                                // GENERATE_SERIES with interval normalization for PG target
                                "GENERATE_SERIES" if f.args.len() >= 3
                                    && matches!(source, DialectType::PostgreSQL | DialectType::Redshift)
                                    && matches!(target, DialectType::PostgreSQL | DialectType::Redshift) => Action::GenerateSeriesConvert,
                                "GENERATE_SERIES" => Action::None, // passthrough for other cases
                                // CONCAT(a, b) -> COALESCE wrapping for Presto/ClickHouse from PostgreSQL
                                "CONCAT" if matches!(source, DialectType::PostgreSQL | DialectType::Redshift)
                                    && matches!(target, DialectType::Presto | DialectType::Trino | DialectType::ClickHouse) => Action::ConcatCoalesceWrap,
                                "CONCAT" => Action::GenericFunctionNormalize,
                                // DIV(a, b) -> target-specific integer division
                                "DIV" if f.args.len() == 2
                                    && matches!(source, DialectType::PostgreSQL)
                                    && matches!(target, DialectType::DuckDB | DialectType::BigQuery | DialectType::SQLite) => Action::DivFuncConvert,
                                // JSON_OBJECT_AGG/JSONB_OBJECT_AGG -> JSON_GROUP_OBJECT for DuckDB
                                "JSON_OBJECT_AGG" | "JSONB_OBJECT_AGG" if f.args.len() == 2
                                    && matches!(target, DialectType::DuckDB) => Action::JsonObjectAggConvert,
                                // JSONB_EXISTS -> JSON_EXISTS for DuckDB
                                "JSONB_EXISTS" if f.args.len() == 2
                                    && matches!(target, DialectType::DuckDB) => Action::JsonbExistsConvert,
                                // DATE_BIN -> TIME_BUCKET for DuckDB
                                "DATE_BIN" if matches!(target, DialectType::DuckDB) => Action::DateBinConvert,
                                // Multi-arg MIN(a,b,c) -> LEAST, MAX(a,b,c) -> GREATEST
                                "MIN" | "MAX" if f.args.len() > 1 && !matches!(target, DialectType::SQLite) => Action::MinMaxToLeastGreatest,
                                // ClickHouse uniq -> APPROX_COUNT_DISTINCT for other dialects
                                "UNIQ" if matches!(source, DialectType::ClickHouse) && !matches!(target, DialectType::ClickHouse) => Action::ClickHouseUniqToApproxCountDistinct,
                                // ClickHouse any -> ANY_VALUE for other dialects
                                "ANY" if f.args.len() == 1 && matches!(source, DialectType::ClickHouse) && !matches!(target, DialectType::ClickHouse) => Action::ClickHouseAnyToAnyValue,
                                _ => Action::None,
                            }
                        }
                    }
                    Expression::AggregateFunction(af) => {
                        let name = af.name.to_uppercase();
                        match name.as_str() {
                            "ARBITRARY" | "AGGREGATE" => Action::GenericFunctionNormalize,
                            "JSON_ARRAYAGG" => Action::GenericFunctionNormalize,
                            // JSON_OBJECT_AGG/JSONB_OBJECT_AGG -> JSON_GROUP_OBJECT for DuckDB
                            "JSON_OBJECT_AGG" | "JSONB_OBJECT_AGG"
                                if matches!(target, DialectType::DuckDB) =>
                            {
                                Action::JsonObjectAggConvert
                            }
                            "ARRAY_AGG"
                                if matches!(
                                    target,
                                    DialectType::Hive
                                        | DialectType::Spark
                                        | DialectType::Databricks
                                ) =>
                            {
                                Action::ArrayAggToCollectList
                            }
                            "MAX_BY" | "MIN_BY"
                                if matches!(
                                    target,
                                    DialectType::ClickHouse
                                        | DialectType::Spark
                                        | DialectType::Databricks
                                        | DialectType::DuckDB
                                ) =>
                            {
                                Action::MaxByMinByConvert
                            }
                            "COLLECT_LIST"
                                if matches!(
                                    target,
                                    DialectType::Presto | DialectType::Trino | DialectType::DuckDB
                                ) =>
                            {
                                Action::CollectListToArrayAgg
                            }
                            "COLLECT_SET"
                                if matches!(
                                    target,
                                    DialectType::Presto
                                        | DialectType::Trino
                                        | DialectType::Snowflake
                                        | DialectType::DuckDB
                                ) =>
                            {
                                Action::CollectSetConvert
                            }
                            "PERCENTILE"
                                if matches!(
                                    target,
                                    DialectType::DuckDB | DialectType::Presto | DialectType::Trino
                                ) =>
                            {
                                Action::PercentileConvert
                            }
                            // CORR -> CASE WHEN ISNAN(CORR(a,b)) THEN NULL ELSE CORR(a,b) END for DuckDB
                            "CORR"
                                if matches!(target, DialectType::DuckDB)
                                    && matches!(source, DialectType::Snowflake) =>
                            {
                                Action::CorrIsnanWrap
                            }
                            // BigQuery APPROX_QUANTILES(x, n) -> APPROX_QUANTILE(x, [quantiles]) for DuckDB
                            "APPROX_QUANTILES"
                                if matches!(source, DialectType::BigQuery)
                                    && matches!(target, DialectType::DuckDB) =>
                            {
                                Action::BigQueryApproxQuantiles
                            }
                            // BigQuery PERCENTILE_CONT(x, frac RESPECT NULLS) -> QUANTILE_CONT(x, frac) for DuckDB
                            "PERCENTILE_CONT"
                                if matches!(source, DialectType::BigQuery)
                                    && matches!(target, DialectType::DuckDB)
                                    && af.args.len() >= 2 =>
                            {
                                Action::BigQueryPercentileContToDuckDB
                            }
                            _ => Action::None,
                        }
                    }
                    Expression::JSONArrayAgg(_) => match target {
                        DialectType::PostgreSQL => Action::GenericFunctionNormalize,
                        _ => Action::None,
                    },
                    Expression::ToNumber(tn) => {
                        // TO_NUMBER(x) with 1 arg -> CAST(x AS DOUBLE) for most targets
                        if tn.format.is_none() && tn.precision.is_none() && tn.scale.is_none() {
                            match target {
                                DialectType::Oracle
                                | DialectType::Snowflake
                                | DialectType::Teradata => Action::None,
                                _ => Action::GenericFunctionNormalize,
                            }
                        } else {
                            Action::None
                        }
                    }
                    Expression::Nvl2(_) => {
                        // NVL2(a, b, c) -> CASE WHEN NOT a IS NULL THEN b ELSE c END for most dialects
                        // Keep as NVL2 for dialects that support it natively
                        match target {
                            DialectType::Oracle
                            | DialectType::Snowflake
                            | DialectType::Teradata
                            | DialectType::Spark
                            | DialectType::Databricks
                            | DialectType::Redshift => Action::None,
                            _ => Action::Nvl2Expand,
                        }
                    }
                    Expression::Decode(_) | Expression::DecodeCase(_) => {
                        // DECODE(a, b, c[, d, e[, ...]]) -> CASE WHEN with null-safe comparisons
                        // Keep as DECODE for Oracle/Snowflake
                        match target {
                            DialectType::Oracle | DialectType::Snowflake => Action::None,
                            _ => Action::DecodeSimplify,
                        }
                    }
                    Expression::Coalesce(ref cf) => {
                        // IFNULL(a, b) -> COALESCE(a, b): clear original_name for cross-dialect
                        // BigQuery keeps IFNULL natively when source is also BigQuery
                        if cf.original_name.as_deref() == Some("IFNULL")
                            && !(matches!(source, DialectType::BigQuery)
                                && matches!(target, DialectType::BigQuery))
                        {
                            Action::IfnullToCoalesce
                        } else {
                            Action::None
                        }
                    }
                    Expression::IfFunc(if_func) => {
                        if matches!(source, DialectType::Snowflake)
                            && matches!(
                                target,
                                DialectType::Presto | DialectType::Trino | DialectType::SQLite
                            )
                            && matches!(if_func.false_value, Some(Expression::Div(_)))
                        {
                            Action::Div0TypedDivision
                        } else {
                            Action::None
                        }
                    }
                    Expression::ToJson(_) => match target {
                        DialectType::Presto | DialectType::Trino => Action::ToJsonConvert,
                        DialectType::BigQuery => Action::ToJsonConvert,
                        DialectType::DuckDB => Action::ToJsonConvert,
                        _ => Action::None,
                    },
                    Expression::ArrayAgg(ref agg) => {
                        if matches!(
                            target,
                            DialectType::Hive | DialectType::Spark | DialectType::Databricks
                        ) {
                            // Any source -> Hive/Spark: convert ARRAY_AGG to COLLECT_LIST
                            Action::ArrayAggToCollectList
                        } else if matches!(
                            source,
                            DialectType::Spark | DialectType::Databricks | DialectType::Hive
                        ) && matches!(target, DialectType::DuckDB)
                            && agg.filter.is_some()
                        {
                            // Spark/Hive ARRAY_AGG excludes NULLs, DuckDB includes them
                            // Need to add NOT x IS NULL to existing filter
                            Action::ArrayAggNullFilter
                        } else if matches!(target, DialectType::DuckDB)
                            && agg.ignore_nulls == Some(true)
                            && !agg.order_by.is_empty()
                        {
                            // BigQuery ARRAY_AGG(x IGNORE NULLS ORDER BY ...) -> DuckDB ARRAY_AGG(x ORDER BY a NULLS FIRST, ...)
                            Action::ArrayAggIgnoreNullsDuckDB
                        } else if !matches!(source, DialectType::Snowflake) {
                            Action::None
                        } else if matches!(target, DialectType::Spark | DialectType::Databricks) {
                            let is_array_agg = agg.name.as_deref().map(|n| n.to_uppercase())
                                == Some("ARRAY_AGG".to_string())
                                || agg.name.is_none();
                            if is_array_agg {
                                Action::ArrayAggCollectList
                            } else {
                                Action::None
                            }
                        } else if matches!(
                            target,
                            DialectType::DuckDB | DialectType::Presto | DialectType::Trino
                        ) && agg.filter.is_none()
                        {
                            Action::ArrayAggFilter
                        } else {
                            Action::None
                        }
                    }
                    Expression::WithinGroup(wg) => {
                        if matches!(source, DialectType::Snowflake)
                            && matches!(
                                target,
                                DialectType::DuckDB | DialectType::Presto | DialectType::Trino
                            )
                            && matches!(wg.this, Expression::ArrayAgg(_))
                        {
                            Action::ArrayAggWithinGroupFilter
                        } else if matches!(&wg.this, Expression::AggregateFunction(af) if af.name.eq_ignore_ascii_case("STRING_AGG"))
                            || matches!(&wg.this, Expression::Function(f) if f.name.eq_ignore_ascii_case("STRING_AGG"))
                            || matches!(&wg.this, Expression::StringAgg(_))
                        {
                            Action::StringAggConvert
                        } else if matches!(
                            target,
                            DialectType::Presto
                                | DialectType::Trino
                                | DialectType::Athena
                                | DialectType::Spark
                                | DialectType::Databricks
                        ) && (matches!(&wg.this, Expression::Function(f) if f.name.eq_ignore_ascii_case("PERCENTILE_CONT") || f.name.eq_ignore_ascii_case("PERCENTILE_DISC"))
                            || matches!(&wg.this, Expression::AggregateFunction(af) if af.name.eq_ignore_ascii_case("PERCENTILE_CONT") || af.name.eq_ignore_ascii_case("PERCENTILE_DISC"))
                            || matches!(&wg.this, Expression::PercentileCont(_)))
                        {
                            Action::PercentileContConvert
                        } else {
                            Action::None
                        }
                    }
                    // For BigQuery: CAST(x AS TIMESTAMP) -> CAST(x AS DATETIME)
                    // because BigQuery's TIMESTAMP is really TIMESTAMPTZ, and
                    // DATETIME is the timezone-unaware type
                    Expression::Cast(ref c) => {
                        if c.format.is_some()
                            && (matches!(source, DialectType::BigQuery)
                                || matches!(source, DialectType::Teradata))
                        {
                            Action::BigQueryCastFormat
                        } else if matches!(target, DialectType::BigQuery)
                            && !matches!(source, DialectType::BigQuery)
                            && matches!(
                                c.to,
                                DataType::Timestamp {
                                    timezone: false,
                                    ..
                                }
                            )
                        {
                            Action::CastTimestampToDatetime
                        } else if matches!(target, DialectType::MySQL | DialectType::StarRocks)
                            && !matches!(source, DialectType::MySQL | DialectType::StarRocks)
                            && matches!(
                                c.to,
                                DataType::Timestamp {
                                    timezone: false,
                                    ..
                                }
                            )
                        {
                            // Generic/other -> MySQL/StarRocks: CAST(x AS TIMESTAMP) -> CAST(x AS DATETIME)
                            // but MySQL-native CAST(x AS TIMESTAMP) stays as TIMESTAMP(x) via transform_cast
                            Action::CastTimestampToDatetime
                        } else if matches!(
                            source,
                            DialectType::Hive | DialectType::Spark | DialectType::Databricks
                        ) && matches!(
                            target,
                            DialectType::Presto
                                | DialectType::Trino
                                | DialectType::Athena
                                | DialectType::DuckDB
                                | DialectType::Snowflake
                                | DialectType::BigQuery
                                | DialectType::Databricks
                                | DialectType::TSQL
                        ) {
                            Action::HiveCastToTryCast
                        } else if matches!(c.to, DataType::Timestamp { timezone: true, .. })
                            && matches!(target, DialectType::MySQL | DialectType::StarRocks)
                        {
                            // CAST(x AS TIMESTAMPTZ) -> TIMESTAMP(x) function for MySQL/StarRocks
                            Action::CastTimestamptzToFunc
                        } else if matches!(c.to, DataType::Timestamp { timezone: true, .. })
                            && matches!(
                                target,
                                DialectType::Hive
                                    | DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::BigQuery
                            )
                        {
                            // CAST(x AS TIMESTAMP WITH TIME ZONE) -> CAST(x AS TIMESTAMP) for Hive/Spark/BigQuery
                            Action::CastTimestampStripTz
                        } else if matches!(&c.to, DataType::Json)
                            && matches!(&c.this, Expression::Literal(Literal::String(_)))
                            && matches!(
                                target,
                                DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena
                                    | DialectType::Snowflake
                            )
                        {
                            // CAST('x' AS JSON) -> JSON_PARSE('x') for Presto, PARSE_JSON for Snowflake
                            // Only when the input is a string literal (JSON 'value' syntax)
                            Action::JsonLiteralToJsonParse
                        } else if matches!(&c.to, DataType::Json | DataType::JsonB)
                            && matches!(target, DialectType::Spark | DialectType::Databricks)
                        {
                            // CAST(x AS JSON) -> TO_JSON(x) for Spark
                            Action::CastToJsonForSpark
                        } else if (matches!(
                            &c.to,
                            DataType::Array { .. } | DataType::Map { .. } | DataType::Struct { .. }
                        )) && matches!(
                            target,
                            DialectType::Spark | DialectType::Databricks
                        ) && (matches!(&c.this, Expression::ParseJson(_))
                            || matches!(
                                &c.this,
                                Expression::Function(f)
                                    if f.name.eq_ignore_ascii_case("JSON_EXTRACT")
                                        || f.name.eq_ignore_ascii_case("JSON_EXTRACT_SCALAR")
                                        || f.name.eq_ignore_ascii_case("GET_JSON_OBJECT")
                            ))
                        {
                            // CAST(JSON_PARSE(...) AS ARRAY/MAP) or CAST(JSON_EXTRACT/GET_JSON_OBJECT(...) AS ARRAY/MAP)
                            // -> FROM_JSON(..., type_string) for Spark
                            Action::CastJsonToFromJson
                        } else if matches!(target, DialectType::Spark | DialectType::Databricks)
                            && matches!(
                                c.to,
                                DataType::Timestamp {
                                    timezone: false,
                                    ..
                                }
                            )
                            && matches!(source, DialectType::DuckDB)
                        {
                            Action::StrftimeCastTimestamp
                        } else if matches!(source, DialectType::DuckDB)
                            && matches!(
                                c.to,
                                DataType::Decimal {
                                    precision: None,
                                    ..
                                }
                            )
                        {
                            Action::DecimalDefaultPrecision
                        } else if matches!(source, DialectType::MySQL | DialectType::SingleStore)
                            && matches!(c.to, DataType::Char { length: None })
                            && !matches!(target, DialectType::MySQL | DialectType::SingleStore)
                        {
                            // MySQL CAST(x AS CHAR) was originally TEXT - convert to target text type
                            Action::MysqlCastCharToText
                        } else if matches!(
                            source,
                            DialectType::Spark | DialectType::Databricks | DialectType::Hive
                        ) && matches!(
                            target,
                            DialectType::Spark | DialectType::Databricks | DialectType::Hive
                        ) && Self::has_varchar_char_type(&c.to)
                        {
                            // Spark parses VARCHAR(n)/CHAR(n) as TEXT, so normalize back to STRING
                            Action::SparkCastVarcharToString
                        } else {
                            Action::None
                        }
                    }
                    Expression::SafeCast(ref c) => {
                        if c.format.is_some()
                            && matches!(source, DialectType::BigQuery)
                            && !matches!(target, DialectType::BigQuery)
                        {
                            Action::BigQueryCastFormat
                        } else {
                            Action::None
                        }
                    }
                    // For DuckDB: DATE_TRUNC should preserve the input type
                    Expression::DateTrunc(_) | Expression::TimestampTrunc(_) => {
                        if matches!(source, DialectType::Snowflake)
                            && matches!(target, DialectType::DuckDB)
                        {
                            Action::DateTruncWrapCast
                        } else {
                            Action::None
                        }
                    }
                    // For DuckDB: SET a = 1 -> SET VARIABLE a = 1
                    Expression::SetStatement(s) => {
                        if matches!(target, DialectType::DuckDB)
                            && !matches!(source, DialectType::TSQL | DialectType::Fabric)
                            && s.items.iter().any(|item| item.kind.is_none())
                        {
                            Action::SetToVariable
                        } else {
                            Action::None
                        }
                    }
                    // Cross-dialect NULL ordering normalization.
                    // When nulls_first is not specified, fill in the source dialect's implied
                    // default so the target generator can correctly add/strip NULLS FIRST/LAST.
                    Expression::Ordered(o) => {
                        // MySQL doesn't support NULLS FIRST/LAST - strip or rewrite
                        if matches!(target, DialectType::MySQL) && o.nulls_first.is_some() {
                            Action::MysqlNullsOrdering
                        } else {
                            // Skip targets that don't support NULLS FIRST/LAST syntax
                            let target_supports_nulls = !matches!(
                                target,
                                DialectType::MySQL
                                    | DialectType::TSQL
                                    | DialectType::StarRocks
                                    | DialectType::Doris
                            );
                            if o.nulls_first.is_none() && source != target && target_supports_nulls
                            {
                                Action::NullsOrdering
                            } else {
                                Action::None
                            }
                        }
                    }
                    // BigQuery data types: convert INT64, BYTES, NUMERIC etc. to standard types
                    Expression::DataType(dt) => {
                        if matches!(source, DialectType::BigQuery)
                            && !matches!(target, DialectType::BigQuery)
                        {
                            match dt {
                                DataType::Custom { ref name }
                                    if name.eq_ignore_ascii_case("INT64")
                                        || name.eq_ignore_ascii_case("FLOAT64")
                                        || name.eq_ignore_ascii_case("BOOL")
                                        || name.eq_ignore_ascii_case("BYTES")
                                        || name.eq_ignore_ascii_case("NUMERIC")
                                        || name.eq_ignore_ascii_case("STRING")
                                        || name.eq_ignore_ascii_case("DATETIME") =>
                                {
                                    Action::BigQueryCastType
                                }
                                _ => Action::None,
                            }
                        } else if matches!(source, DialectType::TSQL) {
                            // For TSQL source -> any target (including TSQL itself for REAL)
                            match dt {
                                // REAL -> FLOAT even for TSQL->TSQL
                                DataType::Custom { ref name }
                                    if name.eq_ignore_ascii_case("REAL") =>
                                {
                                    Action::TSQLTypeNormalize
                                }
                                DataType::Float {
                                    real_spelling: true,
                                    ..
                                } => Action::TSQLTypeNormalize,
                                // Other TSQL type normalizations only for non-TSQL targets
                                DataType::Custom { ref name }
                                    if !matches!(target, DialectType::TSQL)
                                        && (name.eq_ignore_ascii_case("MONEY")
                                            || name.eq_ignore_ascii_case("SMALLMONEY")
                                            || name.eq_ignore_ascii_case("DATETIME2")
                                            || name.eq_ignore_ascii_case("IMAGE")
                                            || name.eq_ignore_ascii_case("BIT")
                                            || name.eq_ignore_ascii_case("ROWVERSION")
                                            || name.eq_ignore_ascii_case("UNIQUEIDENTIFIER")
                                            || name.eq_ignore_ascii_case("DATETIMEOFFSET")
                                            || name.to_uppercase().starts_with("NUMERIC")
                                            || name.to_uppercase().starts_with("DATETIME2(")
                                            || name.to_uppercase().starts_with("TIME(")) =>
                                {
                                    Action::TSQLTypeNormalize
                                }
                                DataType::Float {
                                    precision: Some(_), ..
                                } if !matches!(target, DialectType::TSQL) => {
                                    Action::TSQLTypeNormalize
                                }
                                DataType::TinyInt { .. }
                                    if !matches!(target, DialectType::TSQL) =>
                                {
                                    Action::TSQLTypeNormalize
                                }
                                // INTEGER -> INT for Databricks/Spark targets
                                DataType::Int {
                                    integer_spelling: true,
                                    ..
                                } if matches!(
                                    target,
                                    DialectType::Databricks | DialectType::Spark
                                ) =>
                                {
                                    Action::TSQLTypeNormalize
                                }
                                _ => Action::None,
                            }
                        } else if (matches!(source, DialectType::Oracle)
                            || matches!(source, DialectType::Generic))
                            && !matches!(target, DialectType::Oracle)
                        {
                            match dt {
                                DataType::Custom { ref name }
                                    if name.to_uppercase().starts_with("VARCHAR2(")
                                        || name.to_uppercase().starts_with("NVARCHAR2(")
                                        || name.eq_ignore_ascii_case("VARCHAR2")
                                        || name.eq_ignore_ascii_case("NVARCHAR2") =>
                                {
                                    Action::OracleVarchar2ToVarchar
                                }
                                _ => Action::None,
                            }
                        } else if matches!(target, DialectType::Snowflake)
                            && !matches!(source, DialectType::Snowflake)
                        {
                            // When target is Snowflake but source is NOT Snowflake,
                            // protect FLOAT from being converted to DOUBLE by Snowflake's transform.
                            // Snowflake treats FLOAT=DOUBLE internally, but non-Snowflake sources
                            // should keep their FLOAT spelling.
                            match dt {
                                DataType::Float { .. } => Action::SnowflakeFloatProtect,
                                _ => Action::None,
                            }
                        } else {
                            Action::None
                        }
                    }
                    // LOWER patterns from BigQuery TO_HEX conversions:
                    // - LOWER(LOWER(HEX(x))) from non-BQ targets: flatten
                    // - LOWER(Function("TO_HEX")) for BQ->BQ: strip LOWER
                    Expression::Lower(uf) => {
                        if matches!(source, DialectType::BigQuery) {
                            match &uf.this {
                                Expression::Lower(_) => Action::BigQueryToHexLower,
                                Expression::Function(f)
                                    if f.name == "TO_HEX"
                                        && matches!(target, DialectType::BigQuery) =>
                                {
                                    // BQ->BQ: LOWER(TO_HEX(x)) -> TO_HEX(x)
                                    Action::BigQueryToHexLower
                                }
                                _ => Action::None,
                            }
                        } else {
                            Action::None
                        }
                    }
                    // UPPER patterns from BigQuery TO_HEX conversions:
                    // - UPPER(LOWER(HEX(x))) from non-BQ targets: extract inner
                    // - UPPER(Function("TO_HEX")) for BQ->BQ: keep as UPPER(TO_HEX(x))
                    Expression::Upper(uf) => {
                        if matches!(source, DialectType::BigQuery) {
                            match &uf.this {
                                Expression::Lower(_) => Action::BigQueryToHexUpper,
                                _ => Action::None,
                            }
                        } else {
                            Action::None
                        }
                    }
                    // BigQuery LAST_DAY(date, unit) -> strip unit for non-BigQuery targets
                    // Snowflake supports LAST_DAY with unit, so keep it there
                    Expression::LastDay(ld) => {
                        if matches!(source, DialectType::BigQuery)
                            && !matches!(target, DialectType::BigQuery | DialectType::Snowflake)
                            && ld.unit.is_some()
                        {
                            Action::BigQueryLastDayStripUnit
                        } else {
                            Action::None
                        }
                    }
                    // BigQuery SafeDivide expressions (already parsed as SafeDivide)
                    Expression::SafeDivide(_) => {
                        if matches!(source, DialectType::BigQuery)
                            && !matches!(target, DialectType::BigQuery)
                        {
                            Action::BigQuerySafeDivide
                        } else {
                            Action::None
                        }
                    }
                    // BigQuery ANY_VALUE(x HAVING MAX/MIN y) -> ARG_MAX_NULL/ARG_MIN_NULL for DuckDB
                    // ANY_VALUE(x) -> ANY_VALUE(x) IGNORE NULLS for Spark
                    Expression::AnyValue(ref agg) => {
                        if matches!(source, DialectType::BigQuery)
                            && matches!(target, DialectType::DuckDB)
                            && agg.having_max.is_some()
                        {
                            Action::BigQueryAnyValueHaving
                        } else if matches!(target, DialectType::Spark | DialectType::Databricks)
                            && !matches!(source, DialectType::Spark | DialectType::Databricks)
                            && agg.ignore_nulls.is_none()
                        {
                            Action::AnyValueIgnoreNulls
                        } else {
                            Action::None
                        }
                    }
                    Expression::Any(ref q) => {
                        if matches!(source, DialectType::PostgreSQL)
                            && matches!(
                                target,
                                DialectType::Spark | DialectType::Databricks | DialectType::Hive
                            )
                            && q.op.is_some()
                            && !matches!(
                                q.subquery,
                                Expression::Select(_) | Expression::Subquery(_)
                            )
                        {
                            Action::AnyToExists
                        } else {
                            Action::None
                        }
                    }
                    // BigQuery APPROX_QUANTILES(x, n) -> APPROX_QUANTILE(x, [quantiles]) for DuckDB
                    // RegexpLike from non-DuckDB sources -> REGEXP_MATCHES for DuckDB target
                    // DuckDB's ~ is a full match, but other dialects' REGEXP/RLIKE is a partial match
                    Expression::RegexpLike(_)
                        if !matches!(source, DialectType::DuckDB)
                            && matches!(target, DialectType::DuckDB) =>
                    {
                        Action::RegexpLikeToDuckDB
                    }
                    // Safe-division source -> non-safe target: NULLIF wrapping and/or CAST
                    // Safe-division dialects: MySQL, DuckDB, SingleStore, TiDB, ClickHouse, Doris
                    Expression::Div(ref op)
                        if matches!(
                            source,
                            DialectType::MySQL
                                | DialectType::DuckDB
                                | DialectType::SingleStore
                                | DialectType::TiDB
                                | DialectType::ClickHouse
                                | DialectType::Doris
                        ) && matches!(
                            target,
                            DialectType::PostgreSQL
                                | DialectType::Redshift
                                | DialectType::Drill
                                | DialectType::Trino
                                | DialectType::Presto
                                | DialectType::Athena
                                | DialectType::TSQL
                                | DialectType::Teradata
                                | DialectType::SQLite
                                | DialectType::BigQuery
                                | DialectType::Snowflake
                                | DialectType::Databricks
                                | DialectType::Oracle
                                | DialectType::Materialize
                                | DialectType::RisingWave
                        ) =>
                    {
                        // Only wrap if RHS is not already NULLIF
                        if !matches!(&op.right, Expression::Function(f) if f.name.eq_ignore_ascii_case("NULLIF"))
                        {
                            Action::MySQLSafeDivide
                        } else {
                            Action::None
                        }
                    }
                    // ALTER TABLE ... RENAME TO <schema>.<table> -> strip schema for most targets
                    // For TSQL/Fabric, convert to sp_rename instead
                    Expression::AlterTable(ref at) if !at.actions.is_empty() => {
                        if let Some(crate::expressions::AlterTableAction::RenameTable(
                            ref new_tbl,
                        )) = at.actions.first()
                        {
                            if matches!(target, DialectType::TSQL | DialectType::Fabric) {
                                // TSQL: ALTER TABLE RENAME -> EXEC sp_rename
                                Action::AlterTableToSpRename
                            } else if new_tbl.schema.is_some()
                                && matches!(
                                    target,
                                    DialectType::BigQuery
                                        | DialectType::Doris
                                        | DialectType::StarRocks
                                        | DialectType::DuckDB
                                        | DialectType::PostgreSQL
                                        | DialectType::Redshift
                                )
                            {
                                Action::AlterTableRenameStripSchema
                            } else {
                                Action::None
                            }
                        } else {
                            Action::None
                        }
                    }
                    // EPOCH(x) expression -> target-specific epoch conversion
                    Expression::Epoch(_) if !matches!(target, DialectType::DuckDB) => {
                        Action::EpochConvert
                    }
                    // EPOCH_MS(x) expression -> target-specific epoch ms conversion
                    Expression::EpochMs(_) if !matches!(target, DialectType::DuckDB) => {
                        Action::EpochMsConvert
                    }
                    // STRING_AGG -> GROUP_CONCAT for MySQL/SQLite
                    Expression::StringAgg(_) => {
                        if matches!(
                            target,
                            DialectType::MySQL
                                | DialectType::SingleStore
                                | DialectType::Doris
                                | DialectType::StarRocks
                                | DialectType::SQLite
                        ) {
                            Action::StringAggConvert
                        } else if matches!(target, DialectType::Spark | DialectType::Databricks) {
                            Action::StringAggConvert
                        } else {
                            Action::None
                        }
                    }
                    // GROUP_CONCAT -> STRING_AGG for PostgreSQL/Presto/etc.
                    // Also handles GROUP_CONCAT normalization for MySQL/SQLite targets
                    Expression::GroupConcat(_) => Action::GroupConcatConvert,
                    // CARDINALITY/ARRAY_LENGTH/ARRAY_SIZE -> target-specific array length
                    Expression::Cardinality(_) | Expression::ArrayLength(_) => {
                        Action::ArrayLengthConvert
                    }
                    Expression::ArraySize(_) => {
                        if matches!(target, DialectType::Drill) {
                            Action::ArraySizeDrill
                        } else {
                            Action::ArrayLengthConvert
                        }
                    }
                    // ARRAY_REMOVE(arr, target) -> LIST_FILTER/arrayFilter/ARRAY subquery
                    Expression::ArrayRemove(_) => match target {
                        DialectType::DuckDB | DialectType::ClickHouse | DialectType::BigQuery => {
                            Action::ArrayRemoveConvert
                        }
                        _ => Action::None,
                    },
                    // ARRAY_REVERSE(x) -> arrayReverse for ClickHouse
                    Expression::ArrayReverse(_) => match target {
                        DialectType::ClickHouse => Action::ArrayReverseConvert,
                        _ => Action::None,
                    },
                    // JSON_KEYS(x) -> JSON_OBJECT_KEYS/OBJECT_KEYS for Spark/Databricks/Snowflake
                    Expression::JsonKeys(_) => match target {
                        DialectType::Spark | DialectType::Databricks | DialectType::Snowflake => {
                            Action::JsonKeysConvert
                        }
                        _ => Action::None,
                    },
                    // PARSE_JSON(x) -> strip for SQLite/Doris/MySQL/StarRocks
                    Expression::ParseJson(_) => match target {
                        DialectType::SQLite
                        | DialectType::Doris
                        | DialectType::MySQL
                        | DialectType::StarRocks => Action::ParseJsonStrip,
                        _ => Action::None,
                    },
                    // WeekOfYear -> WEEKISO for Snowflake (cross-dialect only)
                    Expression::WeekOfYear(_)
                        if matches!(target, DialectType::Snowflake)
                            && !matches!(source, DialectType::Snowflake) =>
                    {
                        Action::WeekOfYearToWeekIso
                    }
                    // NVL: clear original_name so generator uses dialect-specific function names
                    Expression::Nvl(f) if f.original_name.is_some() => Action::NvlClearOriginal,
                    // XOR: expand for dialects that don't support the XOR keyword
                    Expression::Xor(_) => {
                        let target_supports_xor = matches!(
                            target,
                            DialectType::MySQL
                                | DialectType::SingleStore
                                | DialectType::Doris
                                | DialectType::StarRocks
                        );
                        if !target_supports_xor {
                            Action::XorExpand
                        } else {
                            Action::None
                        }
                    }
                    // TSQL #table -> temp table normalization (CREATE TABLE)
                    Expression::CreateTable(ct)
                        if matches!(source, DialectType::TSQL | DialectType::Fabric)
                            && !matches!(target, DialectType::TSQL | DialectType::Fabric)
                            && ct.name.name.name.starts_with('#') =>
                    {
                        Action::TempTableHash
                    }
                    // TSQL #table -> strip # from table references in SELECT/etc.
                    Expression::Table(tr)
                        if matches!(source, DialectType::TSQL | DialectType::Fabric)
                            && !matches!(target, DialectType::TSQL | DialectType::Fabric)
                            && tr.name.name.starts_with('#') =>
                    {
                        Action::TempTableHash
                    }
                    // TSQL #table -> strip # from DROP TABLE names
                    Expression::DropTable(ref dt)
                        if matches!(source, DialectType::TSQL | DialectType::Fabric)
                            && !matches!(target, DialectType::TSQL | DialectType::Fabric)
                            && dt.names.iter().any(|n| n.name.name.starts_with('#')) =>
                    {
                        Action::TempTableHash
                    }
                    // JSON_EXTRACT -> ISNULL(JSON_QUERY, JSON_VALUE) for TSQL
                    Expression::JsonExtract(_)
                        if matches!(target, DialectType::TSQL | DialectType::Fabric) =>
                    {
                        Action::JsonExtractToTsql
                    }
                    // JSON_EXTRACT_SCALAR -> ISNULL(JSON_QUERY, JSON_VALUE) for TSQL
                    Expression::JsonExtractScalar(_)
                        if matches!(target, DialectType::TSQL | DialectType::Fabric) =>
                    {
                        Action::JsonExtractToTsql
                    }
                    // JSON_EXTRACT -> JSONExtractString for ClickHouse
                    Expression::JsonExtract(_) if matches!(target, DialectType::ClickHouse) => {
                        Action::JsonExtractToClickHouse
                    }
                    // JSON_EXTRACT_SCALAR -> JSONExtractString for ClickHouse
                    Expression::JsonExtractScalar(_)
                        if matches!(target, DialectType::ClickHouse) =>
                    {
                        Action::JsonExtractToClickHouse
                    }
                    // JSON_EXTRACT -> arrow syntax for SQLite/DuckDB
                    Expression::JsonExtract(ref f)
                        if !f.arrow_syntax
                            && matches!(target, DialectType::SQLite | DialectType::DuckDB) =>
                    {
                        Action::JsonExtractToArrow
                    }
                    // JSON_EXTRACT with JSONPath -> JSON_EXTRACT_PATH for PostgreSQL (non-PG sources only)
                    Expression::JsonExtract(ref f)
                        if matches!(target, DialectType::PostgreSQL | DialectType::Redshift)
                            && !matches!(
                                source,
                                DialectType::PostgreSQL
                                    | DialectType::Redshift
                                    | DialectType::Materialize
                            )
                            && matches!(&f.path, Expression::Literal(Literal::String(s)) if s.starts_with('$')) =>
                    {
                        Action::JsonExtractToGetJsonObject
                    }
                    // JSON_EXTRACT -> GET_JSON_OBJECT for Hive/Spark
                    Expression::JsonExtract(_)
                        if matches!(
                            target,
                            DialectType::Hive | DialectType::Spark | DialectType::Databricks
                        ) =>
                    {
                        Action::JsonExtractToGetJsonObject
                    }
                    // JSON_EXTRACT_SCALAR -> target-specific for PostgreSQL, Snowflake, SQLite
                    // Skip if already in arrow/hash_arrow syntax (same-dialect identity case)
                    Expression::JsonExtractScalar(ref f)
                        if !f.arrow_syntax
                            && !f.hash_arrow_syntax
                            && matches!(
                                target,
                                DialectType::PostgreSQL
                                    | DialectType::Redshift
                                    | DialectType::Snowflake
                                    | DialectType::SQLite
                                    | DialectType::DuckDB
                            ) =>
                    {
                        Action::JsonExtractScalarConvert
                    }
                    // JSON_EXTRACT_SCALAR -> GET_JSON_OBJECT for Hive/Spark
                    Expression::JsonExtractScalar(_)
                        if matches!(
                            target,
                            DialectType::Hive | DialectType::Spark | DialectType::Databricks
                        ) =>
                    {
                        Action::JsonExtractScalarToGetJsonObject
                    }
                    // JSON_EXTRACT path normalization for BigQuery, MySQL (bracket/wildcard handling)
                    Expression::JsonExtract(ref f)
                        if !f.arrow_syntax
                            && matches!(target, DialectType::BigQuery | DialectType::MySQL) =>
                    {
                        Action::JsonPathNormalize
                    }
                    // JsonQuery (parsed JSON_QUERY) -> target-specific
                    Expression::JsonQuery(_) => Action::JsonQueryValueConvert,
                    // JsonValue (parsed JSON_VALUE) -> target-specific
                    Expression::JsonValue(_) => Action::JsonQueryValueConvert,
                    // AT TIME ZONE -> AT_TIMEZONE for Presto, FROM_UTC_TIMESTAMP for Spark,
                    // TIMESTAMP(DATETIME(...)) for BigQuery, CONVERT_TIMEZONE for Snowflake
                    Expression::AtTimeZone(_)
                        if matches!(
                            target,
                            DialectType::Presto
                                | DialectType::Trino
                                | DialectType::Athena
                                | DialectType::Spark
                                | DialectType::Databricks
                                | DialectType::BigQuery
                                | DialectType::Snowflake
                        ) =>
                    {
                        Action::AtTimeZoneConvert
                    }
                    // DAY_OF_WEEK -> dialect-specific
                    Expression::DayOfWeek(_)
                        if matches!(
                            target,
                            DialectType::DuckDB | DialectType::Spark | DialectType::Databricks
                        ) =>
                    {
                        Action::DayOfWeekConvert
                    }
                    // CURRENT_USER -> CURRENT_USER() for Snowflake
                    Expression::CurrentUser(_) if matches!(target, DialectType::Snowflake) => {
                        Action::CurrentUserParens
                    }
                    // ELEMENT_AT(arr, idx) -> arr[idx] for PostgreSQL, arr[SAFE_ORDINAL(idx)] for BigQuery
                    Expression::ElementAt(_)
                        if matches!(target, DialectType::PostgreSQL | DialectType::BigQuery) =>
                    {
                        Action::ElementAtConvert
                    }
                    // ARRAY[...] (ArrayFunc bracket_notation=false) -> convert for target dialect
                    Expression::ArrayFunc(ref arr)
                        if !arr.bracket_notation
                            && matches!(
                                target,
                                DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive
                                    | DialectType::BigQuery
                                    | DialectType::DuckDB
                                    | DialectType::Snowflake
                                    | DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena
                                    | DialectType::ClickHouse
                                    | DialectType::StarRocks
                            ) =>
                    {
                        Action::ArraySyntaxConvert
                    }
                    // VARIANCE expression -> varSamp for ClickHouse
                    Expression::Variance(_) if matches!(target, DialectType::ClickHouse) => {
                        Action::VarianceToClickHouse
                    }
                    // STDDEV expression -> stddevSamp for ClickHouse
                    Expression::Stddev(_) if matches!(target, DialectType::ClickHouse) => {
                        Action::StddevToClickHouse
                    }
                    // ApproxQuantile -> APPROX_PERCENTILE for Snowflake
                    Expression::ApproxQuantile(_) if matches!(target, DialectType::Snowflake) => {
                        Action::ApproxQuantileConvert
                    }
                    // MonthsBetween -> target-specific
                    Expression::MonthsBetween(_)
                        if !matches!(
                            target,
                            DialectType::Spark | DialectType::Databricks | DialectType::Hive
                        ) =>
                    {
                        Action::MonthsBetweenConvert
                    }
                    // AddMonths -> target-specific DATEADD/DATE_ADD
                    Expression::AddMonths(_) => Action::AddMonthsConvert,
                    // MapFromArrays -> target-specific (MAP, OBJECT_CONSTRUCT, MAP_FROM_ARRAYS)
                    Expression::MapFromArrays(_)
                        if !matches!(target, DialectType::Spark | DialectType::Databricks) =>
                    {
                        Action::MapFromArraysConvert
                    }
                    // CURRENT_USER -> CURRENT_USER() for Spark
                    Expression::CurrentUser(_)
                        if matches!(target, DialectType::Spark | DialectType::Databricks) =>
                    {
                        Action::CurrentUserSparkParens
                    }
                    // MONTH/YEAR/DAY('string') from Spark -> cast string to DATE for DuckDB/Presto
                    Expression::Month(ref f) | Expression::Year(ref f) | Expression::Day(ref f)
                        if matches!(
                            source,
                            DialectType::Spark | DialectType::Databricks | DialectType::Hive
                        ) && matches!(&f.this, Expression::Literal(Literal::String(_)))
                            && matches!(
                                target,
                                DialectType::DuckDB
                                    | DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena
                                    | DialectType::PostgreSQL
                                    | DialectType::Redshift
                            ) =>
                    {
                        Action::SparkDateFuncCast
                    }
                    // $parameter -> @parameter for BigQuery
                    Expression::Parameter(ref p)
                        if matches!(target, DialectType::BigQuery)
                            && matches!(source, DialectType::DuckDB)
                            && (p.style == crate::expressions::ParameterStyle::Dollar
                                || p.style == crate::expressions::ParameterStyle::DoubleDollar) =>
                    {
                        Action::DollarParamConvert
                    }
                    // EscapeString literal: normalize literal newlines to \n
                    Expression::Literal(Literal::EscapeString(ref s))
                        if s.contains('\n') || s.contains('\r') || s.contains('\t') =>
                    {
                        Action::EscapeStringNormalize
                    }
                    // straight_join: keep lowercase for DuckDB, quote for MySQL
                    Expression::Column(ref col)
                        if col.name.name == "STRAIGHT_JOIN"
                            && col.table.is_none()
                            && matches!(source, DialectType::DuckDB)
                            && matches!(target, DialectType::DuckDB | DialectType::MySQL) =>
                    {
                        Action::StraightJoinCase
                    }
                    // DATE and TIMESTAMP literal type conversions are now handled in the generator directly
                    // Snowflake INTERVAL format: INTERVAL '2' HOUR -> INTERVAL '2 HOUR'
                    Expression::Interval(ref iv)
                        if matches!(
                            target,
                            DialectType::Snowflake
                                | DialectType::PostgreSQL
                                | DialectType::Redshift
                        ) && iv.unit.is_some()
                            && matches!(
                                &iv.this,
                                Some(Expression::Literal(Literal::String(_)))
                            ) =>
                    {
                        Action::SnowflakeIntervalFormat
                    }
                    // TABLESAMPLE -> TABLESAMPLE RESERVOIR for DuckDB target
                    Expression::TableSample(ref ts) if matches!(target, DialectType::DuckDB) => {
                        if let Some(ref sample) = ts.sample {
                            if !sample.explicit_method {
                                Action::TablesampleReservoir
                            } else {
                                Action::None
                            }
                        } else {
                            Action::None
                        }
                    }
                    // TABLESAMPLE from non-Snowflake source to Snowflake: strip method and PERCENT
                    // Handles both Expression::TableSample wrapper and Expression::Table with table_sample
                    Expression::TableSample(ref ts)
                        if matches!(target, DialectType::Snowflake)
                            && !matches!(source, DialectType::Snowflake)
                            && ts.sample.is_some() =>
                    {
                        if let Some(ref sample) = ts.sample {
                            if !sample.explicit_method {
                                Action::TablesampleSnowflakeStrip
                            } else {
                                Action::None
                            }
                        } else {
                            Action::None
                        }
                    }
                    Expression::Table(ref t)
                        if matches!(target, DialectType::Snowflake)
                            && !matches!(source, DialectType::Snowflake)
                            && t.table_sample.is_some() =>
                    {
                        if let Some(ref sample) = t.table_sample {
                            if !sample.explicit_method {
                                Action::TablesampleSnowflakeStrip
                            } else {
                                Action::None
                            }
                        } else {
                            Action::None
                        }
                    }
                    // ALTER TABLE RENAME -> EXEC sp_rename for TSQL
                    Expression::AlterTable(ref at)
                        if matches!(target, DialectType::TSQL | DialectType::Fabric)
                            && !at.actions.is_empty()
                            && matches!(
                                at.actions.first(),
                                Some(crate::expressions::AlterTableAction::RenameTable(_))
                            ) =>
                    {
                        Action::AlterTableToSpRename
                    }
                    // Subscript index: 1-based to 0-based for BigQuery/Hive/Spark
                    Expression::Subscript(ref sub)
                        if matches!(
                            target,
                            DialectType::BigQuery
                                | DialectType::Hive
                                | DialectType::Spark
                                | DialectType::Databricks
                        ) && matches!(
                            source,
                            DialectType::DuckDB
                                | DialectType::PostgreSQL
                                | DialectType::Presto
                                | DialectType::Trino
                                | DialectType::Redshift
                                | DialectType::ClickHouse
                        ) && matches!(&sub.index, Expression::Literal(Literal::Number(ref n)) if n.parse::<i64>().unwrap_or(0) > 0) =>
                    {
                        Action::ArrayIndexConvert
                    }
                    // ANY_VALUE IGNORE NULLS detection moved to the AnyValue arm above
                    // MysqlNullsOrdering for Ordered is now handled in the Ordered arm above
                    // RESPECT NULLS handling for SQLite (strip it, add NULLS LAST to ORDER BY)
                    // and for MySQL (rewrite ORDER BY with CASE WHEN for null ordering)
                    Expression::WindowFunction(ref wf) => {
                        // BigQuery doesn't support NULLS FIRST/LAST in window function ORDER BY
                        // EXCEPT for ROW_NUMBER which keeps NULLS LAST
                        let is_row_number = matches!(wf.this, Expression::RowNumber(_));
                        if matches!(target, DialectType::BigQuery)
                            && !is_row_number
                            && !wf.over.order_by.is_empty()
                            && wf.over.order_by.iter().any(|o| o.nulls_first.is_some())
                        {
                            Action::BigQueryNullsOrdering
                        // DuckDB -> MySQL: Add CASE WHEN for NULLS LAST simulation in window ORDER BY
                        // But NOT when frame is RANGE/GROUPS, since adding CASE WHEN would break value-based frames
                        } else {
                            let source_nulls_last = matches!(source, DialectType::DuckDB);
                            let has_range_frame = wf.over.frame.as_ref().map_or(false, |f| {
                                matches!(
                                    f.kind,
                                    crate::expressions::WindowFrameKind::Range
                                        | crate::expressions::WindowFrameKind::Groups
                                )
                            });
                            if source_nulls_last
                                && matches!(target, DialectType::MySQL)
                                && !wf.over.order_by.is_empty()
                                && wf.over.order_by.iter().any(|o| !o.desc)
                                && !has_range_frame
                            {
                                Action::MysqlNullsLastRewrite
                            } else {
                                match &wf.this {
                                    Expression::FirstValue(ref vf)
                                    | Expression::LastValue(ref vf)
                                        if vf.ignore_nulls == Some(false) =>
                                    {
                                        // RESPECT NULLS
                                        match target {
                                            DialectType::SQLite => Action::RespectNullsConvert,
                                            _ => Action::None,
                                        }
                                    }
                                    _ => Action::None,
                                }
                            }
                        }
                    }
                    // CREATE TABLE a LIKE b -> dialect-specific transformations
                    Expression::CreateTable(ref ct)
                        if ct.columns.is_empty()
                            && ct.constraints.iter().any(|c| {
                                matches!(c, crate::expressions::TableConstraint::Like { .. })
                            })
                            && matches!(
                                target,
                                DialectType::DuckDB | DialectType::SQLite | DialectType::Drill
                            ) =>
                    {
                        Action::CreateTableLikeToCtas
                    }
                    Expression::CreateTable(ref ct)
                        if ct.columns.is_empty()
                            && ct.constraints.iter().any(|c| {
                                matches!(c, crate::expressions::TableConstraint::Like { .. })
                            })
                            && matches!(target, DialectType::TSQL | DialectType::Fabric) =>
                    {
                        Action::CreateTableLikeToSelectInto
                    }
                    Expression::CreateTable(ref ct)
                        if ct.columns.is_empty()
                            && ct.constraints.iter().any(|c| {
                                matches!(c, crate::expressions::TableConstraint::Like { .. })
                            })
                            && matches!(target, DialectType::ClickHouse) =>
                    {
                        Action::CreateTableLikeToAs
                    }
                    // CREATE TABLE: strip COMMENT column constraint, USING, PARTITIONED BY for DuckDB
                    Expression::CreateTable(ref ct)
                        if matches!(target, DialectType::DuckDB)
                            && matches!(
                                source,
                                DialectType::DuckDB
                                    | DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive
                            ) =>
                    {
                        let has_comment = ct.columns.iter().any(|c| {
                            c.comment.is_some()
                                || c.constraints.iter().any(|con| {
                                    matches!(con, crate::expressions::ColumnConstraint::Comment(_))
                                })
                        });
                        let has_props = !ct.properties.is_empty();
                        if has_comment || has_props {
                            Action::CreateTableStripComment
                        } else {
                            Action::None
                        }
                    }
                    // Array conversion: Expression::Array -> Expression::ArrayFunc for PostgreSQL
                    Expression::Array(_)
                        if matches!(target, DialectType::PostgreSQL | DialectType::Redshift) =>
                    {
                        Action::ArrayConcatBracketConvert
                    }
                    // ArrayFunc (bracket notation) -> Function("ARRAY") for Redshift (from BigQuery source)
                    Expression::ArrayFunc(ref arr)
                        if arr.bracket_notation
                            && matches!(source, DialectType::BigQuery)
                            && matches!(target, DialectType::Redshift) =>
                    {
                        Action::ArrayConcatBracketConvert
                    }
                    // BIT_OR/BIT_AND/BIT_XOR: float/decimal arg cast for DuckDB, or rename for Snowflake
                    Expression::BitwiseOrAgg(ref f)
                    | Expression::BitwiseAndAgg(ref f)
                    | Expression::BitwiseXorAgg(ref f) => {
                        if matches!(target, DialectType::DuckDB) {
                            // Check if the arg is CAST(val AS FLOAT/DOUBLE/DECIMAL/REAL)
                            if let Expression::Cast(ref c) = f.this {
                                match &c.to {
                                    DataType::Float { .. }
                                    | DataType::Double { .. }
                                    | DataType::Decimal { .. } => Action::BitAggFloatCast,
                                    DataType::Custom { ref name }
                                        if name.eq_ignore_ascii_case("REAL") =>
                                    {
                                        Action::BitAggFloatCast
                                    }
                                    _ => Action::None,
                                }
                            } else {
                                Action::None
                            }
                        } else if matches!(target, DialectType::Snowflake) {
                            Action::BitAggSnowflakeRename
                        } else {
                            Action::None
                        }
                    }
                    // FILTER -> IFF for Snowflake (aggregate functions with FILTER clause)
                    Expression::Filter(ref _f) if matches!(target, DialectType::Snowflake) => {
                        Action::FilterToIff
                    }
                    // AggFunc.filter -> IFF wrapping for Snowflake (e.g., AVG(x) FILTER(WHERE cond))
                    Expression::Avg(ref f)
                    | Expression::Sum(ref f)
                    | Expression::Min(ref f)
                    | Expression::Max(ref f)
                    | Expression::CountIf(ref f)
                    | Expression::Stddev(ref f)
                    | Expression::StddevPop(ref f)
                    | Expression::StddevSamp(ref f)
                    | Expression::Variance(ref f)
                    | Expression::VarPop(ref f)
                    | Expression::VarSamp(ref f)
                    | Expression::Median(ref f)
                    | Expression::Mode(ref f)
                    | Expression::First(ref f)
                    | Expression::Last(ref f)
                    | Expression::ApproxDistinct(ref f)
                        if f.filter.is_some() && matches!(target, DialectType::Snowflake) =>
                    {
                        Action::AggFilterToIff
                    }
                    Expression::Count(ref c)
                        if c.filter.is_some() && matches!(target, DialectType::Snowflake) =>
                    {
                        Action::AggFilterToIff
                    }
                    // COUNT(DISTINCT a, b) -> COUNT(DISTINCT CASE WHEN ... END) for dialects that don't support multi-arg DISTINCT
                    Expression::Count(ref c)
                        if c.distinct
                            && matches!(&c.this, Some(Expression::Tuple(_)))
                            && matches!(
                                target,
                                DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::DuckDB
                                    | DialectType::PostgreSQL
                            ) =>
                    {
                        Action::CountDistinctMultiArg
                    }
                    // JSON arrow -> GET_PATH/PARSE_JSON for Snowflake
                    Expression::JsonExtract(_) if matches!(target, DialectType::Snowflake) => {
                        Action::JsonToGetPath
                    }
                    // DuckDB struct/dict -> BigQuery STRUCT / Presto ROW
                    Expression::Struct(_)
                        if matches!(
                            target,
                            DialectType::BigQuery | DialectType::Presto | DialectType::Trino
                        ) && matches!(source, DialectType::DuckDB) =>
                    {
                        Action::StructToRow
                    }
                    // DuckDB curly-brace dict {'key': value} -> BigQuery STRUCT / Presto ROW
                    Expression::MapFunc(ref m)
                        if m.curly_brace_syntax
                            && matches!(
                                target,
                                DialectType::BigQuery | DialectType::Presto | DialectType::Trino
                            )
                            && matches!(source, DialectType::DuckDB) =>
                    {
                        Action::StructToRow
                    }
                    // APPROX_COUNT_DISTINCT -> APPROX_DISTINCT for Presto/Trino
                    Expression::ApproxCountDistinct(_)
                        if matches!(
                            target,
                            DialectType::Presto | DialectType::Trino | DialectType::Athena
                        ) =>
                    {
                        Action::ApproxCountDistinctToApproxDistinct
                    }
                    // ARRAY_CONTAINS(arr, val) -> CONTAINS(arr, val) for Presto, ARRAY_CONTAINS(CAST(val AS VARIANT), arr) for Snowflake
                    Expression::ArrayContains(_)
                        if matches!(
                            target,
                            DialectType::Presto | DialectType::Trino | DialectType::Snowflake
                        ) =>
                    {
                        Action::ArrayContainsConvert
                    }
                    // StrPosition with position -> complex expansion for Presto/DuckDB
                    // STRPOS doesn't support a position arg in these dialects
                    Expression::StrPosition(ref sp)
                        if sp.position.is_some()
                            && matches!(
                                target,
                                DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena
                                    | DialectType::DuckDB
                            ) =>
                    {
                        Action::StrPositionExpand
                    }
                    // FIRST(col) IGNORE NULLS -> ANY_VALUE(col) for DuckDB
                    Expression::First(ref f)
                        if f.ignore_nulls == Some(true)
                            && matches!(target, DialectType::DuckDB) =>
                    {
                        Action::FirstToAnyValue
                    }
                    // BEGIN -> START TRANSACTION for Presto/Trino
                    Expression::Command(ref cmd)
                        if cmd.this.eq_ignore_ascii_case("BEGIN")
                            && matches!(
                                target,
                                DialectType::Presto | DialectType::Trino | DialectType::Athena
                            ) =>
                    {
                        // Handled inline below
                        Action::None // We'll handle it directly
                    }
                    // Note: PostgreSQL ^ is now parsed as Power directly (not BitwiseXor).
                    // PostgreSQL # is parsed as BitwiseXor (which is correct).
                    // a || b (Concat operator) -> CONCAT function for Presto/Trino
                    Expression::Concat(ref _op)
                        if matches!(source, DialectType::PostgreSQL | DialectType::Redshift)
                            && matches!(target, DialectType::Presto | DialectType::Trino) =>
                    {
                        Action::PipeConcatToConcat
                    }
                    _ => Action::None,
                }
            };

            match action {
                Action::None => {
                    // Handle inline transforms that don't need a dedicated action

                    // BETWEEN SYMMETRIC/ASYMMETRIC expansion for non-PostgreSQL/Dremio targets
                    if let Expression::Between(ref b) = e {
                        if let Some(sym) = b.symmetric {
                            let keeps_symmetric =
                                matches!(target, DialectType::PostgreSQL | DialectType::Dremio);
                            if !keeps_symmetric {
                                if sym {
                                    // SYMMETRIC: expand to (x BETWEEN a AND b OR x BETWEEN b AND a)
                                    let b = if let Expression::Between(b) = e {
                                        *b
                                    } else {
                                        unreachable!()
                                    };
                                    let between1 = Expression::Between(Box::new(
                                        crate::expressions::Between {
                                            this: b.this.clone(),
                                            low: b.low.clone(),
                                            high: b.high.clone(),
                                            not: b.not,
                                            symmetric: None,
                                        },
                                    ));
                                    let between2 = Expression::Between(Box::new(
                                        crate::expressions::Between {
                                            this: b.this,
                                            low: b.high,
                                            high: b.low,
                                            not: b.not,
                                            symmetric: None,
                                        },
                                    ));
                                    return Ok(Expression::Paren(Box::new(
                                        crate::expressions::Paren {
                                            this: Expression::Or(Box::new(
                                                crate::expressions::BinaryOp::new(
                                                    between1, between2,
                                                ),
                                            )),
                                            trailing_comments: vec![],
                                        },
                                    )));
                                } else {
                                    // ASYMMETRIC: strip qualifier, keep as regular BETWEEN
                                    let b = if let Expression::Between(b) = e {
                                        *b
                                    } else {
                                        unreachable!()
                                    };
                                    return Ok(Expression::Between(Box::new(
                                        crate::expressions::Between {
                                            this: b.this,
                                            low: b.low,
                                            high: b.high,
                                            not: b.not,
                                            symmetric: None,
                                        },
                                    )));
                                }
                            }
                        }
                    }

                    // ILIKE -> LOWER(x) LIKE LOWER(y) for StarRocks/Doris
                    if let Expression::ILike(ref _like) = e {
                        if matches!(target, DialectType::StarRocks | DialectType::Doris) {
                            let like = if let Expression::ILike(l) = e {
                                *l
                            } else {
                                unreachable!()
                            };
                            let lower_left = Expression::Function(Box::new(Function::new(
                                "LOWER".to_string(),
                                vec![like.left],
                            )));
                            let lower_right = Expression::Function(Box::new(Function::new(
                                "LOWER".to_string(),
                                vec![like.right],
                            )));
                            return Ok(Expression::Like(Box::new(crate::expressions::LikeOp {
                                left: lower_left,
                                right: lower_right,
                                escape: like.escape,
                                quantifier: like.quantifier,
                            })));
                        }
                    }

                    // Oracle DBMS_RANDOM.VALUE() -> RANDOM() for PostgreSQL, RAND() for others
                    if let Expression::MethodCall(ref mc) = e {
                        if matches!(source, DialectType::Oracle)
                            && mc.method.name.eq_ignore_ascii_case("VALUE")
                            && mc.args.is_empty()
                        {
                            let is_dbms_random = match &mc.this {
                                Expression::Identifier(id) => {
                                    id.name.eq_ignore_ascii_case("DBMS_RANDOM")
                                }
                                Expression::Column(col) => {
                                    col.table.is_none()
                                        && col.name.name.eq_ignore_ascii_case("DBMS_RANDOM")
                                }
                                _ => false,
                            };
                            if is_dbms_random {
                                let func_name = match target {
                                    DialectType::PostgreSQL
                                    | DialectType::Redshift
                                    | DialectType::DuckDB
                                    | DialectType::SQLite => "RANDOM",
                                    DialectType::Oracle => "DBMS_RANDOM.VALUE",
                                    _ => "RAND",
                                };
                                return Ok(Expression::Function(Box::new(Function::new(
                                    func_name.to_string(),
                                    vec![],
                                ))));
                            }
                        }
                    }
                    // TRIM without explicit position -> add BOTH for ClickHouse
                    if let Expression::Trim(ref trim) = e {
                        if matches!(target, DialectType::ClickHouse)
                            && trim.sql_standard_syntax
                            && trim.characters.is_some()
                            && !trim.position_explicit
                        {
                            let mut new_trim = (**trim).clone();
                            new_trim.position_explicit = true;
                            return Ok(Expression::Trim(Box::new(new_trim)));
                        }
                    }
                    // BEGIN -> START TRANSACTION for Presto/Trino
                    if let Expression::Transaction(ref txn) = e {
                        if matches!(
                            target,
                            DialectType::Presto | DialectType::Trino | DialectType::Athena
                        ) {
                            // Convert BEGIN to START TRANSACTION by setting mark to "START"
                            let mut txn = txn.clone();
                            txn.mark = Some(Box::new(Expression::Identifier(Identifier::new(
                                "START".to_string(),
                            ))));
                            return Ok(Expression::Transaction(Box::new(*txn)));
                        }
                    }
                    // IS TRUE/FALSE -> simplified forms for Presto/Trino
                    if matches!(
                        target,
                        DialectType::Presto | DialectType::Trino | DialectType::Athena
                    ) {
                        match &e {
                            Expression::IsTrue(itf) if !itf.not => {
                                // x IS TRUE -> x
                                return Ok(itf.this.clone());
                            }
                            Expression::IsTrue(itf) if itf.not => {
                                // x IS NOT TRUE -> NOT x
                                return Ok(Expression::Not(Box::new(
                                    crate::expressions::UnaryOp {
                                        this: itf.this.clone(),
                                    },
                                )));
                            }
                            Expression::IsFalse(itf) if !itf.not => {
                                // x IS FALSE -> NOT x
                                return Ok(Expression::Not(Box::new(
                                    crate::expressions::UnaryOp {
                                        this: itf.this.clone(),
                                    },
                                )));
                            }
                            Expression::IsFalse(itf) if itf.not => {
                                // x IS NOT FALSE -> NOT NOT x
                                let not_x =
                                    Expression::Not(Box::new(crate::expressions::UnaryOp {
                                        this: itf.this.clone(),
                                    }));
                                return Ok(Expression::Not(Box::new(
                                    crate::expressions::UnaryOp { this: not_x },
                                )));
                            }
                            _ => {}
                        }
                    }
                    // x IS NOT FALSE -> NOT x IS FALSE for Redshift
                    if matches!(target, DialectType::Redshift) {
                        if let Expression::IsFalse(ref itf) = e {
                            if itf.not {
                                return Ok(Expression::Not(Box::new(
                                    crate::expressions::UnaryOp {
                                        this: Expression::IsFalse(Box::new(
                                            crate::expressions::IsTrueFalse {
                                                this: itf.this.clone(),
                                                not: false,
                                            },
                                        )),
                                    },
                                )));
                            }
                        }
                    }
                    // REGEXP_REPLACE: add 'g' flag when source defaults to global replacement
                    // Snowflake default is global, PostgreSQL/DuckDB default is first-match-only
                    if let Expression::Function(ref f) = e {
                        if f.name.eq_ignore_ascii_case("REGEXP_REPLACE")
                            && matches!(source, DialectType::Snowflake)
                            && matches!(target, DialectType::PostgreSQL | DialectType::DuckDB)
                        {
                            if f.args.len() == 3 {
                                let mut args = f.args.clone();
                                args.push(Expression::string("g"));
                                return Ok(Expression::Function(Box::new(Function::new(
                                    "REGEXP_REPLACE".to_string(),
                                    args,
                                ))));
                            } else if f.args.len() == 4 {
                                // 4th arg might be position, add 'g' as 5th
                                let mut args = f.args.clone();
                                args.push(Expression::string("g"));
                                return Ok(Expression::Function(Box::new(Function::new(
                                    "REGEXP_REPLACE".to_string(),
                                    args,
                                ))));
                            }
                        }
                    }
                    Ok(e)
                }

                Action::GreatestLeastNull => {
                    let f = if let Expression::Function(f) = e {
                        *f
                    } else {
                        unreachable!("action only triggered for Function expressions")
                    };
                    let mut null_checks: Vec<Expression> = f
                        .args
                        .iter()
                        .map(|a| {
                            Expression::IsNull(Box::new(IsNull {
                                this: a.clone(),
                                not: false,
                                postfix_form: false,
                            }))
                        })
                        .collect();
                    let condition = if null_checks.len() == 1 {
                        null_checks.remove(0)
                    } else {
                        let first = null_checks.remove(0);
                        null_checks.into_iter().fold(first, |acc, check| {
                            Expression::Or(Box::new(BinaryOp::new(acc, check)))
                        })
                    };
                    Ok(Expression::Case(Box::new(Case {
                        operand: None,
                        whens: vec![(condition, Expression::Null(Null))],
                        else_: Some(Expression::Function(Box::new(Function::new(
                            f.name, f.args,
                        )))),
                        comments: Vec::new(),
                    })))
                }

                Action::ArrayGenerateRange => {
                    let f = if let Expression::Function(f) = e {
                        *f
                    } else {
                        unreachable!("action only triggered for Function expressions")
                    };
                    let start = f.args[0].clone();
                    let end = f.args[1].clone();
                    let step = f.args.get(2).cloned();

                    let end_minus_1 = Expression::Sub(Box::new(BinaryOp::new(
                        end.clone(),
                        Expression::number(1),
                    )));

                    match target {
                        DialectType::PostgreSQL | DialectType::Redshift => {
                            let mut args = vec![start, end_minus_1];
                            if let Some(s) = step {
                                args.push(s);
                            }
                            Ok(Expression::Function(Box::new(Function::new(
                                "GENERATE_SERIES".to_string(),
                                args,
                            ))))
                        }
                        DialectType::Presto | DialectType::Trino => {
                            let mut args = vec![start, end_minus_1];
                            if let Some(s) = step {
                                args.push(s);
                            }
                            Ok(Expression::Function(Box::new(Function::new(
                                "SEQUENCE".to_string(),
                                args,
                            ))))
                        }
                        DialectType::BigQuery => {
                            let mut args = vec![start, end_minus_1];
                            if let Some(s) = step {
                                args.push(s);
                            }
                            Ok(Expression::Function(Box::new(Function::new(
                                "GENERATE_ARRAY".to_string(),
                                args,
                            ))))
                        }
                        DialectType::Snowflake => {
                            let normalized_end = Expression::Add(Box::new(BinaryOp::new(
                                Expression::Paren(Box::new(Paren {
                                    this: end_minus_1,
                                    trailing_comments: vec![],
                                })),
                                Expression::number(1),
                            )));
                            let mut args = vec![start, normalized_end];
                            if let Some(s) = step {
                                args.push(s);
                            }
                            Ok(Expression::Function(Box::new(Function::new(
                                "ARRAY_GENERATE_RANGE".to_string(),
                                args,
                            ))))
                        }
                        _ => Ok(Expression::Function(Box::new(Function::new(
                            f.name, f.args,
                        )))),
                    }
                }

                Action::Div0TypedDivision => {
                    let if_func = if let Expression::IfFunc(f) = e {
                        *f
                    } else {
                        unreachable!("action only triggered for IfFunc expressions")
                    };
                    if let Some(Expression::Div(div)) = if_func.false_value {
                        let cast_type = if matches!(target, DialectType::SQLite) {
                            DataType::Float {
                                precision: None,
                                scale: None,
                                real_spelling: true,
                            }
                        } else {
                            DataType::Double {
                                precision: None,
                                scale: None,
                            }
                        };
                        let casted_left = Expression::Cast(Box::new(Cast {
                            this: div.left,
                            to: cast_type,
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        }));
                        Ok(Expression::IfFunc(Box::new(crate::expressions::IfFunc {
                            condition: if_func.condition,
                            true_value: if_func.true_value,
                            false_value: Some(Expression::Div(Box::new(BinaryOp::new(
                                casted_left,
                                div.right,
                            )))),
                            original_name: if_func.original_name,
                        })))
                    } else {
                        // Not actually a Div, reconstruct
                        Ok(Expression::IfFunc(Box::new(if_func)))
                    }
                }

                Action::ArrayAggCollectList => {
                    let agg = if let Expression::ArrayAgg(a) = e {
                        *a
                    } else {
                        unreachable!("action only triggered for ArrayAgg expressions")
                    };
                    Ok(Expression::ArrayAgg(Box::new(AggFunc {
                        name: Some("COLLECT_LIST".to_string()),
                        ..agg
                    })))
                }

                Action::ArrayAggWithinGroupFilter => {
                    let wg = if let Expression::WithinGroup(w) = e {
                        *w
                    } else {
                        unreachable!("action only triggered for WithinGroup expressions")
                    };
                    if let Expression::ArrayAgg(inner_agg) = wg.this {
                        let col = inner_agg.this.clone();
                        let filter = Expression::IsNull(Box::new(IsNull {
                            this: col,
                            not: true,
                            postfix_form: false,
                        }));
                        // For DuckDB, add explicit NULLS FIRST for DESC ordering
                        let order_by = if matches!(target, DialectType::DuckDB) {
                            wg.order_by
                                .into_iter()
                                .map(|mut o| {
                                    if o.desc && o.nulls_first.is_none() {
                                        o.nulls_first = Some(true);
                                    }
                                    o
                                })
                                .collect()
                        } else {
                            wg.order_by
                        };
                        Ok(Expression::ArrayAgg(Box::new(AggFunc {
                            this: inner_agg.this,
                            distinct: inner_agg.distinct,
                            filter: Some(filter),
                            order_by,
                            name: inner_agg.name,
                            ignore_nulls: inner_agg.ignore_nulls,
                            having_max: inner_agg.having_max,
                            limit: inner_agg.limit,
                        })))
                    } else {
                        Ok(Expression::WithinGroup(Box::new(wg)))
                    }
                }

                Action::ArrayAggFilter => {
                    let agg = if let Expression::ArrayAgg(a) = e {
                        *a
                    } else {
                        unreachable!("action only triggered for ArrayAgg expressions")
                    };
                    let col = agg.this.clone();
                    let filter = Expression::IsNull(Box::new(IsNull {
                        this: col,
                        not: true,
                        postfix_form: false,
                    }));
                    Ok(Expression::ArrayAgg(Box::new(AggFunc {
                        filter: Some(filter),
                        ..agg
                    })))
                }

                Action::ArrayAggNullFilter => {
                    // ARRAY_AGG(x) FILTER(WHERE cond) -> ARRAY_AGG(x) FILTER(WHERE cond AND NOT x IS NULL)
                    // For source dialects that exclude NULLs (Spark/Hive) targeting DuckDB which includes them
                    let agg = if let Expression::ArrayAgg(a) = e {
                        *a
                    } else {
                        unreachable!("action only triggered for ArrayAgg expressions")
                    };
                    let col = agg.this.clone();
                    let not_null = Expression::IsNull(Box::new(IsNull {
                        this: col,
                        not: true,
                        postfix_form: true, // Use "NOT x IS NULL" form (prefix NOT)
                    }));
                    let new_filter = if let Some(existing_filter) = agg.filter {
                        // AND the NOT IS NULL with existing filter
                        Expression::And(Box::new(crate::expressions::BinaryOp::new(
                            existing_filter,
                            not_null,
                        )))
                    } else {
                        not_null
                    };
                    Ok(Expression::ArrayAgg(Box::new(AggFunc {
                        filter: Some(new_filter),
                        ..agg
                    })))
                }

                Action::BigQueryArraySelectAsStructToSnowflake => {
                    // ARRAY(SELECT AS STRUCT x1 AS x1, x2 AS x2 FROM t)
                    // -> (SELECT ARRAY_AGG(OBJECT_CONSTRUCT('x1', x1, 'x2', x2)) FROM t)
                    if let Expression::Function(mut f) = e {
                        let is_match = f.args.len() == 1
                            && matches!(&f.args[0], Expression::Select(s) if s.kind.as_deref() == Some("STRUCT"));
                        if is_match {
                            let inner_select = match f.args.remove(0) {
                                Expression::Select(s) => *s,
                                _ => unreachable!(
                                    "argument already verified to be a Select expression"
                                ),
                            };
                            // Build OBJECT_CONSTRUCT args from SELECT expressions
                            let mut oc_args = Vec::new();
                            for expr in &inner_select.expressions {
                                match expr {
                                    Expression::Alias(a) => {
                                        let key = Expression::Literal(Literal::String(
                                            a.alias.name.clone(),
                                        ));
                                        let value = a.this.clone();
                                        oc_args.push(key);
                                        oc_args.push(value);
                                    }
                                    Expression::Column(c) => {
                                        let key = Expression::Literal(Literal::String(
                                            c.name.name.clone(),
                                        ));
                                        oc_args.push(key);
                                        oc_args.push(expr.clone());
                                    }
                                    _ => {
                                        oc_args.push(expr.clone());
                                    }
                                }
                            }
                            let object_construct = Expression::Function(Box::new(Function::new(
                                "OBJECT_CONSTRUCT".to_string(),
                                oc_args,
                            )));
                            let array_agg = Expression::Function(Box::new(Function::new(
                                "ARRAY_AGG".to_string(),
                                vec![object_construct],
                            )));
                            let mut new_select = crate::expressions::Select::new();
                            new_select.expressions = vec![array_agg];
                            new_select.from = inner_select.from.clone();
                            new_select.where_clause = inner_select.where_clause.clone();
                            new_select.group_by = inner_select.group_by.clone();
                            new_select.having = inner_select.having.clone();
                            new_select.joins = inner_select.joins.clone();
                            Ok(Expression::Subquery(Box::new(
                                crate::expressions::Subquery {
                                    this: Expression::Select(Box::new(new_select)),
                                    alias: None,
                                    column_aliases: Vec::new(),
                                    order_by: None,
                                    limit: None,
                                    offset: None,
                                    distribute_by: None,
                                    sort_by: None,
                                    cluster_by: None,
                                    lateral: false,
                                    modifiers_inside: false,
                                    trailing_comments: Vec::new(),
                                },
                            )))
                        } else {
                            Ok(Expression::Function(f))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::BigQueryPercentileContToDuckDB => {
                    // PERCENTILE_CONT(x, frac [RESPECT NULLS]) -> QUANTILE_CONT(x, frac) for DuckDB
                    if let Expression::AggregateFunction(mut af) = e {
                        af.name = "QUANTILE_CONT".to_string();
                        af.ignore_nulls = None; // Strip RESPECT/IGNORE NULLS
                                                // Keep only first 2 args
                        if af.args.len() > 2 {
                            af.args.truncate(2);
                        }
                        Ok(Expression::AggregateFunction(af))
                    } else {
                        Ok(e)
                    }
                }

                Action::ArrayAggIgnoreNullsDuckDB => {
                    // ARRAY_AGG(x IGNORE NULLS ORDER BY a, b DESC) -> ARRAY_AGG(x ORDER BY a NULLS FIRST, b DESC)
                    // Strip IGNORE NULLS, add NULLS FIRST to first ORDER BY column
                    let mut agg = if let Expression::ArrayAgg(a) = e {
                        *a
                    } else {
                        unreachable!("action only triggered for ArrayAgg expressions")
                    };
                    agg.ignore_nulls = None; // Strip IGNORE NULLS
                    if !agg.order_by.is_empty() {
                        agg.order_by[0].nulls_first = Some(true);
                    }
                    Ok(Expression::ArrayAgg(Box::new(agg)))
                }

                Action::CountDistinctMultiArg => {
                    // COUNT(DISTINCT a, b) -> COUNT(DISTINCT CASE WHEN a IS NULL THEN NULL WHEN b IS NULL THEN NULL ELSE (a, b) END)
                    if let Expression::Count(c) = e {
                        if let Some(Expression::Tuple(t)) = c.this {
                            let args = t.expressions;
                            // Build CASE expression:
                            // WHEN a IS NULL THEN NULL WHEN b IS NULL THEN NULL ELSE (a, b) END
                            let mut whens = Vec::new();
                            for arg in &args {
                                whens.push((
                                    Expression::IsNull(Box::new(IsNull {
                                        this: arg.clone(),
                                        not: false,
                                        postfix_form: false,
                                    })),
                                    Expression::Null(crate::expressions::Null),
                                ));
                            }
                            // Build the tuple for ELSE
                            let tuple_expr =
                                Expression::Tuple(Box::new(crate::expressions::Tuple {
                                    expressions: args,
                                }));
                            let case_expr = Expression::Case(Box::new(crate::expressions::Case {
                                operand: None,
                                whens,
                                else_: Some(tuple_expr),
                                comments: Vec::new(),
                            }));
                            Ok(Expression::Count(Box::new(crate::expressions::CountFunc {
                                this: Some(case_expr),
                                star: false,
                                distinct: true,
                                filter: c.filter,
                                ignore_nulls: c.ignore_nulls,
                                original_name: c.original_name,
                            })))
                        } else {
                            Ok(Expression::Count(c))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::CastTimestampToDatetime => {
                    let c = if let Expression::Cast(c) = e {
                        *c
                    } else {
                        unreachable!("action only triggered for Cast expressions")
                    };
                    Ok(Expression::Cast(Box::new(Cast {
                        to: DataType::Custom {
                            name: "DATETIME".to_string(),
                        },
                        ..c
                    })))
                }

                Action::CastTimestampStripTz => {
                    // CAST(x AS TIMESTAMP(n) WITH TIME ZONE) -> CAST(x AS TIMESTAMP) for Hive/Spark/BigQuery
                    let c = if let Expression::Cast(c) = e {
                        *c
                    } else {
                        unreachable!("action only triggered for Cast expressions")
                    };
                    Ok(Expression::Cast(Box::new(Cast {
                        to: DataType::Timestamp {
                            precision: None,
                            timezone: false,
                        },
                        ..c
                    })))
                }

                Action::CastTimestamptzToFunc => {
                    // CAST(x AS TIMESTAMPTZ) -> TIMESTAMP(x) function for MySQL/StarRocks
                    let c = if let Expression::Cast(c) = e {
                        *c
                    } else {
                        unreachable!("action only triggered for Cast expressions")
                    };
                    Ok(Expression::Function(Box::new(Function::new(
                        "TIMESTAMP".to_string(),
                        vec![c.this],
                    ))))
                }

                Action::ToDateToCast => {
                    // Convert TO_DATE(x) -> CAST(x AS DATE) for DuckDB
                    if let Expression::Function(f) = e {
                        let arg = f.args.into_iter().next().unwrap();
                        Ok(Expression::Cast(Box::new(Cast {
                            this: arg,
                            to: DataType::Date,
                            double_colon_syntax: false,
                            trailing_comments: vec![],
                            format: None,
                            default: None,
                        })))
                    } else {
                        Ok(e)
                    }
                }
                Action::DateTruncWrapCast => {
                    // Handle both Expression::DateTrunc/TimestampTrunc and
                    // Expression::Function("DATE_TRUNC", [unit, expr])
                    match e {
                        Expression::DateTrunc(d) | Expression::TimestampTrunc(d) => {
                            let input_type = match &d.this {
                                Expression::Cast(c) => Some(c.to.clone()),
                                _ => None,
                            };
                            if let Some(cast_type) = input_type {
                                let is_time = matches!(cast_type, DataType::Time { .. });
                                if is_time {
                                    let date_expr = Expression::Cast(Box::new(Cast {
                                        this: Expression::Literal(
                                            crate::expressions::Literal::String(
                                                "1970-01-01".to_string(),
                                            ),
                                        ),
                                        to: DataType::Date,
                                        double_colon_syntax: false,
                                        trailing_comments: vec![],
                                        format: None,
                                        default: None,
                                    }));
                                    let add_expr =
                                        Expression::Add(Box::new(BinaryOp::new(date_expr, d.this)));
                                    let inner = Expression::DateTrunc(Box::new(DateTruncFunc {
                                        this: add_expr,
                                        unit: d.unit,
                                    }));
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this: inner,
                                        to: cast_type,
                                        double_colon_syntax: false,
                                        trailing_comments: vec![],
                                        format: None,
                                        default: None,
                                    })))
                                } else {
                                    let inner = Expression::DateTrunc(Box::new(*d));
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this: inner,
                                        to: cast_type,
                                        double_colon_syntax: false,
                                        trailing_comments: vec![],
                                        format: None,
                                        default: None,
                                    })))
                                }
                            } else {
                                Ok(Expression::DateTrunc(d))
                            }
                        }
                        Expression::Function(f) if f.args.len() == 2 => {
                            // Function-based DATE_TRUNC(unit, expr)
                            let input_type = match &f.args[1] {
                                Expression::Cast(c) => Some(c.to.clone()),
                                _ => None,
                            };
                            if let Some(cast_type) = input_type {
                                let is_time = matches!(cast_type, DataType::Time { .. });
                                if is_time {
                                    let date_expr = Expression::Cast(Box::new(Cast {
                                        this: Expression::Literal(
                                            crate::expressions::Literal::String(
                                                "1970-01-01".to_string(),
                                            ),
                                        ),
                                        to: DataType::Date,
                                        double_colon_syntax: false,
                                        trailing_comments: vec![],
                                        format: None,
                                        default: None,
                                    }));
                                    let mut args = f.args;
                                    let unit_arg = args.remove(0);
                                    let time_expr = args.remove(0);
                                    let add_expr = Expression::Add(Box::new(BinaryOp::new(
                                        date_expr, time_expr,
                                    )));
                                    let inner = Expression::Function(Box::new(Function::new(
                                        "DATE_TRUNC".to_string(),
                                        vec![unit_arg, add_expr],
                                    )));
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this: inner,
                                        to: cast_type,
                                        double_colon_syntax: false,
                                        trailing_comments: vec![],
                                        format: None,
                                        default: None,
                                    })))
                                } else {
                                    // Wrap the function in CAST
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this: Expression::Function(f),
                                        to: cast_type,
                                        double_colon_syntax: false,
                                        trailing_comments: vec![],
                                        format: None,
                                        default: None,
                                    })))
                                }
                            } else {
                                Ok(Expression::Function(f))
                            }
                        }
                        other => Ok(other),
                    }
                }

                Action::RegexpReplaceSnowflakeToDuckDB => {
                    // Snowflake REGEXP_REPLACE(s, p, r, position) -> REGEXP_REPLACE(s, p, r, 'g')
                    if let Expression::Function(f) = e {
                        let mut args = f.args;
                        let subject = args.remove(0);
                        let pattern = args.remove(0);
                        let replacement = args.remove(0);
                        Ok(Expression::Function(Box::new(Function::new(
                            "REGEXP_REPLACE".to_string(),
                            vec![
                                subject,
                                pattern,
                                replacement,
                                Expression::Literal(crate::expressions::Literal::String(
                                    "g".to_string(),
                                )),
                            ],
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::SetToVariable => {
                    // For DuckDB: SET a = 1 -> SET VARIABLE a = 1
                    if let Expression::SetStatement(mut s) = e {
                        for item in &mut s.items {
                            if item.kind.is_none() {
                                // Check if name already has VARIABLE prefix (from DuckDB source parsing)
                                let already_variable = match &item.name {
                                    Expression::Identifier(id) => id.name.starts_with("VARIABLE "),
                                    _ => false,
                                };
                                if already_variable {
                                    // Extract the actual name and set kind
                                    if let Expression::Identifier(ref mut id) = item.name {
                                        let actual_name = id.name["VARIABLE ".len()..].to_string();
                                        id.name = actual_name;
                                    }
                                }
                                item.kind = Some("VARIABLE".to_string());
                            }
                        }
                        Ok(Expression::SetStatement(s))
                    } else {
                        Ok(e)
                    }
                }

                Action::ConvertTimezoneToExpr => {
                    // Convert Function("CONVERT_TIMEZONE", args) to Expression::ConvertTimezone
                    // This prevents Redshift's transform_expr from expanding 2-arg to 3-arg with 'UTC'
                    if let Expression::Function(f) = e {
                        if f.args.len() == 2 {
                            let mut args = f.args;
                            let target_tz = args.remove(0);
                            let timestamp = args.remove(0);
                            Ok(Expression::ConvertTimezone(Box::new(ConvertTimezone {
                                source_tz: None,
                                target_tz: Some(Box::new(target_tz)),
                                timestamp: Some(Box::new(timestamp)),
                                options: vec![],
                            })))
                        } else if f.args.len() == 3 {
                            let mut args = f.args;
                            let source_tz = args.remove(0);
                            let target_tz = args.remove(0);
                            let timestamp = args.remove(0);
                            Ok(Expression::ConvertTimezone(Box::new(ConvertTimezone {
                                source_tz: Some(Box::new(source_tz)),
                                target_tz: Some(Box::new(target_tz)),
                                timestamp: Some(Box::new(timestamp)),
                                options: vec![],
                            })))
                        } else {
                            Ok(Expression::Function(f))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::BigQueryCastType => {
                    // Convert BigQuery types to standard SQL types
                    if let Expression::DataType(dt) = e {
                        match dt {
                            DataType::Custom { ref name } if name.eq_ignore_ascii_case("INT64") => {
                                Ok(Expression::DataType(DataType::BigInt { length: None }))
                            }
                            DataType::Custom { ref name }
                                if name.eq_ignore_ascii_case("FLOAT64") =>
                            {
                                Ok(Expression::DataType(DataType::Double {
                                    precision: None,
                                    scale: None,
                                }))
                            }
                            DataType::Custom { ref name } if name.eq_ignore_ascii_case("BOOL") => {
                                Ok(Expression::DataType(DataType::Boolean))
                            }
                            DataType::Custom { ref name } if name.eq_ignore_ascii_case("BYTES") => {
                                Ok(Expression::DataType(DataType::VarBinary { length: None }))
                            }
                            DataType::Custom { ref name }
                                if name.eq_ignore_ascii_case("NUMERIC") =>
                            {
                                // For DuckDB target, use Custom("DECIMAL") to avoid DuckDB's
                                // default precision (18, 3) being added to bare DECIMAL
                                if matches!(target, DialectType::DuckDB) {
                                    Ok(Expression::DataType(DataType::Custom {
                                        name: "DECIMAL".to_string(),
                                    }))
                                } else {
                                    Ok(Expression::DataType(DataType::Decimal {
                                        precision: None,
                                        scale: None,
                                    }))
                                }
                            }
                            DataType::Custom { ref name }
                                if name.eq_ignore_ascii_case("STRING") =>
                            {
                                Ok(Expression::DataType(DataType::String { length: None }))
                            }
                            DataType::Custom { ref name }
                                if name.eq_ignore_ascii_case("DATETIME") =>
                            {
                                Ok(Expression::DataType(DataType::Timestamp {
                                    precision: None,
                                    timezone: false,
                                }))
                            }
                            _ => Ok(Expression::DataType(dt)),
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::BigQuerySafeDivide => {
                    // Convert SafeDivide expression to IF/CASE form for most targets
                    if let Expression::SafeDivide(sd) = e {
                        let x = *sd.this;
                        let y = *sd.expression;
                        // Wrap x and y in parens if they're complex expressions
                        let y_ref = match &y {
                            Expression::Column(_)
                            | Expression::Literal(_)
                            | Expression::Identifier(_) => y.clone(),
                            _ => Expression::Paren(Box::new(Paren {
                                this: y.clone(),
                                trailing_comments: vec![],
                            })),
                        };
                        let x_ref = match &x {
                            Expression::Column(_)
                            | Expression::Literal(_)
                            | Expression::Identifier(_) => x.clone(),
                            _ => Expression::Paren(Box::new(Paren {
                                this: x.clone(),
                                trailing_comments: vec![],
                            })),
                        };
                        let condition = Expression::Neq(Box::new(BinaryOp::new(
                            y_ref.clone(),
                            Expression::number(0),
                        )));
                        let div_expr = Expression::Div(Box::new(BinaryOp::new(x_ref, y_ref)));

                        if matches!(target, DialectType::Presto | DialectType::Trino) {
                            // Presto/Trino: IF(y <> 0, CAST(x AS DOUBLE) / y, NULL)
                            let cast_x = Expression::Cast(Box::new(Cast {
                                this: match &x {
                                    Expression::Column(_)
                                    | Expression::Literal(_)
                                    | Expression::Identifier(_) => x,
                                    _ => Expression::Paren(Box::new(Paren {
                                        this: x,
                                        trailing_comments: vec![],
                                    })),
                                },
                                to: DataType::Double {
                                    precision: None,
                                    scale: None,
                                },
                                trailing_comments: vec![],
                                double_colon_syntax: false,
                                format: None,
                                default: None,
                            }));
                            let cast_div = Expression::Div(Box::new(BinaryOp::new(
                                cast_x,
                                match &y {
                                    Expression::Column(_)
                                    | Expression::Literal(_)
                                    | Expression::Identifier(_) => y,
                                    _ => Expression::Paren(Box::new(Paren {
                                        this: y,
                                        trailing_comments: vec![],
                                    })),
                                },
                            )));
                            Ok(Expression::IfFunc(Box::new(crate::expressions::IfFunc {
                                condition,
                                true_value: cast_div,
                                false_value: Some(Expression::Null(Null)),
                                original_name: None,
                            })))
                        } else if matches!(target, DialectType::PostgreSQL) {
                            // PostgreSQL: CASE WHEN y <> 0 THEN CAST(x AS DOUBLE PRECISION) / y ELSE NULL END
                            let cast_x = Expression::Cast(Box::new(Cast {
                                this: match &x {
                                    Expression::Column(_)
                                    | Expression::Literal(_)
                                    | Expression::Identifier(_) => x,
                                    _ => Expression::Paren(Box::new(Paren {
                                        this: x,
                                        trailing_comments: vec![],
                                    })),
                                },
                                to: DataType::Custom {
                                    name: "DOUBLE PRECISION".to_string(),
                                },
                                trailing_comments: vec![],
                                double_colon_syntax: false,
                                format: None,
                                default: None,
                            }));
                            let y_paren = match &y {
                                Expression::Column(_)
                                | Expression::Literal(_)
                                | Expression::Identifier(_) => y,
                                _ => Expression::Paren(Box::new(Paren {
                                    this: y,
                                    trailing_comments: vec![],
                                })),
                            };
                            let cast_div =
                                Expression::Div(Box::new(BinaryOp::new(cast_x, y_paren)));
                            Ok(Expression::Case(Box::new(Case {
                                operand: None,
                                whens: vec![(condition, cast_div)],
                                else_: Some(Expression::Null(Null)),
                                comments: Vec::new(),
                            })))
                        } else if matches!(target, DialectType::DuckDB) {
                            // DuckDB: CASE WHEN y <> 0 THEN x / y ELSE NULL END
                            Ok(Expression::Case(Box::new(Case {
                                operand: None,
                                whens: vec![(condition, div_expr)],
                                else_: Some(Expression::Null(Null)),
                                comments: Vec::new(),
                            })))
                        } else if matches!(target, DialectType::Snowflake) {
                            // Snowflake: IFF(y <> 0, x / y, NULL)
                            Ok(Expression::IfFunc(Box::new(crate::expressions::IfFunc {
                                condition,
                                true_value: div_expr,
                                false_value: Some(Expression::Null(Null)),
                                original_name: Some("IFF".to_string()),
                            })))
                        } else {
                            // All others: IF(y <> 0, x / y, NULL)
                            Ok(Expression::IfFunc(Box::new(crate::expressions::IfFunc {
                                condition,
                                true_value: div_expr,
                                false_value: Some(Expression::Null(Null)),
                                original_name: None,
                            })))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::BigQueryLastDayStripUnit => {
                    if let Expression::LastDay(mut ld) = e {
                        ld.unit = None; // Strip the unit (MONTH is default)
                        match target {
                            DialectType::PostgreSQL => {
                                // LAST_DAY(date) -> CAST(DATE_TRUNC('MONTH', date) + INTERVAL '1 MONTH' - INTERVAL '1 DAY' AS DATE)
                                let date_trunc = Expression::Function(Box::new(Function::new(
                                    "DATE_TRUNC".to_string(),
                                    vec![
                                        Expression::Literal(crate::expressions::Literal::String(
                                            "MONTH".to_string(),
                                        )),
                                        ld.this.clone(),
                                    ],
                                )));
                                let plus_month =
                                    Expression::Add(Box::new(crate::expressions::BinaryOp::new(
                                        date_trunc,
                                        Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(Expression::Literal(
                                                    crate::expressions::Literal::String(
                                                        "1 MONTH".to_string(),
                                                    ),
                                                )),
                                                unit: None,
                                            },
                                        )),
                                    )));
                                let minus_day =
                                    Expression::Sub(Box::new(crate::expressions::BinaryOp::new(
                                        plus_month,
                                        Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(Expression::Literal(
                                                    crate::expressions::Literal::String(
                                                        "1 DAY".to_string(),
                                                    ),
                                                )),
                                                unit: None,
                                            },
                                        )),
                                    )));
                                Ok(Expression::Cast(Box::new(Cast {
                                    this: minus_day,
                                    to: DataType::Date,
                                    trailing_comments: vec![],
                                    double_colon_syntax: false,
                                    format: None,
                                    default: None,
                                })))
                            }
                            DialectType::Presto => {
                                // LAST_DAY(date) -> LAST_DAY_OF_MONTH(date)
                                Ok(Expression::Function(Box::new(Function::new(
                                    "LAST_DAY_OF_MONTH".to_string(),
                                    vec![ld.this],
                                ))))
                            }
                            DialectType::ClickHouse => {
                                // ClickHouse LAST_DAY(CAST(x AS Nullable(DATE)))
                                // Need to wrap the DATE type in Nullable
                                let nullable_date = match ld.this {
                                    Expression::Cast(mut c) => {
                                        c.to = DataType::Nullable {
                                            inner: Box::new(DataType::Date),
                                        };
                                        Expression::Cast(c)
                                    }
                                    other => other,
                                };
                                ld.this = nullable_date;
                                Ok(Expression::LastDay(ld))
                            }
                            _ => Ok(Expression::LastDay(ld)),
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::BigQueryCastFormat => {
                    // CAST(x AS DATE FORMAT 'fmt') -> PARSE_DATE('%m/%d/%Y', x) for BigQuery
                    // CAST(x AS TIMESTAMP FORMAT 'fmt') -> PARSE_TIMESTAMP(...) for BigQuery
                    // SAFE_CAST(x AS DATE FORMAT 'fmt') -> CAST(TRY_STRPTIME(x, ...) AS DATE) for DuckDB
                    let (this, to, format_expr, is_safe) = match e {
                        Expression::Cast(ref c) if c.format.is_some() => (
                            c.this.clone(),
                            c.to.clone(),
                            c.format.as_ref().unwrap().as_ref().clone(),
                            false,
                        ),
                        Expression::SafeCast(ref c) if c.format.is_some() => (
                            c.this.clone(),
                            c.to.clone(),
                            c.format.as_ref().unwrap().as_ref().clone(),
                            true,
                        ),
                        _ => return Ok(e),
                    };
                    // For CAST(x AS STRING FORMAT ...) when target is BigQuery, keep as-is
                    if matches!(target, DialectType::BigQuery) {
                        match &to {
                            DataType::String { .. } | DataType::VarChar { .. } | DataType::Text => {
                                // CAST(x AS STRING FORMAT 'fmt') stays as CAST expression for BigQuery
                                return Ok(e);
                            }
                            _ => {}
                        }
                    }
                    // Extract timezone from format if AT TIME ZONE is present
                    let (actual_format_expr, timezone) = match &format_expr {
                        Expression::AtTimeZone(ref atz) => {
                            (atz.this.clone(), Some(atz.zone.clone()))
                        }
                        _ => (format_expr.clone(), None),
                    };
                    let strftime_fmt = Self::bq_cast_format_to_strftime(&actual_format_expr);
                    match target {
                        DialectType::BigQuery => {
                            // CAST(x AS DATE FORMAT 'fmt') -> PARSE_DATE(strftime_fmt, x)
                            // CAST(x AS TIMESTAMP FORMAT 'fmt' AT TIME ZONE 'tz') -> PARSE_TIMESTAMP(strftime_fmt, x, tz)
                            let func_name = match &to {
                                DataType::Date => "PARSE_DATE",
                                DataType::Timestamp { .. } => "PARSE_TIMESTAMP",
                                DataType::Time { .. } => "PARSE_TIMESTAMP",
                                _ => "PARSE_TIMESTAMP",
                            };
                            let mut func_args = vec![strftime_fmt, this];
                            if let Some(tz) = timezone {
                                func_args.push(tz);
                            }
                            Ok(Expression::Function(Box::new(Function::new(
                                func_name.to_string(),
                                func_args,
                            ))))
                        }
                        DialectType::DuckDB => {
                            // SAFE_CAST(x AS DATE FORMAT 'fmt') -> CAST(TRY_STRPTIME(x, fmt) AS DATE)
                            // CAST(x AS DATE FORMAT 'fmt') -> CAST(STRPTIME(x, fmt) AS DATE)
                            let duck_fmt = Self::bq_format_to_duckdb(&strftime_fmt);
                            let parse_fn_name = if is_safe { "TRY_STRPTIME" } else { "STRPTIME" };
                            let parse_call = Expression::Function(Box::new(Function::new(
                                parse_fn_name.to_string(),
                                vec![this, duck_fmt],
                            )));
                            Ok(Expression::Cast(Box::new(Cast {
                                this: parse_call,
                                to,
                                trailing_comments: vec![],
                                double_colon_syntax: false,
                                format: None,
                                default: None,
                            })))
                        }
                        _ => Ok(e),
                    }
                }

                Action::BigQueryFunctionNormalize => {
                    Self::normalize_bigquery_function(e, source, target)
                }

                Action::BigQueryToHexBare => {
                    // Not used anymore - handled directly in normalize_bigquery_function
                    Ok(e)
                }

                Action::BigQueryToHexLower => {
                    if let Expression::Lower(uf) = e {
                        match uf.this {
                            // BQ->BQ: LOWER(TO_HEX(x)) -> TO_HEX(x)
                            Expression::Function(f)
                                if matches!(target, DialectType::BigQuery)
                                    && f.name == "TO_HEX" =>
                            {
                                Ok(Expression::Function(f))
                            }
                            // LOWER(LOWER(HEX/TO_HEX(x))) patterns
                            Expression::Lower(inner_uf) => {
                                if matches!(target, DialectType::BigQuery) {
                                    // BQ->BQ: extract TO_HEX
                                    if let Expression::Function(f) = inner_uf.this {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "TO_HEX".to_string(),
                                            f.args,
                                        ))))
                                    } else {
                                        Ok(Expression::Lower(inner_uf))
                                    }
                                } else {
                                    // Flatten: LOWER(LOWER(x)) -> LOWER(x)
                                    Ok(Expression::Lower(inner_uf))
                                }
                            }
                            other => {
                                Ok(Expression::Lower(Box::new(crate::expressions::UnaryFunc {
                                    this: other,
                                    original_name: None,
                                })))
                            }
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::BigQueryToHexUpper => {
                    // UPPER(LOWER(HEX(x))) -> HEX(x) (UPPER cancels LOWER, HEX is already uppercase)
                    // UPPER(LOWER(TO_HEX(x))) -> TO_HEX(x) for Presto/Trino
                    if let Expression::Upper(uf) = e {
                        if let Expression::Lower(inner_uf) = uf.this {
                            // For BQ->BQ: UPPER(TO_HEX(x)) should stay as UPPER(TO_HEX(x))
                            if matches!(target, DialectType::BigQuery) {
                                // Restore TO_HEX name in inner function
                                if let Expression::Function(f) = inner_uf.this {
                                    let restored = Expression::Function(Box::new(Function::new(
                                        "TO_HEX".to_string(),
                                        f.args,
                                    )));
                                    Ok(Expression::Upper(Box::new(
                                        crate::expressions::UnaryFunc::new(restored),
                                    )))
                                } else {
                                    Ok(Expression::Upper(inner_uf))
                                }
                            } else {
                                // Extract the inner HEX/TO_HEX function (UPPER(LOWER(x)) = x when HEX is uppercase)
                                Ok(inner_uf.this)
                            }
                        } else {
                            Ok(Expression::Upper(uf))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::BigQueryAnyValueHaving => {
                    // ANY_VALUE(x HAVING MAX y) -> ARG_MAX_NULL(x, y)
                    // ANY_VALUE(x HAVING MIN y) -> ARG_MIN_NULL(x, y)
                    if let Expression::AnyValue(agg) = e {
                        if let Some((having_expr, is_max)) = agg.having_max {
                            let func_name = if is_max {
                                "ARG_MAX_NULL"
                            } else {
                                "ARG_MIN_NULL"
                            };
                            Ok(Expression::Function(Box::new(Function::new(
                                func_name.to_string(),
                                vec![agg.this, *having_expr],
                            ))))
                        } else {
                            Ok(Expression::AnyValue(agg))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::BigQueryApproxQuantiles => {
                    // APPROX_QUANTILES(x, n) -> APPROX_QUANTILE(x, [0, 1/n, 2/n, ..., 1])
                    // APPROX_QUANTILES(DISTINCT x, n) -> APPROX_QUANTILE(DISTINCT x, [0, 1/n, ..., 1])
                    if let Expression::AggregateFunction(agg) = e {
                        if agg.args.len() >= 2 {
                            let x_expr = agg.args[0].clone();
                            let n_expr = &agg.args[1];

                            // Extract the numeric value from n_expr
                            let n = match n_expr {
                                Expression::Literal(crate::expressions::Literal::Number(s)) => {
                                    s.parse::<usize>().unwrap_or(2)
                                }
                                _ => 2,
                            };

                            // Generate quantile array: [0, 1/n, 2/n, ..., 1]
                            let mut quantiles = Vec::new();
                            for i in 0..=n {
                                let q = i as f64 / n as f64;
                                // Format nicely: 0 -> 0, 0.25 -> 0.25, 1 -> 1
                                if q == 0.0 {
                                    quantiles.push(Expression::number(0));
                                } else if q == 1.0 {
                                    quantiles.push(Expression::number(1));
                                } else {
                                    quantiles.push(Expression::Literal(
                                        crate::expressions::Literal::Number(format!("{}", q)),
                                    ));
                                }
                            }

                            let array_expr =
                                Expression::Array(Box::new(crate::expressions::Array {
                                    expressions: quantiles,
                                }));

                            // Preserve DISTINCT modifier
                            let mut new_func = Function::new(
                                "APPROX_QUANTILE".to_string(),
                                vec![x_expr, array_expr],
                            );
                            new_func.distinct = agg.distinct;
                            Ok(Expression::Function(Box::new(new_func)))
                        } else {
                            Ok(Expression::AggregateFunction(agg))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::GenericFunctionNormalize => {
                    // Helper closure to convert ARBITRARY to target-specific function
                    fn convert_arbitrary(arg: Expression, target: DialectType) -> Expression {
                        let name = match target {
                            DialectType::ClickHouse => "any",
                            DialectType::TSQL | DialectType::SQLite => "MAX",
                            DialectType::Hive => "FIRST",
                            DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                "ARBITRARY"
                            }
                            _ => "ANY_VALUE",
                        };
                        Expression::Function(Box::new(Function::new(name.to_string(), vec![arg])))
                    }

                    if let Expression::Function(f) = e {
                        let name = f.name.to_uppercase();
                        match name.as_str() {
                            "ARBITRARY" if f.args.len() == 1 => {
                                let arg = f.args.into_iter().next().unwrap();
                                Ok(convert_arbitrary(arg, target))
                            }
                            "TO_NUMBER" if f.args.len() == 1 => {
                                let arg = f.args.into_iter().next().unwrap();
                                match target {
                                    DialectType::Oracle | DialectType::Snowflake => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "TO_NUMBER".to_string(),
                                            vec![arg],
                                        ))))
                                    }
                                    _ => Ok(Expression::Cast(Box::new(crate::expressions::Cast {
                                        this: arg,
                                        to: crate::expressions::DataType::Double {
                                            precision: None,
                                            scale: None,
                                        },
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    }))),
                                }
                            }
                            "AGGREGATE" if f.args.len() >= 3 => match target {
                                DialectType::DuckDB
                                | DialectType::Hive
                                | DialectType::Presto
                                | DialectType::Trino => Ok(Expression::Function(Box::new(
                                    Function::new("REDUCE".to_string(), f.args),
                                ))),
                                _ => Ok(Expression::Function(f)),
                            },
                            // REGEXP_MATCHES(x, y) -> RegexpLike for most targets, keep for DuckDB
                            "REGEXP_MATCHES" if f.args.len() >= 2 => {
                                if matches!(target, DialectType::DuckDB) {
                                    Ok(Expression::Function(f))
                                } else {
                                    let mut args = f.args;
                                    let this = args.remove(0);
                                    let pattern = args.remove(0);
                                    let flags = if args.is_empty() {
                                        None
                                    } else {
                                        Some(args.remove(0))
                                    };
                                    Ok(Expression::RegexpLike(Box::new(
                                        crate::expressions::RegexpFunc {
                                            this,
                                            pattern,
                                            flags,
                                        },
                                    )))
                                }
                            }
                            // REGEXP_FULL_MATCH (Hive REGEXP) -> RegexpLike
                            "REGEXP_FULL_MATCH" if f.args.len() >= 2 => {
                                if matches!(target, DialectType::DuckDB) {
                                    Ok(Expression::Function(f))
                                } else {
                                    let mut args = f.args;
                                    let this = args.remove(0);
                                    let pattern = args.remove(0);
                                    let flags = if args.is_empty() {
                                        None
                                    } else {
                                        Some(args.remove(0))
                                    };
                                    Ok(Expression::RegexpLike(Box::new(
                                        crate::expressions::RegexpFunc {
                                            this,
                                            pattern,
                                            flags,
                                        },
                                    )))
                                }
                            }
                            // STRUCT_EXTRACT(x, 'field') -> x.field (StructExtract expression)
                            "STRUCT_EXTRACT" if f.args.len() == 2 => {
                                let mut args = f.args;
                                let this = args.remove(0);
                                let field_expr = args.remove(0);
                                // Extract string literal to get field name
                                let field_name = match &field_expr {
                                    Expression::Literal(crate::expressions::Literal::String(s)) => {
                                        s.clone()
                                    }
                                    Expression::Identifier(id) => id.name.clone(),
                                    _ => {
                                        return Ok(Expression::Function(Box::new(Function::new(
                                            "STRUCT_EXTRACT".to_string(),
                                            vec![this, field_expr],
                                        ))))
                                    }
                                };
                                Ok(Expression::StructExtract(Box::new(
                                    crate::expressions::StructExtractFunc {
                                        this,
                                        field: crate::expressions::Identifier::new(field_name),
                                    },
                                )))
                            }
                            // LIST_FILTER([4,5,6], x -> x > 4) -> FILTER(ARRAY(4,5,6), x -> x > 4)
                            "LIST_FILTER" if f.args.len() == 2 => {
                                let name = match target {
                                    DialectType::DuckDB => "LIST_FILTER",
                                    _ => "FILTER",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // LIST_TRANSFORM(x, y -> y + 1) -> TRANSFORM(x, y -> y + 1)
                            "LIST_TRANSFORM" if f.args.len() == 2 => {
                                let name = match target {
                                    DialectType::DuckDB => "LIST_TRANSFORM",
                                    _ => "TRANSFORM",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // LIST_SORT(x) -> SORT_ARRAY(x) / ARRAY_SORT(x)
                            "LIST_SORT" if f.args.len() >= 1 => {
                                let name = match target {
                                    DialectType::DuckDB
                                    | DialectType::Presto
                                    | DialectType::Trino => "ARRAY_SORT",
                                    _ => "SORT_ARRAY",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // LIST_REVERSE_SORT(x) -> SORT_ARRAY(x, FALSE) for Spark/Hive, ARRAY_SORT(x, lambda) for Presto
                            "LIST_REVERSE_SORT" if f.args.len() >= 1 => {
                                match target {
                                    DialectType::DuckDB => Ok(Expression::Function(Box::new(
                                        Function::new("ARRAY_REVERSE_SORT".to_string(), f.args),
                                    ))),
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => {
                                        let mut args = f.args;
                                        args.push(Expression::Identifier(
                                            crate::expressions::Identifier::new("FALSE"),
                                        ));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "SORT_ARRAY".to_string(),
                                            args,
                                        ))))
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        // ARRAY_SORT(x, (a, b) -> CASE WHEN a < b THEN 1 WHEN a > b THEN -1 ELSE 0 END)
                                        let arr = f.args.into_iter().next().unwrap();
                                        let lambda = Expression::Lambda(Box::new(crate::expressions::LambdaExpr {
                                            parameters: vec![
                                                crate::expressions::Identifier::new("a"),
                                                crate::expressions::Identifier::new("b"),
                                            ],
                                            body: Expression::Case(Box::new(Case {
                                                operand: None,
                                                whens: vec![
                                                    (
                                                        Expression::Lt(Box::new(BinaryOp::new(
                                                            Expression::Identifier(crate::expressions::Identifier::new("a")),
                                                            Expression::Identifier(crate::expressions::Identifier::new("b")),
                                                        ))),
                                                        Expression::number(1),
                                                    ),
                                                    (
                                                        Expression::Gt(Box::new(BinaryOp::new(
                                                            Expression::Identifier(crate::expressions::Identifier::new("a")),
                                                            Expression::Identifier(crate::expressions::Identifier::new("b")),
                                                        ))),
                                                        Expression::Literal(Literal::Number("-1".to_string())),
                                                    ),
                                                ],
                                                else_: Some(Expression::number(0)),
                                                comments: Vec::new(),
                                            })),
                                            colon: false,
                                            parameter_types: Vec::new(),
                                        }));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "ARRAY_SORT".to_string(),
                                            vec![arr, lambda],
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "LIST_REVERSE_SORT".to_string(),
                                        f.args,
                                    )))),
                                }
                            }
                            // SPLIT_TO_ARRAY(x) with 1 arg -> add default ',' separator and rename
                            "SPLIT_TO_ARRAY" if f.args.len() == 1 => {
                                let mut args = f.args;
                                args.push(Expression::string(","));
                                let name = match target {
                                    DialectType::DuckDB => "STR_SPLIT",
                                    DialectType::Presto | DialectType::Trino => "SPLIT",
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => "SPLIT",
                                    DialectType::PostgreSQL => "STRING_TO_ARRAY",
                                    DialectType::Redshift => "SPLIT_TO_ARRAY",
                                    _ => "SPLIT",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    args,
                                ))))
                            }
                            // SPLIT_TO_ARRAY(x, sep) with 2 args -> rename based on target
                            "SPLIT_TO_ARRAY" if f.args.len() == 2 => {
                                let name = match target {
                                    DialectType::DuckDB => "STR_SPLIT",
                                    DialectType::Presto | DialectType::Trino => "SPLIT",
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => "SPLIT",
                                    DialectType::PostgreSQL => "STRING_TO_ARRAY",
                                    DialectType::Redshift => "SPLIT_TO_ARRAY",
                                    _ => "SPLIT",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // STRING_TO_ARRAY/STR_SPLIT -> target-specific split function
                            "STRING_TO_ARRAY" | "STR_SPLIT" if f.args.len() >= 2 => {
                                let name = match target {
                                    DialectType::DuckDB => "STR_SPLIT",
                                    DialectType::Presto | DialectType::Trino => "SPLIT",
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => "SPLIT",
                                    DialectType::Doris | DialectType::StarRocks => {
                                        "SPLIT_BY_STRING"
                                    }
                                    DialectType::PostgreSQL | DialectType::Redshift => {
                                        "STRING_TO_ARRAY"
                                    }
                                    _ => "SPLIT",
                                };
                                // For Spark/Hive, SPLIT uses regex - need to escape literal with \Q...\E
                                if matches!(
                                    target,
                                    DialectType::Spark
                                        | DialectType::Databricks
                                        | DialectType::Hive
                                ) {
                                    let mut args = f.args;
                                    let x = args.remove(0);
                                    let sep = args.remove(0);
                                    // Wrap separator in CONCAT('\\Q', sep, '\\E')
                                    let escaped_sep =
                                        Expression::Function(Box::new(Function::new(
                                            "CONCAT".to_string(),
                                            vec![
                                                Expression::string("\\Q"),
                                                sep,
                                                Expression::string("\\E"),
                                            ],
                                        )));
                                    Ok(Expression::Function(Box::new(Function::new(
                                        name.to_string(),
                                        vec![x, escaped_sep],
                                    ))))
                                } else {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        name.to_string(),
                                        f.args,
                                    ))))
                                }
                            }
                            // STR_SPLIT_REGEX(x, 'a') / REGEXP_SPLIT(x, 'a') -> target-specific regex split
                            "STR_SPLIT_REGEX" | "REGEXP_SPLIT" if f.args.len() == 2 => {
                                let name = match target {
                                    DialectType::DuckDB => "STR_SPLIT_REGEX",
                                    DialectType::Presto | DialectType::Trino => "REGEXP_SPLIT",
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => "SPLIT",
                                    _ => "REGEXP_SPLIT",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // SPLIT(x, sep) from Presto/StarRocks/Doris -> target-specific split with regex escaping for Hive/Spark
                            "SPLIT"
                                if f.args.len() == 2
                                    && matches!(
                                        source,
                                        DialectType::Presto
                                            | DialectType::Trino
                                            | DialectType::Athena
                                            | DialectType::StarRocks
                                            | DialectType::Doris
                                    )
                                    && matches!(
                                        target,
                                        DialectType::Spark
                                            | DialectType::Databricks
                                            | DialectType::Hive
                                    ) =>
                            {
                                // Presto/StarRocks SPLIT is literal, Hive/Spark SPLIT is regex
                                let mut args = f.args;
                                let x = args.remove(0);
                                let sep = args.remove(0);
                                let escaped_sep = Expression::Function(Box::new(Function::new(
                                    "CONCAT".to_string(),
                                    vec![Expression::string("\\Q"), sep, Expression::string("\\E")],
                                )));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "SPLIT".to_string(),
                                    vec![x, escaped_sep],
                                ))))
                            }
                            // SUBSTRINGINDEX -> SUBSTRING_INDEX (ClickHouse camelCase to standard)
                            // For ClickHouse target, preserve original name to maintain camelCase
                            "SUBSTRINGINDEX" => {
                                let name = if matches!(target, DialectType::ClickHouse) {
                                    f.name.clone()
                                } else {
                                    "SUBSTRING_INDEX".to_string()
                                };
                                Ok(Expression::Function(Box::new(Function::new(name, f.args))))
                            }
                            // ARRAY_LENGTH/SIZE/CARDINALITY -> target-specific array length function
                            "ARRAY_LENGTH" | "SIZE" | "CARDINALITY" => {
                                // Get the array argument (first arg, drop dimension args)
                                let mut args = f.args;
                                let arr = if args.is_empty() {
                                    return Ok(Expression::Function(Box::new(Function::new(
                                        name.to_string(),
                                        args,
                                    ))));
                                } else {
                                    args.remove(0)
                                };
                                let name =
                                    match target {
                                        DialectType::Spark
                                        | DialectType::Databricks
                                        | DialectType::Hive => "SIZE",
                                        DialectType::Presto | DialectType::Trino => "CARDINALITY",
                                        DialectType::BigQuery => "ARRAY_LENGTH",
                                        DialectType::DuckDB => {
                                            // DuckDB: use ARRAY_LENGTH with all args
                                            let mut all_args = vec![arr];
                                            all_args.extend(args);
                                            return Ok(Expression::Function(Box::new(
                                                Function::new("ARRAY_LENGTH".to_string(), all_args),
                                            )));
                                        }
                                        DialectType::PostgreSQL | DialectType::Redshift => {
                                            // Keep ARRAY_LENGTH with dimension arg
                                            let mut all_args = vec![arr];
                                            all_args.extend(args);
                                            return Ok(Expression::Function(Box::new(
                                                Function::new("ARRAY_LENGTH".to_string(), all_args),
                                            )));
                                        }
                                        DialectType::ClickHouse => "LENGTH",
                                        _ => "ARRAY_LENGTH",
                                    };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    vec![arr],
                                ))))
                            }
                            // UNICODE(x) -> target-specific codepoint function
                            "UNICODE" if f.args.len() == 1 => {
                                match target {
                                    DialectType::SQLite | DialectType::DuckDB => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "UNICODE".to_string(),
                                            f.args,
                                        ))))
                                    }
                                    DialectType::Oracle => {
                                        // ASCII(UNISTR(x))
                                        let inner = Expression::Function(Box::new(Function::new(
                                            "UNISTR".to_string(),
                                            f.args,
                                        )));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "ASCII".to_string(),
                                            vec![inner],
                                        ))))
                                    }
                                    DialectType::MySQL => {
                                        // ORD(CONVERT(x USING utf32))
                                        let arg = f.args.into_iter().next().unwrap();
                                        let convert_expr = Expression::ConvertToCharset(Box::new(
                                            crate::expressions::ConvertToCharset {
                                                this: Box::new(arg),
                                                dest: Some(Box::new(Expression::Identifier(
                                                    crate::expressions::Identifier::new("utf32"),
                                                ))),
                                                source: None,
                                            },
                                        ));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "ORD".to_string(),
                                            vec![convert_expr],
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "ASCII".to_string(),
                                        f.args,
                                    )))),
                                }
                            }
                            // XOR(a, b, ...) -> a XOR b XOR ... for MySQL, BITWISE_XOR for Presto/Trino, # for PostgreSQL, ^ for BigQuery
                            "XOR" if f.args.len() >= 2 => {
                                match target {
                                    DialectType::ClickHouse => {
                                        // ClickHouse: keep as xor() function with lowercase name
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "xor".to_string(),
                                            f.args,
                                        ))))
                                    }
                                    DialectType::Presto | DialectType::Trino => {
                                        if f.args.len() == 2 {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "BITWISE_XOR".to_string(),
                                                f.args,
                                            ))))
                                        } else {
                                            // Nest: BITWISE_XOR(BITWISE_XOR(a, b), c)
                                            let mut args = f.args;
                                            let first = args.remove(0);
                                            let second = args.remove(0);
                                            let mut result =
                                                Expression::Function(Box::new(Function::new(
                                                    "BITWISE_XOR".to_string(),
                                                    vec![first, second],
                                                )));
                                            for arg in args {
                                                result =
                                                    Expression::Function(Box::new(Function::new(
                                                        "BITWISE_XOR".to_string(),
                                                        vec![result, arg],
                                                    )));
                                            }
                                            Ok(result)
                                        }
                                    }
                                    DialectType::MySQL
                                    | DialectType::SingleStore
                                    | DialectType::Doris
                                    | DialectType::StarRocks => {
                                        // Convert XOR(a, b, c) -> Expression::Xor with expressions list
                                        let args = f.args;
                                        Ok(Expression::Xor(Box::new(crate::expressions::Xor {
                                            this: None,
                                            expression: None,
                                            expressions: args,
                                        })))
                                    }
                                    DialectType::PostgreSQL | DialectType::Redshift => {
                                        // PostgreSQL: a # b (hash operator for XOR)
                                        let mut args = f.args;
                                        let first = args.remove(0);
                                        let second = args.remove(0);
                                        let mut result = Expression::BitwiseXor(Box::new(
                                            BinaryOp::new(first, second),
                                        ));
                                        for arg in args {
                                            result = Expression::BitwiseXor(Box::new(
                                                BinaryOp::new(result, arg),
                                            ));
                                        }
                                        Ok(result)
                                    }
                                    DialectType::DuckDB => {
                                        // DuckDB: keep as XOR function (DuckDB ^ is Power, not XOR)
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "XOR".to_string(),
                                            f.args,
                                        ))))
                                    }
                                    DialectType::BigQuery => {
                                        // BigQuery: a ^ b (caret operator for XOR)
                                        let mut args = f.args;
                                        let first = args.remove(0);
                                        let second = args.remove(0);
                                        let mut result = Expression::BitwiseXor(Box::new(
                                            BinaryOp::new(first, second),
                                        ));
                                        for arg in args {
                                            result = Expression::BitwiseXor(Box::new(
                                                BinaryOp::new(result, arg),
                                            ));
                                        }
                                        Ok(result)
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "XOR".to_string(),
                                        f.args,
                                    )))),
                                }
                            }
                            // ARRAY_REVERSE_SORT(x) -> SORT_ARRAY(x, FALSE) for Spark/Hive, ARRAY_SORT(x, lambda) for Presto
                            "ARRAY_REVERSE_SORT" if f.args.len() >= 1 => {
                                match target {
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => {
                                        let mut args = f.args;
                                        args.push(Expression::Identifier(
                                            crate::expressions::Identifier::new("FALSE"),
                                        ));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "SORT_ARRAY".to_string(),
                                            args,
                                        ))))
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        // ARRAY_SORT(x, (a, b) -> CASE WHEN a < b THEN 1 WHEN a > b THEN -1 ELSE 0 END)
                                        let arr = f.args.into_iter().next().unwrap();
                                        let lambda = Expression::Lambda(Box::new(
                                            crate::expressions::LambdaExpr {
                                                parameters: vec![
                                                    Identifier::new("a"),
                                                    Identifier::new("b"),
                                                ],
                                                colon: false,
                                                parameter_types: Vec::new(),
                                                body: Expression::Case(Box::new(Case {
                                                    operand: None,
                                                    whens: vec![
                                                        (
                                                            Expression::Lt(Box::new(
                                                                BinaryOp::new(
                                                                    Expression::Identifier(
                                                                        Identifier::new("a"),
                                                                    ),
                                                                    Expression::Identifier(
                                                                        Identifier::new("b"),
                                                                    ),
                                                                ),
                                                            )),
                                                            Expression::number(1),
                                                        ),
                                                        (
                                                            Expression::Gt(Box::new(
                                                                BinaryOp::new(
                                                                    Expression::Identifier(
                                                                        Identifier::new("a"),
                                                                    ),
                                                                    Expression::Identifier(
                                                                        Identifier::new("b"),
                                                                    ),
                                                                ),
                                                            )),
                                                            Expression::Neg(Box::new(
                                                                crate::expressions::UnaryOp {
                                                                    this: Expression::number(1),
                                                                },
                                                            )),
                                                        ),
                                                    ],
                                                    else_: Some(Expression::number(0)),
                                                    comments: Vec::new(),
                                                })),
                                            },
                                        ));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "ARRAY_SORT".to_string(),
                                            vec![arr, lambda],
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "ARRAY_REVERSE_SORT".to_string(),
                                        f.args,
                                    )))),
                                }
                            }
                            // ENCODE(x) -> ENCODE(x, 'utf-8') for Spark/Hive, TO_UTF8(x) for Presto
                            "ENCODE" if f.args.len() == 1 => match target {
                                DialectType::Spark
                                | DialectType::Databricks
                                | DialectType::Hive => {
                                    let mut args = f.args;
                                    args.push(Expression::string("utf-8"));
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "ENCODE".to_string(),
                                        args,
                                    ))))
                                }
                                DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "TO_UTF8".to_string(),
                                        f.args,
                                    ))))
                                }
                                _ => Ok(Expression::Function(Box::new(Function::new(
                                    "ENCODE".to_string(),
                                    f.args,
                                )))),
                            },
                            // DECODE(x) -> DECODE(x, 'utf-8') for Spark/Hive, FROM_UTF8(x) for Presto
                            "DECODE" if f.args.len() == 1 => match target {
                                DialectType::Spark
                                | DialectType::Databricks
                                | DialectType::Hive => {
                                    let mut args = f.args;
                                    args.push(Expression::string("utf-8"));
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "DECODE".to_string(),
                                        args,
                                    ))))
                                }
                                DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "FROM_UTF8".to_string(),
                                        f.args,
                                    ))))
                                }
                                _ => Ok(Expression::Function(Box::new(Function::new(
                                    "DECODE".to_string(),
                                    f.args,
                                )))),
                            },
                            // QUANTILE(x, p) -> PERCENTILE(x, p) for Spark/Hive
                            "QUANTILE" if f.args.len() == 2 => {
                                let name = match target {
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => "PERCENTILE",
                                    DialectType::Presto | DialectType::Trino => "APPROX_PERCENTILE",
                                    DialectType::BigQuery => "PERCENTILE_CONT",
                                    _ => "QUANTILE",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // QUANTILE_CONT(x, q) -> PERCENTILE_CONT(q) WITHIN GROUP (ORDER BY x) for PostgreSQL/Snowflake
                            "QUANTILE_CONT" if f.args.len() == 2 => {
                                let mut args = f.args;
                                let column = args.remove(0);
                                let quantile = args.remove(0);
                                match target {
                                    DialectType::DuckDB => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "QUANTILE_CONT".to_string(),
                                            vec![column, quantile],
                                        ))))
                                    }
                                    DialectType::PostgreSQL
                                    | DialectType::Redshift
                                    | DialectType::Snowflake => {
                                        // PERCENTILE_CONT(q) WITHIN GROUP (ORDER BY x)
                                        let inner = Expression::PercentileCont(Box::new(
                                            crate::expressions::PercentileFunc {
                                                this: column.clone(),
                                                percentile: quantile,
                                                order_by: None,
                                                filter: None,
                                            },
                                        ));
                                        Ok(Expression::WithinGroup(Box::new(
                                            crate::expressions::WithinGroup {
                                                this: inner,
                                                order_by: vec![crate::expressions::Ordered {
                                                    this: column,
                                                    desc: false,
                                                    nulls_first: None,
                                                    explicit_asc: false,
                                                    with_fill: None,
                                                }],
                                            },
                                        )))
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "QUANTILE_CONT".to_string(),
                                        vec![column, quantile],
                                    )))),
                                }
                            }
                            // QUANTILE_DISC(x, q) -> PERCENTILE_DISC(q) WITHIN GROUP (ORDER BY x) for PostgreSQL/Snowflake
                            "QUANTILE_DISC" if f.args.len() == 2 => {
                                let mut args = f.args;
                                let column = args.remove(0);
                                let quantile = args.remove(0);
                                match target {
                                    DialectType::DuckDB => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "QUANTILE_DISC".to_string(),
                                            vec![column, quantile],
                                        ))))
                                    }
                                    DialectType::PostgreSQL
                                    | DialectType::Redshift
                                    | DialectType::Snowflake => {
                                        // PERCENTILE_DISC(q) WITHIN GROUP (ORDER BY x)
                                        let inner = Expression::PercentileDisc(Box::new(
                                            crate::expressions::PercentileFunc {
                                                this: column.clone(),
                                                percentile: quantile,
                                                order_by: None,
                                                filter: None,
                                            },
                                        ));
                                        Ok(Expression::WithinGroup(Box::new(
                                            crate::expressions::WithinGroup {
                                                this: inner,
                                                order_by: vec![crate::expressions::Ordered {
                                                    this: column,
                                                    desc: false,
                                                    nulls_first: None,
                                                    explicit_asc: false,
                                                    with_fill: None,
                                                }],
                                            },
                                        )))
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "QUANTILE_DISC".to_string(),
                                        vec![column, quantile],
                                    )))),
                                }
                            }
                            // PERCENTILE_APPROX(x, p) / APPROX_PERCENTILE(x, p) -> target-specific
                            "PERCENTILE_APPROX" | "APPROX_PERCENTILE" if f.args.len() >= 2 => {
                                let name = match target {
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => "APPROX_PERCENTILE",
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => "PERCENTILE_APPROX",
                                    DialectType::DuckDB => "APPROX_QUANTILE",
                                    DialectType::PostgreSQL | DialectType::Redshift => {
                                        "PERCENTILE_CONT"
                                    }
                                    _ => &f.name,
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // EPOCH(x) -> UNIX_TIMESTAMP(x) for Spark/Hive
                            "EPOCH" if f.args.len() == 1 => {
                                let name = match target {
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => "UNIX_TIMESTAMP",
                                    DialectType::Presto | DialectType::Trino => "TO_UNIXTIME",
                                    _ => "EPOCH",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // EPOCH_MS(x) -> target-specific epoch milliseconds conversion
                            "EPOCH_MS" if f.args.len() == 1 => {
                                match target {
                                    DialectType::Spark | DialectType::Databricks => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "TIMESTAMP_MILLIS".to_string(),
                                            f.args,
                                        ))))
                                    }
                                    DialectType::Hive => {
                                        // Hive: FROM_UNIXTIME(x / 1000)
                                        let arg = f.args.into_iter().next().unwrap();
                                        let div_expr = Expression::Div(Box::new(
                                            crate::expressions::BinaryOp::new(
                                                arg,
                                                Expression::number(1000),
                                            ),
                                        ));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "FROM_UNIXTIME".to_string(),
                                            vec![div_expr],
                                        ))))
                                    }
                                    DialectType::Presto | DialectType::Trino => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "FROM_UNIXTIME".to_string(),
                                            vec![Expression::Div(Box::new(
                                                crate::expressions::BinaryOp::new(
                                                    f.args.into_iter().next().unwrap(),
                                                    Expression::number(1000),
                                                ),
                                            ))],
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "EPOCH_MS".to_string(),
                                        f.args,
                                    )))),
                                }
                            }
                            // HASHBYTES('algorithm', x) -> target-specific hash function
                            "HASHBYTES" if f.args.len() == 2 => {
                                // Keep HASHBYTES as-is for TSQL target
                                if matches!(target, DialectType::TSQL) {
                                    return Ok(Expression::Function(f));
                                }
                                let algo_expr = &f.args[0];
                                let algo = match algo_expr {
                                    Expression::Literal(crate::expressions::Literal::String(s)) => {
                                        s.to_uppercase()
                                    }
                                    _ => return Ok(Expression::Function(f)),
                                };
                                let data_arg = f.args.into_iter().nth(1).unwrap();
                                match algo.as_str() {
                                    "SHA1" => {
                                        let name = match target {
                                            DialectType::Spark | DialectType::Databricks => "SHA",
                                            DialectType::Hive => "SHA1",
                                            _ => "SHA1",
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            name.to_string(),
                                            vec![data_arg],
                                        ))))
                                    }
                                    "SHA2_256" => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "SHA2".to_string(),
                                            vec![data_arg, Expression::number(256)],
                                        ))))
                                    }
                                    "SHA2_512" => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "SHA2".to_string(),
                                            vec![data_arg, Expression::number(512)],
                                        ))))
                                    }
                                    "MD5" => Ok(Expression::Function(Box::new(Function::new(
                                        "MD5".to_string(),
                                        vec![data_arg],
                                    )))),
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "HASHBYTES".to_string(),
                                        vec![Expression::string(&algo), data_arg],
                                    )))),
                                }
                            }
                            // JSON_EXTRACT_PATH(json, key1, key2, ...) -> target-specific JSON extraction
                            "JSON_EXTRACT_PATH" | "JSON_EXTRACT_PATH_TEXT" if f.args.len() >= 2 => {
                                let is_text = name == "JSON_EXTRACT_PATH_TEXT";
                                let mut args = f.args;
                                let json_expr = args.remove(0);
                                // Build JSON path from remaining keys: $.key1.key2 or $.key1[0]
                                let mut json_path = "$".to_string();
                                for a in &args {
                                    match a {
                                        Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) => {
                                            // Numeric string keys become array indices: [0]
                                            if s.chars().all(|c| c.is_ascii_digit()) {
                                                json_path.push('[');
                                                json_path.push_str(s);
                                                json_path.push(']');
                                            } else {
                                                json_path.push('.');
                                                json_path.push_str(s);
                                            }
                                        }
                                        _ => {
                                            json_path.push_str(".?");
                                        }
                                    }
                                }
                                match target {
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "GET_JSON_OBJECT".to_string(),
                                            vec![json_expr, Expression::string(&json_path)],
                                        ))))
                                    }
                                    DialectType::Presto | DialectType::Trino => {
                                        let func_name = if is_text {
                                            "JSON_EXTRACT_SCALAR"
                                        } else {
                                            "JSON_EXTRACT"
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            func_name.to_string(),
                                            vec![json_expr, Expression::string(&json_path)],
                                        ))))
                                    }
                                    DialectType::BigQuery | DialectType::MySQL => {
                                        let func_name = if is_text {
                                            "JSON_EXTRACT_SCALAR"
                                        } else {
                                            "JSON_EXTRACT"
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            func_name.to_string(),
                                            vec![json_expr, Expression::string(&json_path)],
                                        ))))
                                    }
                                    DialectType::PostgreSQL | DialectType::Materialize => {
                                        // Keep as JSON_EXTRACT_PATH_TEXT / JSON_EXTRACT_PATH for PostgreSQL/Materialize
                                        let func_name = if is_text {
                                            "JSON_EXTRACT_PATH_TEXT"
                                        } else {
                                            "JSON_EXTRACT_PATH"
                                        };
                                        let mut new_args = vec![json_expr];
                                        new_args.extend(args);
                                        Ok(Expression::Function(Box::new(Function::new(
                                            func_name.to_string(),
                                            new_args,
                                        ))))
                                    }
                                    DialectType::DuckDB | DialectType::SQLite => {
                                        // Use -> for JSON_EXTRACT_PATH, ->> for JSON_EXTRACT_PATH_TEXT
                                        if is_text {
                                            Ok(Expression::JsonExtractScalar(Box::new(
                                                crate::expressions::JsonExtractFunc {
                                                    this: json_expr,
                                                    path: Expression::string(&json_path),
                                                    returning: None,
                                                    arrow_syntax: true,
                                                    hash_arrow_syntax: false,
                                                    wrapper_option: None,
                                                    quotes_option: None,
                                                    on_scalar_string: false,
                                                    on_error: None,
                                                },
                                            )))
                                        } else {
                                            Ok(Expression::JsonExtract(Box::new(
                                                crate::expressions::JsonExtractFunc {
                                                    this: json_expr,
                                                    path: Expression::string(&json_path),
                                                    returning: None,
                                                    arrow_syntax: true,
                                                    hash_arrow_syntax: false,
                                                    wrapper_option: None,
                                                    quotes_option: None,
                                                    on_scalar_string: false,
                                                    on_error: None,
                                                },
                                            )))
                                        }
                                    }
                                    DialectType::Redshift => {
                                        // Keep as JSON_EXTRACT_PATH_TEXT for Redshift
                                        let mut new_args = vec![json_expr];
                                        new_args.extend(args);
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "JSON_EXTRACT_PATH_TEXT".to_string(),
                                            new_args,
                                        ))))
                                    }
                                    DialectType::TSQL => {
                                        // ISNULL(JSON_QUERY(json, '$.path'), JSON_VALUE(json, '$.path'))
                                        let jq = Expression::Function(Box::new(Function::new(
                                            "JSON_QUERY".to_string(),
                                            vec![json_expr.clone(), Expression::string(&json_path)],
                                        )));
                                        let jv = Expression::Function(Box::new(Function::new(
                                            "JSON_VALUE".to_string(),
                                            vec![json_expr, Expression::string(&json_path)],
                                        )));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "ISNULL".to_string(),
                                            vec![jq, jv],
                                        ))))
                                    }
                                    DialectType::ClickHouse => {
                                        let func_name = if is_text {
                                            "JSONExtractString"
                                        } else {
                                            "JSONExtractRaw"
                                        };
                                        let mut new_args = vec![json_expr];
                                        new_args.extend(args);
                                        Ok(Expression::Function(Box::new(Function::new(
                                            func_name.to_string(),
                                            new_args,
                                        ))))
                                    }
                                    _ => {
                                        let func_name = if is_text {
                                            "JSON_EXTRACT_SCALAR"
                                        } else {
                                            "JSON_EXTRACT"
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            func_name.to_string(),
                                            vec![json_expr, Expression::string(&json_path)],
                                        ))))
                                    }
                                }
                            }
                            // APPROX_DISTINCT(x) -> APPROX_COUNT_DISTINCT(x) for Spark/Hive/BigQuery
                            "APPROX_DISTINCT" if f.args.len() >= 1 => {
                                let name = match target {
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive
                                    | DialectType::BigQuery => "APPROX_COUNT_DISTINCT",
                                    _ => "APPROX_DISTINCT",
                                };
                                let mut args = f.args;
                                // Hive doesn't support the accuracy parameter
                                if name == "APPROX_COUNT_DISTINCT"
                                    && matches!(target, DialectType::Hive)
                                {
                                    args.truncate(1);
                                }
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    args,
                                ))))
                            }
                            // REGEXP_EXTRACT(x, pattern) - normalize default group index
                            "REGEXP_EXTRACT" if f.args.len() == 2 => {
                                // Determine source default group index
                                let source_default = match source {
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::DuckDB => 0,
                                    _ => 1, // Hive/Spark/Databricks default = 1
                                };
                                // Determine target default group index
                                let target_default = match target {
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::DuckDB
                                    | DialectType::BigQuery => 0,
                                    DialectType::Snowflake => {
                                        // Snowflake uses REGEXP_SUBSTR
                                        return Ok(Expression::Function(Box::new(Function::new(
                                            "REGEXP_SUBSTR".to_string(),
                                            f.args,
                                        ))));
                                    }
                                    _ => 1, // Hive/Spark/Databricks default = 1
                                };
                                if source_default != target_default {
                                    let mut args = f.args;
                                    args.push(Expression::number(source_default));
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "REGEXP_EXTRACT".to_string(),
                                        args,
                                    ))))
                                } else {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "REGEXP_EXTRACT".to_string(),
                                        f.args,
                                    ))))
                                }
                            }
                            // RLIKE(str, pattern) -> RegexpLike expression (generates as target-specific form)
                            "RLIKE" if f.args.len() == 2 => {
                                let mut args = f.args;
                                let str_expr = args.remove(0);
                                let pattern = args.remove(0);
                                match target {
                                    DialectType::DuckDB => {
                                        // REGEXP_MATCHES(str, pattern)
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "REGEXP_MATCHES".to_string(),
                                            vec![str_expr, pattern],
                                        ))))
                                    }
                                    _ => {
                                        // Convert to RegexpLike which generates as RLIKE/~/REGEXP_LIKE per dialect
                                        Ok(Expression::RegexpLike(Box::new(
                                            crate::expressions::RegexpFunc {
                                                this: str_expr,
                                                pattern,
                                                flags: None,
                                            },
                                        )))
                                    }
                                }
                            }
                            // EOMONTH(date[, month_offset]) -> target-specific
                            "EOMONTH" if f.args.len() >= 1 => {
                                let mut args = f.args;
                                let date_arg = args.remove(0);
                                let month_offset = if !args.is_empty() {
                                    Some(args.remove(0))
                                } else {
                                    None
                                };

                                // Helper: wrap date in CAST to DATE
                                let cast_to_date = |e: Expression| -> Expression {
                                    Expression::Cast(Box::new(Cast {
                                        this: e,
                                        to: DataType::Date,
                                        trailing_comments: vec![],
                                        double_colon_syntax: false,
                                        format: None,
                                        default: None,
                                    }))
                                };

                                match target {
                                    DialectType::TSQL | DialectType::Fabric => {
                                        // TSQL: EOMONTH(CAST(date AS DATE)) or EOMONTH(DATEADD(MONTH, offset, CAST(date AS DATE)))
                                        let date = cast_to_date(date_arg);
                                        let date = if let Some(offset) = month_offset {
                                            Expression::Function(Box::new(Function::new(
                                                "DATEADD".to_string(),
                                                vec![
                                                    Expression::Identifier(Identifier::new(
                                                        "MONTH",
                                                    )),
                                                    offset,
                                                    date,
                                                ],
                                            )))
                                        } else {
                                            date
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "EOMONTH".to_string(),
                                            vec![date],
                                        ))))
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        // Presto: LAST_DAY_OF_MONTH(CAST(CAST(date AS TIMESTAMP) AS DATE))
                                        // or with offset: LAST_DAY_OF_MONTH(DATE_ADD('MONTH', offset, CAST(CAST(date AS TIMESTAMP) AS DATE)))
                                        let cast_ts = Expression::Cast(Box::new(Cast {
                                            this: date_arg,
                                            to: DataType::Timestamp {
                                                timezone: false,
                                                precision: None,
                                            },
                                            trailing_comments: vec![],
                                            double_colon_syntax: false,
                                            format: None,
                                            default: None,
                                        }));
                                        let date = cast_to_date(cast_ts);
                                        let date = if let Some(offset) = month_offset {
                                            Expression::Function(Box::new(Function::new(
                                                "DATE_ADD".to_string(),
                                                vec![Expression::string("MONTH"), offset, date],
                                            )))
                                        } else {
                                            date
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "LAST_DAY_OF_MONTH".to_string(),
                                            vec![date],
                                        ))))
                                    }
                                    DialectType::PostgreSQL => {
                                        // PostgreSQL: CAST(DATE_TRUNC('MONTH', CAST(date AS DATE) [+ INTERVAL 'offset MONTH']) + INTERVAL '1 MONTH' - INTERVAL '1 DAY' AS DATE)
                                        let date = cast_to_date(date_arg);
                                        let date = if let Some(offset) = month_offset {
                                            let interval_str = format!(
                                                "{} MONTH",
                                                Self::expr_to_string_static(&offset)
                                            );
                                            Expression::Add(Box::new(
                                                crate::expressions::BinaryOp::new(
                                                    date,
                                                    Expression::Interval(Box::new(
                                                        crate::expressions::Interval {
                                                            this: Some(Expression::string(
                                                                &interval_str,
                                                            )),
                                                            unit: None,
                                                        },
                                                    )),
                                                ),
                                            ))
                                        } else {
                                            date
                                        };
                                        let truncated =
                                            Expression::Function(Box::new(Function::new(
                                                "DATE_TRUNC".to_string(),
                                                vec![Expression::string("MONTH"), date],
                                            )));
                                        let plus_month = Expression::Add(Box::new(
                                            crate::expressions::BinaryOp::new(
                                                truncated,
                                                Expression::Interval(Box::new(
                                                    crate::expressions::Interval {
                                                        this: Some(Expression::string("1 MONTH")),
                                                        unit: None,
                                                    },
                                                )),
                                            ),
                                        ));
                                        let minus_day = Expression::Sub(Box::new(
                                            crate::expressions::BinaryOp::new(
                                                plus_month,
                                                Expression::Interval(Box::new(
                                                    crate::expressions::Interval {
                                                        this: Some(Expression::string("1 DAY")),
                                                        unit: None,
                                                    },
                                                )),
                                            ),
                                        ));
                                        Ok(Expression::Cast(Box::new(Cast {
                                            this: minus_day,
                                            to: DataType::Date,
                                            trailing_comments: vec![],
                                            double_colon_syntax: false,
                                            format: None,
                                            default: None,
                                        })))
                                    }
                                    DialectType::DuckDB => {
                                        // DuckDB: LAST_DAY(CAST(date AS DATE) [+ INTERVAL (offset) MONTH])
                                        let date = cast_to_date(date_arg);
                                        let date = if let Some(offset) = month_offset {
                                            // Wrap negative numbers in parentheses for DuckDB INTERVAL
                                            let interval_val =
                                                if matches!(&offset, Expression::Neg(_)) {
                                                    Expression::Paren(Box::new(
                                                        crate::expressions::Paren {
                                                            this: offset,
                                                            trailing_comments: Vec::new(),
                                                        },
                                                    ))
                                                } else {
                                                    offset
                                                };
                                            Expression::Add(Box::new(crate::expressions::BinaryOp::new(
                                                date,
                                                Expression::Interval(Box::new(crate::expressions::Interval {
                                                    this: Some(interval_val),
                                                    unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                                        unit: crate::expressions::IntervalUnit::Month,
                                                        use_plural: false,
                                                    }),
                                                })),
                                            )))
                                        } else {
                                            date
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "LAST_DAY".to_string(),
                                            vec![date],
                                        ))))
                                    }
                                    DialectType::Snowflake | DialectType::Redshift => {
                                        // Snowflake/Redshift: LAST_DAY(TO_DATE(date) or CAST(date AS DATE))
                                        // With offset: LAST_DAY(DATEADD(MONTH, offset, TO_DATE(date)))
                                        let date = if matches!(target, DialectType::Snowflake) {
                                            Expression::Function(Box::new(Function::new(
                                                "TO_DATE".to_string(),
                                                vec![date_arg],
                                            )))
                                        } else {
                                            cast_to_date(date_arg)
                                        };
                                        let date = if let Some(offset) = month_offset {
                                            Expression::Function(Box::new(Function::new(
                                                "DATEADD".to_string(),
                                                vec![
                                                    Expression::Identifier(Identifier::new(
                                                        "MONTH",
                                                    )),
                                                    offset,
                                                    date,
                                                ],
                                            )))
                                        } else {
                                            date
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "LAST_DAY".to_string(),
                                            vec![date],
                                        ))))
                                    }
                                    DialectType::Spark | DialectType::Databricks => {
                                        // Spark: LAST_DAY(TO_DATE(date))
                                        // With offset: LAST_DAY(ADD_MONTHS(TO_DATE(date), offset))
                                        let date = Expression::Function(Box::new(Function::new(
                                            "TO_DATE".to_string(),
                                            vec![date_arg],
                                        )));
                                        let date = if let Some(offset) = month_offset {
                                            Expression::Function(Box::new(Function::new(
                                                "ADD_MONTHS".to_string(),
                                                vec![date, offset],
                                            )))
                                        } else {
                                            date
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "LAST_DAY".to_string(),
                                            vec![date],
                                        ))))
                                    }
                                    DialectType::MySQL => {
                                        // MySQL: LAST_DAY(DATE(date)) - no offset
                                        // With offset: LAST_DAY(DATE_ADD(date, INTERVAL offset MONTH)) - no DATE() wrapper
                                        let date = if let Some(offset) = month_offset {
                                            let iu = crate::expressions::IntervalUnit::Month;
                                            Expression::DateAdd(Box::new(
                                                crate::expressions::DateAddFunc {
                                                    this: date_arg,
                                                    interval: offset,
                                                    unit: iu,
                                                },
                                            ))
                                        } else {
                                            Expression::Function(Box::new(Function::new(
                                                "DATE".to_string(),
                                                vec![date_arg],
                                            )))
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "LAST_DAY".to_string(),
                                            vec![date],
                                        ))))
                                    }
                                    DialectType::BigQuery => {
                                        // BigQuery: LAST_DAY(CAST(date AS DATE))
                                        // With offset: LAST_DAY(DATE_ADD(CAST(date AS DATE), INTERVAL offset MONTH))
                                        let date = cast_to_date(date_arg);
                                        let date = if let Some(offset) = month_offset {
                                            let interval = Expression::Interval(Box::new(crate::expressions::Interval {
                                                this: Some(offset),
                                                unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                                    unit: crate::expressions::IntervalUnit::Month,
                                                    use_plural: false,
                                                }),
                                            }));
                                            Expression::Function(Box::new(Function::new(
                                                "DATE_ADD".to_string(),
                                                vec![date, interval],
                                            )))
                                        } else {
                                            date
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "LAST_DAY".to_string(),
                                            vec![date],
                                        ))))
                                    }
                                    DialectType::ClickHouse => {
                                        // ClickHouse: LAST_DAY(CAST(date AS Nullable(DATE)))
                                        let date = Expression::Cast(Box::new(Cast {
                                            this: date_arg,
                                            to: DataType::Nullable {
                                                inner: Box::new(DataType::Date),
                                            },
                                            trailing_comments: vec![],
                                            double_colon_syntax: false,
                                            format: None,
                                            default: None,
                                        }));
                                        let date = if let Some(offset) = month_offset {
                                            Expression::Function(Box::new(Function::new(
                                                "DATE_ADD".to_string(),
                                                vec![
                                                    Expression::Identifier(Identifier::new(
                                                        "MONTH",
                                                    )),
                                                    offset,
                                                    date,
                                                ],
                                            )))
                                        } else {
                                            date
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "LAST_DAY".to_string(),
                                            vec![date],
                                        ))))
                                    }
                                    DialectType::Hive => {
                                        // Hive: LAST_DAY(date)
                                        let date = if let Some(offset) = month_offset {
                                            Expression::Function(Box::new(Function::new(
                                                "ADD_MONTHS".to_string(),
                                                vec![date_arg, offset],
                                            )))
                                        } else {
                                            date_arg
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "LAST_DAY".to_string(),
                                            vec![date],
                                        ))))
                                    }
                                    _ => {
                                        // Default: LAST_DAY(date)
                                        let date = if let Some(offset) = month_offset {
                                            let unit =
                                                Expression::Identifier(Identifier::new("MONTH"));
                                            Expression::Function(Box::new(Function::new(
                                                "DATEADD".to_string(),
                                                vec![unit, offset, date_arg],
                                            )))
                                        } else {
                                            date_arg
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "LAST_DAY".to_string(),
                                            vec![date],
                                        ))))
                                    }
                                }
                            }
                            // LAST_DAY(x) / LAST_DAY_OF_MONTH(x) -> target-specific
                            "LAST_DAY" | "LAST_DAY_OF_MONTH"
                                if !matches!(source, DialectType::BigQuery)
                                    && f.args.len() >= 1 =>
                            {
                                let first_arg = f.args.into_iter().next().unwrap();
                                match target {
                                    DialectType::TSQL | DialectType::Fabric => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "EOMONTH".to_string(),
                                            vec![first_arg],
                                        ))))
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "LAST_DAY_OF_MONTH".to_string(),
                                            vec![first_arg],
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "LAST_DAY".to_string(),
                                        vec![first_arg],
                                    )))),
                                }
                            }
                            // MAP(keys_array, vals_array) from Presto (2-arg form) -> target-specific
                            "MAP"
                                if f.args.len() == 2
                                    && matches!(
                                        source,
                                        DialectType::Presto
                                            | DialectType::Trino
                                            | DialectType::Athena
                                    ) =>
                            {
                                let keys_arg = f.args[0].clone();
                                let vals_arg = f.args[1].clone();

                                // Helper: extract array elements from Array/ArrayFunc/Function("ARRAY") expressions
                                fn extract_array_elements(
                                    expr: &Expression,
                                ) -> Option<&Vec<Expression>> {
                                    match expr {
                                        Expression::Array(arr) => Some(&arr.expressions),
                                        Expression::ArrayFunc(arr) => Some(&arr.expressions),
                                        Expression::Function(f)
                                            if f.name.eq_ignore_ascii_case("ARRAY") =>
                                        {
                                            Some(&f.args)
                                        }
                                        _ => None,
                                    }
                                }

                                match target {
                                    DialectType::Spark | DialectType::Databricks => {
                                        // Presto MAP(keys, vals) -> Spark MAP_FROM_ARRAYS(keys, vals)
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "MAP_FROM_ARRAYS".to_string(),
                                            f.args,
                                        ))))
                                    }
                                    DialectType::Hive => {
                                        // Presto MAP(ARRAY[k1,k2], ARRAY[v1,v2]) -> Hive MAP(k1, v1, k2, v2)
                                        if let (Some(keys), Some(vals)) = (
                                            extract_array_elements(&keys_arg),
                                            extract_array_elements(&vals_arg),
                                        ) {
                                            if keys.len() == vals.len() {
                                                let mut interleaved = Vec::new();
                                                for (k, v) in keys.iter().zip(vals.iter()) {
                                                    interleaved.push(k.clone());
                                                    interleaved.push(v.clone());
                                                }
                                                Ok(Expression::Function(Box::new(Function::new(
                                                    "MAP".to_string(),
                                                    interleaved,
                                                ))))
                                            } else {
                                                Ok(Expression::Function(Box::new(Function::new(
                                                    "MAP".to_string(),
                                                    f.args,
                                                ))))
                                            }
                                        } else {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "MAP".to_string(),
                                                f.args,
                                            ))))
                                        }
                                    }
                                    DialectType::Snowflake => {
                                        // Presto MAP(ARRAY[k1,k2], ARRAY[v1,v2]) -> Snowflake OBJECT_CONSTRUCT(k1, v1, k2, v2)
                                        if let (Some(keys), Some(vals)) = (
                                            extract_array_elements(&keys_arg),
                                            extract_array_elements(&vals_arg),
                                        ) {
                                            if keys.len() == vals.len() {
                                                let mut interleaved = Vec::new();
                                                for (k, v) in keys.iter().zip(vals.iter()) {
                                                    interleaved.push(k.clone());
                                                    interleaved.push(v.clone());
                                                }
                                                Ok(Expression::Function(Box::new(Function::new(
                                                    "OBJECT_CONSTRUCT".to_string(),
                                                    interleaved,
                                                ))))
                                            } else {
                                                Ok(Expression::Function(Box::new(Function::new(
                                                    "MAP".to_string(),
                                                    f.args,
                                                ))))
                                            }
                                        } else {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "MAP".to_string(),
                                                f.args,
                                            ))))
                                        }
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // MAP() with 0 args from Spark -> MAP(ARRAY[], ARRAY[]) for Presto/Trino
                            "MAP"
                                if f.args.is_empty()
                                    && matches!(
                                        source,
                                        DialectType::Hive
                                            | DialectType::Spark
                                            | DialectType::Databricks
                                    )
                                    && matches!(
                                        target,
                                        DialectType::Presto
                                            | DialectType::Trino
                                            | DialectType::Athena
                                    ) =>
                            {
                                let empty_keys =
                                    Expression::Array(Box::new(crate::expressions::Array {
                                        expressions: vec![],
                                    }));
                                let empty_vals =
                                    Expression::Array(Box::new(crate::expressions::Array {
                                        expressions: vec![],
                                    }));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "MAP".to_string(),
                                    vec![empty_keys, empty_vals],
                                ))))
                            }
                            // MAP(k1, v1, k2, v2, ...) from Hive/Spark -> target-specific
                            "MAP"
                                if f.args.len() >= 2
                                    && f.args.len() % 2 == 0
                                    && matches!(
                                        source,
                                        DialectType::Hive
                                            | DialectType::Spark
                                            | DialectType::Databricks
                                            | DialectType::ClickHouse
                                    ) =>
                            {
                                let args = f.args;
                                match target {
                                    DialectType::DuckDB => {
                                        // MAP([k1, k2], [v1, v2])
                                        let mut keys = Vec::new();
                                        let mut vals = Vec::new();
                                        for (i, arg) in args.into_iter().enumerate() {
                                            if i % 2 == 0 {
                                                keys.push(arg);
                                            } else {
                                                vals.push(arg);
                                            }
                                        }
                                        let keys_arr = Expression::Array(Box::new(
                                            crate::expressions::Array { expressions: keys },
                                        ));
                                        let vals_arr = Expression::Array(Box::new(
                                            crate::expressions::Array { expressions: vals },
                                        ));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "MAP".to_string(),
                                            vec![keys_arr, vals_arr],
                                        ))))
                                    }
                                    DialectType::Presto | DialectType::Trino => {
                                        // MAP(ARRAY[k1, k2], ARRAY[v1, v2])
                                        let mut keys = Vec::new();
                                        let mut vals = Vec::new();
                                        for (i, arg) in args.into_iter().enumerate() {
                                            if i % 2 == 0 {
                                                keys.push(arg);
                                            } else {
                                                vals.push(arg);
                                            }
                                        }
                                        let keys_arr = Expression::Array(Box::new(
                                            crate::expressions::Array { expressions: keys },
                                        ));
                                        let vals_arr = Expression::Array(Box::new(
                                            crate::expressions::Array { expressions: vals },
                                        ));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "MAP".to_string(),
                                            vec![keys_arr, vals_arr],
                                        ))))
                                    }
                                    DialectType::Snowflake => Ok(Expression::Function(Box::new(
                                        Function::new("OBJECT_CONSTRUCT".to_string(), args),
                                    ))),
                                    DialectType::ClickHouse => Ok(Expression::Function(Box::new(
                                        Function::new("map".to_string(), args),
                                    ))),
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "MAP".to_string(),
                                        args,
                                    )))),
                                }
                            }
                            // COLLECT_LIST(x) -> ARRAY_AGG(x) for most targets
                            "COLLECT_LIST" if f.args.len() >= 1 => {
                                let name = match target {
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => "COLLECT_LIST",
                                    DialectType::DuckDB
                                    | DialectType::PostgreSQL
                                    | DialectType::Redshift
                                    | DialectType::Snowflake
                                    | DialectType::BigQuery => "ARRAY_AGG",
                                    DialectType::Presto | DialectType::Trino => "ARRAY_AGG",
                                    _ => "ARRAY_AGG",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // COLLECT_SET(x) -> target-specific distinct array aggregation
                            "COLLECT_SET" if f.args.len() >= 1 => {
                                let name = match target {
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => "COLLECT_SET",
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => "SET_AGG",
                                    DialectType::Snowflake => "ARRAY_UNIQUE_AGG",
                                    _ => "ARRAY_AGG",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // ISNAN(x) / IS_NAN(x) - normalize
                            "ISNAN" | "IS_NAN" => {
                                let name = match target {
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => "ISNAN",
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => "IS_NAN",
                                    DialectType::BigQuery
                                    | DialectType::PostgreSQL
                                    | DialectType::Redshift => "IS_NAN",
                                    DialectType::ClickHouse => "IS_NAN",
                                    _ => "ISNAN",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // SPLIT_PART(str, delim, index) -> target-specific
                            "SPLIT_PART" if f.args.len() == 3 => {
                                match target {
                                    DialectType::Spark | DialectType::Databricks => {
                                        // Keep as SPLIT_PART (Spark 3.4+)
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "SPLIT_PART".to_string(),
                                            f.args,
                                        ))))
                                    }
                                    DialectType::DuckDB
                                    | DialectType::PostgreSQL
                                    | DialectType::Snowflake
                                    | DialectType::Redshift
                                    | DialectType::Trino
                                    | DialectType::Presto => Ok(Expression::Function(Box::new(
                                        Function::new("SPLIT_PART".to_string(), f.args),
                                    ))),
                                    DialectType::Hive => {
                                        // SPLIT(str, delim)[index]
                                        // Complex conversion, just keep as-is for now
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "SPLIT_PART".to_string(),
                                            f.args,
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "SPLIT_PART".to_string(),
                                        f.args,
                                    )))),
                                }
                            }
                            // JSON_EXTRACT(json, path) -> target-specific JSON extraction
                            "JSON_EXTRACT" | "JSON_EXTRACT_SCALAR" if f.args.len() == 2 => {
                                let is_scalar = name == "JSON_EXTRACT_SCALAR";
                                match target {
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => {
                                        let mut args = f.args;
                                        // Spark/Hive don't support Presto's TRY(expr) wrapper form here.
                                        // Mirror sqlglot by unwrapping TRY(expr) to expr before GET_JSON_OBJECT.
                                        if let Some(Expression::Function(inner)) = args.first() {
                                            if inner.name.eq_ignore_ascii_case("TRY")
                                                && inner.args.len() == 1
                                            {
                                                let mut inner_args = inner.args.clone();
                                                args[0] = inner_args.remove(0);
                                            }
                                        }
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "GET_JSON_OBJECT".to_string(),
                                            args,
                                        ))))
                                    }
                                    DialectType::DuckDB | DialectType::SQLite => {
                                        // json -> path syntax
                                        let mut args = f.args;
                                        let json_expr = args.remove(0);
                                        let path = args.remove(0);
                                        Ok(Expression::JsonExtract(Box::new(
                                            crate::expressions::JsonExtractFunc {
                                                this: json_expr,
                                                path,
                                                returning: None,
                                                arrow_syntax: true,
                                                hash_arrow_syntax: false,
                                                wrapper_option: None,
                                                quotes_option: None,
                                                on_scalar_string: false,
                                                on_error: None,
                                            },
                                        )))
                                    }
                                    DialectType::TSQL => {
                                        let func_name = if is_scalar {
                                            "JSON_VALUE"
                                        } else {
                                            "JSON_QUERY"
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            func_name.to_string(),
                                            f.args,
                                        ))))
                                    }
                                    DialectType::PostgreSQL | DialectType::Redshift => {
                                        let func_name = if is_scalar {
                                            "JSON_EXTRACT_PATH_TEXT"
                                        } else {
                                            "JSON_EXTRACT_PATH"
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            func_name.to_string(),
                                            f.args,
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        name.to_string(),
                                        f.args,
                                    )))),
                                }
                            }
                            // SingleStore JSON_EXTRACT_JSON(json, key1, key2, ...) -> JSON_EXTRACT(json, '$.key1.key2' or '$.key1[key2]')
                            // BSON_EXTRACT_BSON(json, key1, ...) -> JSONB_EXTRACT(json, '$.key1')
                            "JSON_EXTRACT_JSON" | "BSON_EXTRACT_BSON"
                                if f.args.len() >= 2
                                    && matches!(source, DialectType::SingleStore) =>
                            {
                                let is_bson = name == "BSON_EXTRACT_BSON";
                                let mut args = f.args;
                                let json_expr = args.remove(0);

                                // Build JSONPath from remaining arguments
                                let mut path = String::from("$");
                                for arg in &args {
                                    if let Expression::Literal(
                                        crate::expressions::Literal::String(s),
                                    ) = arg
                                    {
                                        // Check if it's a numeric string (array index)
                                        if s.parse::<i64>().is_ok() {
                                            path.push('[');
                                            path.push_str(s);
                                            path.push(']');
                                        } else {
                                            path.push('.');
                                            path.push_str(s);
                                        }
                                    }
                                }

                                let target_func = if is_bson {
                                    "JSONB_EXTRACT"
                                } else {
                                    "JSON_EXTRACT"
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    target_func.to_string(),
                                    vec![json_expr, Expression::string(&path)],
                                ))))
                            }
                            // ARRAY_SUM(lambda, array) from Doris -> ClickHouse arraySum
                            "ARRAY_SUM" if matches!(target, DialectType::ClickHouse) => {
                                Ok(Expression::Function(Box::new(Function {
                                    name: "arraySum".to_string(),
                                    args: f.args,
                                    distinct: f.distinct,
                                    trailing_comments: f.trailing_comments,
                                    use_bracket_syntax: f.use_bracket_syntax,
                                    no_parens: f.no_parens,
                                    quoted: f.quoted,
                                })))
                            }
                            // TSQL JSON_QUERY/JSON_VALUE -> target-specific
                            // Note: For TSQL->TSQL, JsonQuery stays as Expression::JsonQuery (source transform not called)
                            // and is handled by JsonQueryValueConvert action. This handles the case where
                            // TSQL read transform converted JsonQuery to Function("JSON_QUERY") for cross-dialect.
                            "JSON_QUERY" | "JSON_VALUE"
                                if f.args.len() == 2
                                    && matches!(
                                        source,
                                        DialectType::TSQL | DialectType::Fabric
                                    ) =>
                            {
                                match target {
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => Ok(Expression::Function(Box::new(
                                        Function::new("GET_JSON_OBJECT".to_string(), f.args),
                                    ))),
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        name.to_string(),
                                        f.args,
                                    )))),
                                }
                            }
                            // UNIX_TIMESTAMP(x) -> TO_UNIXTIME(x) for Presto
                            "UNIX_TIMESTAMP" if f.args.len() == 1 => {
                                let arg = f.args.into_iter().next().unwrap();
                                let is_hive_source = matches!(
                                    source,
                                    DialectType::Hive
                                        | DialectType::Spark
                                        | DialectType::Databricks
                                );
                                match target {
                                    DialectType::DuckDB if is_hive_source => {
                                        // DuckDB: EPOCH(STRPTIME(x, '%Y-%m-%d %H:%M:%S'))
                                        let strptime =
                                            Expression::Function(Box::new(Function::new(
                                                "STRPTIME".to_string(),
                                                vec![arg, Expression::string("%Y-%m-%d %H:%M:%S")],
                                            )));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "EPOCH".to_string(),
                                            vec![strptime],
                                        ))))
                                    }
                                    DialectType::Presto | DialectType::Trino if is_hive_source => {
                                        // Presto: TO_UNIXTIME(COALESCE(TRY(DATE_PARSE(CAST(x AS VARCHAR), '%Y-%m-%d %T')), PARSE_DATETIME(DATE_FORMAT(x, '%Y-%m-%d %T'), 'yyyy-MM-dd HH:mm:ss')))
                                        let cast_varchar =
                                            Expression::Cast(Box::new(crate::expressions::Cast {
                                                this: arg.clone(),
                                                to: DataType::VarChar {
                                                    length: None,
                                                    parenthesized_length: false,
                                                },
                                                trailing_comments: vec![],
                                                double_colon_syntax: false,
                                                format: None,
                                                default: None,
                                            }));
                                        let date_parse =
                                            Expression::Function(Box::new(Function::new(
                                                "DATE_PARSE".to_string(),
                                                vec![
                                                    cast_varchar,
                                                    Expression::string("%Y-%m-%d %T"),
                                                ],
                                            )));
                                        let try_expr = Expression::Function(Box::new(
                                            Function::new("TRY".to_string(), vec![date_parse]),
                                        ));
                                        let date_format =
                                            Expression::Function(Box::new(Function::new(
                                                "DATE_FORMAT".to_string(),
                                                vec![arg, Expression::string("%Y-%m-%d %T")],
                                            )));
                                        let parse_datetime =
                                            Expression::Function(Box::new(Function::new(
                                                "PARSE_DATETIME".to_string(),
                                                vec![
                                                    date_format,
                                                    Expression::string("yyyy-MM-dd HH:mm:ss"),
                                                ],
                                            )));
                                        let coalesce =
                                            Expression::Function(Box::new(Function::new(
                                                "COALESCE".to_string(),
                                                vec![try_expr, parse_datetime],
                                            )));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "TO_UNIXTIME".to_string(),
                                            vec![coalesce],
                                        ))))
                                    }
                                    DialectType::Presto | DialectType::Trino => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "TO_UNIXTIME".to_string(),
                                            vec![arg],
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "UNIX_TIMESTAMP".to_string(),
                                        vec![arg],
                                    )))),
                                }
                            }
                            // TO_UNIX_TIMESTAMP(x) -> UNIX_TIMESTAMP(x) for Spark/Hive
                            "TO_UNIX_TIMESTAMP" if f.args.len() >= 1 => match target {
                                DialectType::Spark
                                | DialectType::Databricks
                                | DialectType::Hive => Ok(Expression::Function(Box::new(
                                    Function::new("UNIX_TIMESTAMP".to_string(), f.args),
                                ))),
                                _ => Ok(Expression::Function(Box::new(Function::new(
                                    "TO_UNIX_TIMESTAMP".to_string(),
                                    f.args,
                                )))),
                            },
                            // CURDATE() -> CURRENT_DATE
                            "CURDATE" => {
                                Ok(Expression::CurrentDate(crate::expressions::CurrentDate))
                            }
                            // CURTIME() -> CURRENT_TIME
                            "CURTIME" => {
                                Ok(Expression::CurrentTime(crate::expressions::CurrentTime {
                                    precision: None,
                                }))
                            }
                            // ARRAY_SORT(x) or ARRAY_SORT(x, lambda) -> SORT_ARRAY(x) for Hive (drop lambda)
                            "ARRAY_SORT" if f.args.len() >= 1 => {
                                match target {
                                    DialectType::Hive => {
                                        let mut args = f.args;
                                        args.truncate(1); // Drop lambda comparator
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "SORT_ARRAY".to_string(),
                                            args,
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // SORT_ARRAY(x) -> ARRAY_SORT(x) for non-Hive/Spark
                            "SORT_ARRAY" if f.args.len() == 1 => match target {
                                DialectType::Hive
                                | DialectType::Spark
                                | DialectType::Databricks => Ok(Expression::Function(f)),
                                _ => Ok(Expression::Function(Box::new(Function::new(
                                    "ARRAY_SORT".to_string(),
                                    f.args,
                                )))),
                            },
                            // SORT_ARRAY(x, FALSE) -> ARRAY_REVERSE_SORT(x) for DuckDB, ARRAY_SORT(x, lambda) for Presto
                            "SORT_ARRAY" if f.args.len() == 2 => {
                                let is_desc =
                                    matches!(&f.args[1], Expression::Boolean(b) if !b.value);
                                if is_desc {
                                    match target {
                                        DialectType::DuckDB => {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "ARRAY_REVERSE_SORT".to_string(),
                                                vec![f.args.into_iter().next().unwrap()],
                                            ))))
                                        }
                                        DialectType::Presto | DialectType::Trino => {
                                            let arr_arg = f.args.into_iter().next().unwrap();
                                            let a =
                                                Expression::Column(crate::expressions::Column {
                                                    name: crate::expressions::Identifier::new("a"),
                                                    table: None,
                                                    join_mark: false,
                                                    trailing_comments: Vec::new(),
                                                });
                                            let b =
                                                Expression::Column(crate::expressions::Column {
                                                    name: crate::expressions::Identifier::new("b"),
                                                    table: None,
                                                    join_mark: false,
                                                    trailing_comments: Vec::new(),
                                                });
                                            let case_expr = Expression::Case(Box::new(
                                                crate::expressions::Case {
                                                    operand: None,
                                                    whens: vec![
                                                        (
                                                            Expression::Lt(Box::new(
                                                                BinaryOp::new(a.clone(), b.clone()),
                                                            )),
                                                            Expression::Literal(Literal::Number(
                                                                "1".to_string(),
                                                            )),
                                                        ),
                                                        (
                                                            Expression::Gt(Box::new(
                                                                BinaryOp::new(a.clone(), b.clone()),
                                                            )),
                                                            Expression::Literal(Literal::Number(
                                                                "-1".to_string(),
                                                            )),
                                                        ),
                                                    ],
                                                    else_: Some(Expression::Literal(
                                                        Literal::Number("0".to_string()),
                                                    )),
                                                    comments: Vec::new(),
                                                },
                                            ));
                                            let lambda = Expression::Lambda(Box::new(
                                                crate::expressions::LambdaExpr {
                                                    parameters: vec![
                                                        crate::expressions::Identifier::new("a"),
                                                        crate::expressions::Identifier::new("b"),
                                                    ],
                                                    body: case_expr,
                                                    colon: false,
                                                    parameter_types: Vec::new(),
                                                },
                                            ));
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "ARRAY_SORT".to_string(),
                                                vec![arr_arg, lambda],
                                            ))))
                                        }
                                        _ => Ok(Expression::Function(f)),
                                    }
                                } else {
                                    // SORT_ARRAY(x, TRUE) -> ARRAY_SORT(x)
                                    match target {
                                        DialectType::Hive => Ok(Expression::Function(f)),
                                        _ => Ok(Expression::Function(Box::new(Function::new(
                                            "ARRAY_SORT".to_string(),
                                            vec![f.args.into_iter().next().unwrap()],
                                        )))),
                                    }
                                }
                            }
                            // LEFT(x, n), RIGHT(x, n) -> SUBSTRING for targets without LEFT/RIGHT
                            "LEFT" if f.args.len() == 2 => {
                                match target {
                                    DialectType::Hive
                                    | DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        let x = f.args[0].clone();
                                        let n = f.args[1].clone();
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "SUBSTRING".to_string(),
                                            vec![x, Expression::number(1), n],
                                        ))))
                                    }
                                    DialectType::Spark | DialectType::Databricks
                                        if matches!(
                                            source,
                                            DialectType::TSQL | DialectType::Fabric
                                        ) =>
                                    {
                                        // TSQL LEFT(x, n) -> LEFT(CAST(x AS STRING), n) for Spark
                                        let x = f.args[0].clone();
                                        let n = f.args[1].clone();
                                        let cast_x = Expression::Cast(Box::new(Cast {
                                            this: x,
                                            to: DataType::VarChar {
                                                length: None,
                                                parenthesized_length: false,
                                            },
                                            double_colon_syntax: false,
                                            trailing_comments: Vec::new(),
                                            format: None,
                                            default: None,
                                        }));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "LEFT".to_string(),
                                            vec![cast_x, n],
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            "RIGHT" if f.args.len() == 2 => {
                                match target {
                                    DialectType::Hive
                                    | DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        let x = f.args[0].clone();
                                        let n = f.args[1].clone();
                                        // SUBSTRING(x, LENGTH(x) - (n - 1))
                                        let len_x = Expression::Function(Box::new(Function::new(
                                            "LENGTH".to_string(),
                                            vec![x.clone()],
                                        )));
                                        let n_minus_1 = Expression::Sub(Box::new(
                                            crate::expressions::BinaryOp::new(
                                                n,
                                                Expression::number(1),
                                            ),
                                        ));
                                        let n_minus_1_paren = Expression::Paren(Box::new(
                                            crate::expressions::Paren {
                                                this: n_minus_1,
                                                trailing_comments: Vec::new(),
                                            },
                                        ));
                                        let offset = Expression::Sub(Box::new(
                                            crate::expressions::BinaryOp::new(
                                                len_x,
                                                n_minus_1_paren,
                                            ),
                                        ));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "SUBSTRING".to_string(),
                                            vec![x, offset],
                                        ))))
                                    }
                                    DialectType::Spark | DialectType::Databricks
                                        if matches!(
                                            source,
                                            DialectType::TSQL | DialectType::Fabric
                                        ) =>
                                    {
                                        // TSQL RIGHT(x, n) -> RIGHT(CAST(x AS STRING), n) for Spark
                                        let x = f.args[0].clone();
                                        let n = f.args[1].clone();
                                        let cast_x = Expression::Cast(Box::new(Cast {
                                            this: x,
                                            to: DataType::VarChar {
                                                length: None,
                                                parenthesized_length: false,
                                            },
                                            double_colon_syntax: false,
                                            trailing_comments: Vec::new(),
                                            format: None,
                                            default: None,
                                        }));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "RIGHT".to_string(),
                                            vec![cast_x, n],
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // MAP_FROM_ARRAYS(keys, vals) -> target-specific map construction
                            "MAP_FROM_ARRAYS" if f.args.len() == 2 => match target {
                                DialectType::Snowflake => Ok(Expression::Function(Box::new(
                                    Function::new("OBJECT_CONSTRUCT".to_string(), f.args),
                                ))),
                                DialectType::Spark | DialectType::Databricks => {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "MAP_FROM_ARRAYS".to_string(),
                                        f.args,
                                    ))))
                                }
                                _ => Ok(Expression::Function(Box::new(Function::new(
                                    "MAP".to_string(),
                                    f.args,
                                )))),
                            },
                            // LIKE(foo, 'pat') -> foo LIKE 'pat'; LIKE(foo, 'pat', '!') -> foo LIKE 'pat' ESCAPE '!'
                            // SQLite uses LIKE(pattern, string[, escape]) with args in reverse order
                            "LIKE" if f.args.len() >= 2 => {
                                let (this, pattern) = if matches!(source, DialectType::SQLite) {
                                    // SQLite: LIKE(pattern, string) -> string LIKE pattern
                                    (f.args[1].clone(), f.args[0].clone())
                                } else {
                                    // Standard: LIKE(string, pattern) -> string LIKE pattern
                                    (f.args[0].clone(), f.args[1].clone())
                                };
                                let escape = if f.args.len() >= 3 {
                                    Some(f.args[2].clone())
                                } else {
                                    None
                                };
                                Ok(Expression::Like(Box::new(crate::expressions::LikeOp {
                                    left: this,
                                    right: pattern,
                                    escape,
                                    quantifier: None,
                                })))
                            }
                            // ILIKE(foo, 'pat') -> foo ILIKE 'pat'
                            "ILIKE" if f.args.len() >= 2 => {
                                let this = f.args[0].clone();
                                let pattern = f.args[1].clone();
                                let escape = if f.args.len() >= 3 {
                                    Some(f.args[2].clone())
                                } else {
                                    None
                                };
                                Ok(Expression::ILike(Box::new(crate::expressions::LikeOp {
                                    left: this,
                                    right: pattern,
                                    escape,
                                    quantifier: None,
                                })))
                            }
                            // CHAR(n) -> CHR(n) for non-MySQL/non-TSQL targets
                            "CHAR" if f.args.len() == 1 => match target {
                                DialectType::MySQL
                                | DialectType::SingleStore
                                | DialectType::TSQL => Ok(Expression::Function(f)),
                                _ => Ok(Expression::Function(Box::new(Function::new(
                                    "CHR".to_string(),
                                    f.args,
                                )))),
                            },
                            // CONCAT(a, b) -> a || b for PostgreSQL
                            "CONCAT"
                                if f.args.len() == 2
                                    && matches!(target, DialectType::PostgreSQL)
                                    && matches!(
                                        source,
                                        DialectType::ClickHouse | DialectType::MySQL
                                    ) =>
                            {
                                let mut args = f.args;
                                let right = args.pop().unwrap();
                                let left = args.pop().unwrap();
                                Ok(Expression::DPipe(Box::new(crate::expressions::DPipe {
                                    this: Box::new(left),
                                    expression: Box::new(right),
                                    safe: None,
                                })))
                            }
                            // ARRAY_TO_STRING(arr, delim) -> target-specific
                            "ARRAY_TO_STRING" if f.args.len() >= 2 => match target {
                                DialectType::Presto | DialectType::Trino => {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "ARRAY_JOIN".to_string(),
                                        f.args,
                                    ))))
                                }
                                DialectType::TSQL => Ok(Expression::Function(Box::new(
                                    Function::new("STRING_AGG".to_string(), f.args),
                                ))),
                                _ => Ok(Expression::Function(f)),
                            },
                            // ARRAY_CONCAT / LIST_CONCAT -> target-specific
                            "ARRAY_CONCAT" | "LIST_CONCAT" if f.args.len() == 2 => match target {
                                DialectType::Spark
                                | DialectType::Databricks
                                | DialectType::Hive => Ok(Expression::Function(Box::new(
                                    Function::new("CONCAT".to_string(), f.args),
                                ))),
                                DialectType::Snowflake => Ok(Expression::Function(Box::new(
                                    Function::new("ARRAY_CAT".to_string(), f.args),
                                ))),
                                DialectType::Redshift => Ok(Expression::Function(Box::new(
                                    Function::new("ARRAY_CONCAT".to_string(), f.args),
                                ))),
                                DialectType::PostgreSQL => Ok(Expression::Function(Box::new(
                                    Function::new("ARRAY_CAT".to_string(), f.args),
                                ))),
                                DialectType::DuckDB => Ok(Expression::Function(Box::new(
                                    Function::new("LIST_CONCAT".to_string(), f.args),
                                ))),
                                DialectType::Presto | DialectType::Trino => {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "CONCAT".to_string(),
                                        f.args,
                                    ))))
                                }
                                DialectType::BigQuery => Ok(Expression::Function(Box::new(
                                    Function::new("ARRAY_CONCAT".to_string(), f.args),
                                ))),
                                _ => Ok(Expression::Function(f)),
                            },
                            // ARRAY_CONTAINS(arr, x) / HAS(arr, x) / CONTAINS(arr, x) normalization
                            "HAS" if f.args.len() == 2 => match target {
                                DialectType::Spark
                                | DialectType::Databricks
                                | DialectType::Hive => Ok(Expression::Function(Box::new(
                                    Function::new("ARRAY_CONTAINS".to_string(), f.args),
                                ))),
                                DialectType::Presto | DialectType::Trino => {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "CONTAINS".to_string(),
                                        f.args,
                                    ))))
                                }
                                _ => Ok(Expression::Function(f)),
                            },
                            // NVL(a, b, c, d) -> COALESCE(a, b, c, d) - NVL should keep all args
                            "NVL" if f.args.len() > 2 => Ok(Expression::Function(Box::new(
                                Function::new("COALESCE".to_string(), f.args),
                            ))),
                            // ISNULL(x) in MySQL -> (x IS NULL)
                            "ISNULL"
                                if f.args.len() == 1
                                    && matches!(source, DialectType::MySQL)
                                    && matches!(target, DialectType::MySQL) =>
                            {
                                let arg = f.args.into_iter().next().unwrap();
                                Ok(Expression::Paren(Box::new(crate::expressions::Paren {
                                    this: Expression::IsNull(Box::new(
                                        crate::expressions::IsNull {
                                            this: arg,
                                            not: false,
                                            postfix_form: false,
                                        },
                                    )),
                                    trailing_comments: Vec::new(),
                                })))
                            }
                            // MONTHNAME(x) -> DATE_FORMAT(x, '%M') for MySQL -> MySQL
                            "MONTHNAME"
                                if f.args.len() == 1 && matches!(target, DialectType::MySQL) =>
                            {
                                let arg = f.args.into_iter().next().unwrap();
                                Ok(Expression::Function(Box::new(Function::new(
                                    "DATE_FORMAT".to_string(),
                                    vec![arg, Expression::string("%M")],
                                ))))
                            }
                            // ClickHouse splitByString('s', x) -> DuckDB STR_SPLIT(x, 's') / Hive SPLIT(x, CONCAT('\\Q', 's', '\\E'))
                            "SPLITBYSTRING" if f.args.len() == 2 => {
                                let sep = f.args[0].clone();
                                let str_arg = f.args[1].clone();
                                match target {
                                    DialectType::DuckDB => Ok(Expression::Function(Box::new(
                                        Function::new("STR_SPLIT".to_string(), vec![str_arg, sep]),
                                    ))),
                                    DialectType::Doris => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "SPLIT_BY_STRING".to_string(),
                                            vec![str_arg, sep],
                                        ))))
                                    }
                                    DialectType::Hive
                                    | DialectType::Spark
                                    | DialectType::Databricks => {
                                        // SPLIT(x, CONCAT('\\Q', sep, '\\E'))
                                        let escaped =
                                            Expression::Function(Box::new(Function::new(
                                                "CONCAT".to_string(),
                                                vec![
                                                    Expression::string("\\Q"),
                                                    sep,
                                                    Expression::string("\\E"),
                                                ],
                                            )));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "SPLIT".to_string(),
                                            vec![str_arg, escaped],
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // ClickHouse splitByRegexp('pattern', x) -> DuckDB STR_SPLIT_REGEX(x, 'pattern')
                            "SPLITBYREGEXP" if f.args.len() == 2 => {
                                let sep = f.args[0].clone();
                                let str_arg = f.args[1].clone();
                                match target {
                                    DialectType::DuckDB => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "STR_SPLIT_REGEX".to_string(),
                                            vec![str_arg, sep],
                                        ))))
                                    }
                                    DialectType::Hive
                                    | DialectType::Spark
                                    | DialectType::Databricks => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "SPLIT".to_string(),
                                            vec![str_arg, sep],
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // ClickHouse toMonday(x) -> DATE_TRUNC('WEEK', x) / DATE_TRUNC(x, 'WEEK') for Doris
                            "TOMONDAY" => {
                                if f.args.len() == 1 {
                                    let arg = f.args.into_iter().next().unwrap();
                                    match target {
                                        DialectType::Doris => {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_TRUNC".to_string(),
                                                vec![arg, Expression::string("WEEK")],
                                            ))))
                                        }
                                        _ => Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_TRUNC".to_string(),
                                            vec![Expression::string("WEEK"), arg],
                                        )))),
                                    }
                                } else {
                                    Ok(Expression::Function(f))
                                }
                            }
                            // COLLECT_LIST with FILTER(WHERE x IS NOT NULL) for targets that need it
                            "COLLECT_LIST" if f.args.len() == 1 => match target {
                                DialectType::Spark
                                | DialectType::Databricks
                                | DialectType::Hive => Ok(Expression::Function(f)),
                                _ => Ok(Expression::Function(Box::new(Function::new(
                                    "ARRAY_AGG".to_string(),
                                    f.args,
                                )))),
                            },
                            // TO_CHAR(x) with 1 arg -> CAST(x AS STRING) for Doris
                            "TO_CHAR"
                                if f.args.len() == 1 && matches!(target, DialectType::Doris) =>
                            {
                                let arg = f.args.into_iter().next().unwrap();
                                Ok(Expression::Cast(Box::new(crate::expressions::Cast {
                                    this: arg,
                                    to: DataType::Custom {
                                        name: "STRING".to_string(),
                                    },
                                    double_colon_syntax: false,
                                    trailing_comments: Vec::new(),
                                    format: None,
                                    default: None,
                                })))
                            }
                            // DBMS_RANDOM.VALUE() -> RANDOM() for PostgreSQL
                            "DBMS_RANDOM.VALUE" if f.args.is_empty() => match target {
                                DialectType::PostgreSQL => Ok(Expression::Function(Box::new(
                                    Function::new("RANDOM".to_string(), vec![]),
                                ))),
                                _ => Ok(Expression::Function(f)),
                            },
                            // ClickHouse formatDateTime -> target-specific
                            "FORMATDATETIME" if f.args.len() >= 2 => match target {
                                DialectType::MySQL => Ok(Expression::Function(Box::new(
                                    Function::new("DATE_FORMAT".to_string(), f.args),
                                ))),
                                _ => Ok(Expression::Function(f)),
                            },
                            // REPLICATE('x', n) -> REPEAT('x', n) for non-TSQL targets
                            "REPLICATE" if f.args.len() == 2 => match target {
                                DialectType::TSQL => Ok(Expression::Function(f)),
                                _ => Ok(Expression::Function(Box::new(Function::new(
                                    "REPEAT".to_string(),
                                    f.args,
                                )))),
                            },
                            // LEN(x) -> LENGTH(x) for non-TSQL targets
                            // No CAST needed when arg is already a string literal
                            "LEN" if f.args.len() == 1 => {
                                match target {
                                    DialectType::TSQL => Ok(Expression::Function(f)),
                                    DialectType::Spark | DialectType::Databricks => {
                                        let arg = f.args.into_iter().next().unwrap();
                                        // Don't wrap string literals with CAST - they're already strings
                                        let is_string = matches!(
                                            &arg,
                                            Expression::Literal(
                                                crate::expressions::Literal::String(_)
                                            )
                                        );
                                        let final_arg = if is_string {
                                            arg
                                        } else {
                                            Expression::Cast(Box::new(Cast {
                                                this: arg,
                                                to: DataType::VarChar {
                                                    length: None,
                                                    parenthesized_length: false,
                                                },
                                                double_colon_syntax: false,
                                                trailing_comments: Vec::new(),
                                                format: None,
                                                default: None,
                                            }))
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "LENGTH".to_string(),
                                            vec![final_arg],
                                        ))))
                                    }
                                    _ => {
                                        let arg = f.args.into_iter().next().unwrap();
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "LENGTH".to_string(),
                                            vec![arg],
                                        ))))
                                    }
                                }
                            }
                            // COUNT_BIG(x) -> COUNT(x) for non-TSQL targets
                            "COUNT_BIG" if f.args.len() == 1 => match target {
                                DialectType::TSQL => Ok(Expression::Function(f)),
                                _ => Ok(Expression::Function(Box::new(Function::new(
                                    "COUNT".to_string(),
                                    f.args,
                                )))),
                            },
                            // DATEFROMPARTS(y, m, d) -> MAKE_DATE(y, m, d) for non-TSQL targets
                            "DATEFROMPARTS" if f.args.len() == 3 => match target {
                                DialectType::TSQL => Ok(Expression::Function(f)),
                                _ => Ok(Expression::Function(Box::new(Function::new(
                                    "MAKE_DATE".to_string(),
                                    f.args,
                                )))),
                            },
                            // REGEXP_LIKE(str, pattern) -> RegexpLike expression (target-specific output)
                            "REGEXP_LIKE" if f.args.len() >= 2 => {
                                let str_expr = f.args[0].clone();
                                let pattern = f.args[1].clone();
                                let flags = if f.args.len() >= 3 {
                                    Some(f.args[2].clone())
                                } else {
                                    None
                                };
                                match target {
                                    DialectType::DuckDB => {
                                        let mut new_args = vec![str_expr, pattern];
                                        if let Some(fl) = flags {
                                            new_args.push(fl);
                                        }
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "REGEXP_MATCHES".to_string(),
                                            new_args,
                                        ))))
                                    }
                                    _ => Ok(Expression::RegexpLike(Box::new(
                                        crate::expressions::RegexpFunc {
                                            this: str_expr,
                                            pattern,
                                            flags,
                                        },
                                    ))),
                                }
                            }
                            // ClickHouse arrayJoin -> UNNEST for PostgreSQL
                            "ARRAYJOIN" if f.args.len() == 1 => match target {
                                DialectType::PostgreSQL => Ok(Expression::Function(Box::new(
                                    Function::new("UNNEST".to_string(), f.args),
                                ))),
                                _ => Ok(Expression::Function(f)),
                            },
                            // DATETIMEFROMPARTS(y, m, d, h, mi, s, ms) -> MAKE_TIMESTAMP / TIMESTAMP_FROM_PARTS
                            "DATETIMEFROMPARTS" if f.args.len() == 7 => {
                                match target {
                                    DialectType::TSQL => Ok(Expression::Function(f)),
                                    DialectType::DuckDB => {
                                        // MAKE_TIMESTAMP(y, m, d, h, mi, s + (ms / 1000.0))
                                        let mut args = f.args;
                                        let ms = args.pop().unwrap();
                                        let s = args.pop().unwrap();
                                        // s + (ms / 1000.0)
                                        let ms_frac = Expression::Div(Box::new(BinaryOp::new(
                                            ms,
                                            Expression::Literal(
                                                crate::expressions::Literal::Number(
                                                    "1000.0".to_string(),
                                                ),
                                            ),
                                        )));
                                        let s_with_ms = Expression::Add(Box::new(BinaryOp::new(
                                            s,
                                            Expression::Paren(Box::new(Paren {
                                                this: ms_frac,
                                                trailing_comments: vec![],
                                            })),
                                        )));
                                        args.push(s_with_ms);
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "MAKE_TIMESTAMP".to_string(),
                                            args,
                                        ))))
                                    }
                                    DialectType::Snowflake => {
                                        // TIMESTAMP_FROM_PARTS(y, m, d, h, mi, s, ms * 1000000)
                                        let mut args = f.args;
                                        let ms = args.pop().unwrap();
                                        // ms * 1000000
                                        let ns = Expression::Mul(Box::new(BinaryOp::new(
                                            ms,
                                            Expression::number(1000000),
                                        )));
                                        args.push(ns);
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "TIMESTAMP_FROM_PARTS".to_string(),
                                            args,
                                        ))))
                                    }
                                    _ => {
                                        // Default: keep function name for other targets
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATETIMEFROMPARTS".to_string(),
                                            f.args,
                                        ))))
                                    }
                                }
                            }
                            // CONVERT(type, expr [, style]) -> CAST(expr AS type) for non-TSQL targets
                            // TRY_CONVERT(type, expr [, style]) -> TRY_CAST(expr AS type) for non-TSQL targets
                            "CONVERT" | "TRY_CONVERT" if f.args.len() >= 2 => {
                                let is_try = name == "TRY_CONVERT";
                                let type_expr = f.args[0].clone();
                                let value_expr = f.args[1].clone();
                                let style = if f.args.len() >= 3 {
                                    Some(&f.args[2])
                                } else {
                                    None
                                };

                                // For TSQL->TSQL, normalize types and preserve CONVERT/TRY_CONVERT
                                if matches!(target, DialectType::TSQL) {
                                    let normalized_type = match &type_expr {
                                        Expression::DataType(dt) => {
                                            let new_dt = match dt {
                                                DataType::Int { .. } => DataType::Custom {
                                                    name: "INTEGER".to_string(),
                                                },
                                                _ => dt.clone(),
                                            };
                                            Expression::DataType(new_dt)
                                        }
                                        Expression::Identifier(id) => {
                                            let upper = id.name.to_uppercase();
                                            let normalized = match upper.as_str() {
                                                "INT" => "INTEGER",
                                                _ => &upper,
                                            };
                                            Expression::Identifier(
                                                crate::expressions::Identifier::new(normalized),
                                            )
                                        }
                                        Expression::Column(col) => {
                                            let upper = col.name.name.to_uppercase();
                                            let normalized = match upper.as_str() {
                                                "INT" => "INTEGER",
                                                _ => &upper,
                                            };
                                            Expression::Identifier(
                                                crate::expressions::Identifier::new(normalized),
                                            )
                                        }
                                        _ => type_expr.clone(),
                                    };
                                    let func_name = if is_try { "TRY_CONVERT" } else { "CONVERT" };
                                    let mut new_args = vec![normalized_type, value_expr];
                                    if let Some(s) = style {
                                        new_args.push(s.clone());
                                    }
                                    return Ok(Expression::Function(Box::new(Function::new(
                                        func_name.to_string(),
                                        new_args,
                                    ))));
                                }

                                // For other targets: CONVERT(type, expr) -> CAST(expr AS type)
                                fn expr_to_datatype(e: &Expression) -> Option<DataType> {
                                    match e {
                                        Expression::DataType(dt) => {
                                            // Convert NVARCHAR/NCHAR Custom types to standard VarChar/Char
                                            match dt {
                                                DataType::Custom { name }
                                                    if name.starts_with("NVARCHAR(")
                                                        || name.starts_with("NCHAR(") =>
                                                {
                                                    // Extract the length from "NVARCHAR(200)" or "NCHAR(40)"
                                                    let inner = &name[name.find('(').unwrap() + 1
                                                        ..name.len() - 1];
                                                    if inner.eq_ignore_ascii_case("MAX") {
                                                        Some(DataType::Text)
                                                    } else if let Ok(len) = inner.parse::<u32>() {
                                                        if name.starts_with("NCHAR") {
                                                            Some(DataType::Char {
                                                                length: Some(len),
                                                            })
                                                        } else {
                                                            Some(DataType::VarChar {
                                                                length: Some(len),
                                                                parenthesized_length: false,
                                                            })
                                                        }
                                                    } else {
                                                        Some(dt.clone())
                                                    }
                                                }
                                                DataType::Custom { name } if name == "NVARCHAR" => {
                                                    Some(DataType::VarChar {
                                                        length: None,
                                                        parenthesized_length: false,
                                                    })
                                                }
                                                DataType::Custom { name } if name == "NCHAR" => {
                                                    Some(DataType::Char { length: None })
                                                }
                                                DataType::Custom { name }
                                                    if name == "NVARCHAR(MAX)"
                                                        || name == "VARCHAR(MAX)" =>
                                                {
                                                    Some(DataType::Text)
                                                }
                                                _ => Some(dt.clone()),
                                            }
                                        }
                                        Expression::Identifier(id) => {
                                            let name = id.name.to_uppercase();
                                            match name.as_str() {
                                                "INT" | "INTEGER" => Some(DataType::Int {
                                                    length: None,
                                                    integer_spelling: false,
                                                }),
                                                "BIGINT" => Some(DataType::BigInt { length: None }),
                                                "SMALLINT" => {
                                                    Some(DataType::SmallInt { length: None })
                                                }
                                                "TINYINT" => {
                                                    Some(DataType::TinyInt { length: None })
                                                }
                                                "FLOAT" => Some(DataType::Float {
                                                    precision: None,
                                                    scale: None,
                                                    real_spelling: false,
                                                }),
                                                "REAL" => Some(DataType::Float {
                                                    precision: None,
                                                    scale: None,
                                                    real_spelling: true,
                                                }),
                                                "DATETIME" | "DATETIME2" => {
                                                    Some(DataType::Timestamp {
                                                        timezone: false,
                                                        precision: None,
                                                    })
                                                }
                                                "DATE" => Some(DataType::Date),
                                                "BIT" => Some(DataType::Boolean),
                                                "TEXT" => Some(DataType::Text),
                                                "NUMERIC" => Some(DataType::Decimal {
                                                    precision: None,
                                                    scale: None,
                                                }),
                                                "MONEY" => Some(DataType::Decimal {
                                                    precision: Some(15),
                                                    scale: Some(4),
                                                }),
                                                "SMALLMONEY" => Some(DataType::Decimal {
                                                    precision: Some(6),
                                                    scale: Some(4),
                                                }),
                                                "VARCHAR" => Some(DataType::VarChar {
                                                    length: None,
                                                    parenthesized_length: false,
                                                }),
                                                "NVARCHAR" => Some(DataType::VarChar {
                                                    length: None,
                                                    parenthesized_length: false,
                                                }),
                                                "CHAR" => Some(DataType::Char { length: None }),
                                                "NCHAR" => Some(DataType::Char { length: None }),
                                                _ => Some(DataType::Custom { name }),
                                            }
                                        }
                                        Expression::Column(col) => {
                                            let name = col.name.name.to_uppercase();
                                            match name.as_str() {
                                                "INT" | "INTEGER" => Some(DataType::Int {
                                                    length: None,
                                                    integer_spelling: false,
                                                }),
                                                "BIGINT" => Some(DataType::BigInt { length: None }),
                                                "FLOAT" => Some(DataType::Float {
                                                    precision: None,
                                                    scale: None,
                                                    real_spelling: false,
                                                }),
                                                "DATETIME" | "DATETIME2" => {
                                                    Some(DataType::Timestamp {
                                                        timezone: false,
                                                        precision: None,
                                                    })
                                                }
                                                "DATE" => Some(DataType::Date),
                                                "NUMERIC" => Some(DataType::Decimal {
                                                    precision: None,
                                                    scale: None,
                                                }),
                                                "VARCHAR" => Some(DataType::VarChar {
                                                    length: None,
                                                    parenthesized_length: false,
                                                }),
                                                "NVARCHAR" => Some(DataType::VarChar {
                                                    length: None,
                                                    parenthesized_length: false,
                                                }),
                                                "CHAR" => Some(DataType::Char { length: None }),
                                                "NCHAR" => Some(DataType::Char { length: None }),
                                                _ => Some(DataType::Custom { name }),
                                            }
                                        }
                                        // NVARCHAR(200) parsed as Function("NVARCHAR", [200])
                                        Expression::Function(f) => {
                                            let fname = f.name.to_uppercase();
                                            match fname.as_str() {
                                                "VARCHAR" | "NVARCHAR" => {
                                                    let len = f.args.first().and_then(|a| {
                                                        if let Expression::Literal(
                                                            crate::expressions::Literal::Number(n),
                                                        ) = a
                                                        {
                                                            n.parse::<u32>().ok()
                                                        } else if let Expression::Identifier(id) = a
                                                        {
                                                            if id.name.eq_ignore_ascii_case("MAX") {
                                                                None
                                                            } else {
                                                                None
                                                            }
                                                        } else {
                                                            None
                                                        }
                                                    });
                                                    // Check for VARCHAR(MAX) -> TEXT
                                                    let is_max = f.args.first().map_or(false, |a| {
                                                        matches!(a, Expression::Identifier(id) if id.name.eq_ignore_ascii_case("MAX"))
                                                        || matches!(a, Expression::Column(col) if col.name.name.eq_ignore_ascii_case("MAX"))
                                                    });
                                                    if is_max {
                                                        Some(DataType::Text)
                                                    } else {
                                                        Some(DataType::VarChar {
                                                            length: len,
                                                            parenthesized_length: false,
                                                        })
                                                    }
                                                }
                                                "NCHAR" | "CHAR" => {
                                                    let len = f.args.first().and_then(|a| {
                                                        if let Expression::Literal(
                                                            crate::expressions::Literal::Number(n),
                                                        ) = a
                                                        {
                                                            n.parse::<u32>().ok()
                                                        } else {
                                                            None
                                                        }
                                                    });
                                                    Some(DataType::Char { length: len })
                                                }
                                                "NUMERIC" | "DECIMAL" => {
                                                    let precision = f.args.first().and_then(|a| {
                                                        if let Expression::Literal(
                                                            crate::expressions::Literal::Number(n),
                                                        ) = a
                                                        {
                                                            n.parse::<u32>().ok()
                                                        } else {
                                                            None
                                                        }
                                                    });
                                                    let scale = f.args.get(1).and_then(|a| {
                                                        if let Expression::Literal(
                                                            crate::expressions::Literal::Number(n),
                                                        ) = a
                                                        {
                                                            n.parse::<u32>().ok()
                                                        } else {
                                                            None
                                                        }
                                                    });
                                                    Some(DataType::Decimal { precision, scale })
                                                }
                                                _ => None,
                                            }
                                        }
                                        _ => None,
                                    }
                                }

                                if let Some(mut dt) = expr_to_datatype(&type_expr) {
                                    // For TSQL source: VARCHAR/CHAR without length defaults to 30
                                    let is_tsql_source =
                                        matches!(source, DialectType::TSQL | DialectType::Fabric);
                                    if is_tsql_source {
                                        match &dt {
                                            DataType::VarChar { length: None, .. } => {
                                                dt = DataType::VarChar {
                                                    length: Some(30),
                                                    parenthesized_length: false,
                                                };
                                            }
                                            DataType::Char { length: None } => {
                                                dt = DataType::Char { length: Some(30) };
                                            }
                                            _ => {}
                                        }
                                    }

                                    // Determine if this is a string type
                                    let is_string_type = matches!(
                                        dt,
                                        DataType::VarChar { .. }
                                            | DataType::Char { .. }
                                            | DataType::Text
                                    ) || matches!(&dt, DataType::Custom { name } if name == "NVARCHAR" || name == "NCHAR"
                                            || name.starts_with("NVARCHAR(") || name.starts_with("NCHAR(")
                                            || name.starts_with("VARCHAR(") || name == "VARCHAR"
                                            || name == "STRING");

                                    // Determine if this is a date/time type
                                    let is_datetime_type = matches!(
                                        dt,
                                        DataType::Timestamp { .. } | DataType::Date
                                    ) || matches!(&dt, DataType::Custom { name } if name == "DATETIME"
                                            || name == "DATETIME2" || name == "SMALLDATETIME");

                                    // Check for date conversion with style
                                    if style.is_some() {
                                        let style_num = style.and_then(|s| {
                                            if let Expression::Literal(
                                                crate::expressions::Literal::Number(n),
                                            ) = s
                                            {
                                                n.parse::<u32>().ok()
                                            } else {
                                                None
                                            }
                                        });

                                        // TSQL CONVERT date styles (Java format)
                                        let format_str = style_num.and_then(|n| match n {
                                            101 => Some("MM/dd/yyyy"),
                                            102 => Some("yyyy.MM.dd"),
                                            103 => Some("dd/MM/yyyy"),
                                            104 => Some("dd.MM.yyyy"),
                                            105 => Some("dd-MM-yyyy"),
                                            108 => Some("HH:mm:ss"),
                                            110 => Some("MM-dd-yyyy"),
                                            112 => Some("yyyyMMdd"),
                                            120 | 20 => Some("yyyy-MM-dd HH:mm:ss"),
                                            121 | 21 => Some("yyyy-MM-dd HH:mm:ss.SSSSSS"),
                                            126 | 127 => Some("yyyy-MM-dd'T'HH:mm:ss.SSS"),
                                            _ => None,
                                        });

                                        // Non-string, non-datetime types with style: just CAST, ignore the style
                                        if !is_string_type && !is_datetime_type {
                                            let cast_expr = if is_try {
                                                Expression::TryCast(Box::new(
                                                    crate::expressions::Cast {
                                                        this: value_expr,
                                                        to: dt,
                                                        trailing_comments: Vec::new(),
                                                        double_colon_syntax: false,
                                                        format: None,
                                                        default: None,
                                                    },
                                                ))
                                            } else {
                                                Expression::Cast(Box::new(
                                                    crate::expressions::Cast {
                                                        this: value_expr,
                                                        to: dt,
                                                        trailing_comments: Vec::new(),
                                                        double_colon_syntax: false,
                                                        format: None,
                                                        default: None,
                                                    },
                                                ))
                                            };
                                            return Ok(cast_expr);
                                        }

                                        if let Some(java_fmt) = format_str {
                                            let c_fmt = java_fmt
                                                .replace("yyyy", "%Y")
                                                .replace("MM", "%m")
                                                .replace("dd", "%d")
                                                .replace("HH", "%H")
                                                .replace("mm", "%M")
                                                .replace("ss", "%S")
                                                .replace("SSSSSS", "%f")
                                                .replace("SSS", "%f")
                                                .replace("'T'", "T");

                                            // For datetime target types: style is the INPUT format for parsing strings -> dates
                                            if is_datetime_type {
                                                match target {
                                                    DialectType::DuckDB => {
                                                        return Ok(Expression::Function(Box::new(
                                                            Function::new(
                                                                "STRPTIME".to_string(),
                                                                vec![
                                                                    value_expr,
                                                                    Expression::string(&c_fmt),
                                                                ],
                                                            ),
                                                        )));
                                                    }
                                                    DialectType::Spark
                                                    | DialectType::Databricks => {
                                                        // CONVERT(DATETIME, x, style) -> TO_TIMESTAMP(x, fmt)
                                                        // CONVERT(DATE, x, style) -> TO_DATE(x, fmt)
                                                        let func_name =
                                                            if matches!(dt, DataType::Date) {
                                                                "TO_DATE"
                                                            } else {
                                                                "TO_TIMESTAMP"
                                                            };
                                                        return Ok(Expression::Function(Box::new(
                                                            Function::new(
                                                                func_name.to_string(),
                                                                vec![
                                                                    value_expr,
                                                                    Expression::string(java_fmt),
                                                                ],
                                                            ),
                                                        )));
                                                    }
                                                    DialectType::Hive => {
                                                        return Ok(Expression::Function(Box::new(
                                                            Function::new(
                                                                "TO_TIMESTAMP".to_string(),
                                                                vec![
                                                                    value_expr,
                                                                    Expression::string(java_fmt),
                                                                ],
                                                            ),
                                                        )));
                                                    }
                                                    _ => {
                                                        return Ok(Expression::Cast(Box::new(
                                                            crate::expressions::Cast {
                                                                this: value_expr,
                                                                to: dt,
                                                                trailing_comments: Vec::new(),
                                                                double_colon_syntax: false,
                                                                format: None,
                                                                default: None,
                                                            },
                                                        )));
                                                    }
                                                }
                                            }

                                            // For string target types: style is the OUTPUT format for dates -> strings
                                            match target {
                                                DialectType::DuckDB => Ok(Expression::Function(
                                                    Box::new(Function::new(
                                                        "STRPTIME".to_string(),
                                                        vec![
                                                            value_expr,
                                                            Expression::string(&c_fmt),
                                                        ],
                                                    )),
                                                )),
                                                DialectType::Spark | DialectType::Databricks => {
                                                    // For string target types with style: CAST(DATE_FORMAT(x, fmt) AS type)
                                                    // Determine the target string type
                                                    let string_dt = match &dt {
                                                        DataType::VarChar {
                                                            length: Some(l),
                                                            ..
                                                        } => DataType::VarChar {
                                                            length: Some(*l),
                                                            parenthesized_length: false,
                                                        },
                                                        DataType::Text => DataType::Custom {
                                                            name: "STRING".to_string(),
                                                        },
                                                        _ => DataType::Custom {
                                                            name: "STRING".to_string(),
                                                        },
                                                    };
                                                    let date_format_expr = Expression::Function(
                                                        Box::new(Function::new(
                                                            "DATE_FORMAT".to_string(),
                                                            vec![
                                                                value_expr,
                                                                Expression::string(java_fmt),
                                                            ],
                                                        )),
                                                    );
                                                    let cast_expr = if is_try {
                                                        Expression::TryCast(Box::new(
                                                            crate::expressions::Cast {
                                                                this: date_format_expr,
                                                                to: string_dt,
                                                                trailing_comments: Vec::new(),
                                                                double_colon_syntax: false,
                                                                format: None,
                                                                default: None,
                                                            },
                                                        ))
                                                    } else {
                                                        Expression::Cast(Box::new(
                                                            crate::expressions::Cast {
                                                                this: date_format_expr,
                                                                to: string_dt,
                                                                trailing_comments: Vec::new(),
                                                                double_colon_syntax: false,
                                                                format: None,
                                                                default: None,
                                                            },
                                                        ))
                                                    };
                                                    Ok(cast_expr)
                                                }
                                                DialectType::MySQL | DialectType::SingleStore => {
                                                    // For MySQL: CAST(DATE_FORMAT(x, mysql_fmt) AS CHAR(n))
                                                    let mysql_fmt = java_fmt
                                                        .replace("yyyy", "%Y")
                                                        .replace("MM", "%m")
                                                        .replace("dd", "%d")
                                                        .replace("HH:mm:ss.SSSSSS", "%T")
                                                        .replace("HH:mm:ss", "%T")
                                                        .replace("HH", "%H")
                                                        .replace("mm", "%i")
                                                        .replace("ss", "%S");
                                                    let date_format_expr = Expression::Function(
                                                        Box::new(Function::new(
                                                            "DATE_FORMAT".to_string(),
                                                            vec![
                                                                value_expr,
                                                                Expression::string(&mysql_fmt),
                                                            ],
                                                        )),
                                                    );
                                                    // MySQL uses CHAR for string casts
                                                    let mysql_dt = match &dt {
                                                        DataType::VarChar { length, .. } => {
                                                            DataType::Char { length: *length }
                                                        }
                                                        _ => dt,
                                                    };
                                                    Ok(Expression::Cast(Box::new(
                                                        crate::expressions::Cast {
                                                            this: date_format_expr,
                                                            to: mysql_dt,
                                                            trailing_comments: Vec::new(),
                                                            double_colon_syntax: false,
                                                            format: None,
                                                            default: None,
                                                        },
                                                    )))
                                                }
                                                DialectType::Hive => {
                                                    let func_name = "TO_TIMESTAMP";
                                                    Ok(Expression::Function(Box::new(
                                                        Function::new(
                                                            func_name.to_string(),
                                                            vec![
                                                                value_expr,
                                                                Expression::string(java_fmt),
                                                            ],
                                                        ),
                                                    )))
                                                }
                                                _ => Ok(Expression::Cast(Box::new(
                                                    crate::expressions::Cast {
                                                        this: value_expr,
                                                        to: dt,
                                                        trailing_comments: Vec::new(),
                                                        double_colon_syntax: false,
                                                        format: None,
                                                        default: None,
                                                    },
                                                ))),
                                            }
                                        } else {
                                            // Unknown style, just CAST
                                            let cast_expr = if is_try {
                                                Expression::TryCast(Box::new(
                                                    crate::expressions::Cast {
                                                        this: value_expr,
                                                        to: dt,
                                                        trailing_comments: Vec::new(),
                                                        double_colon_syntax: false,
                                                        format: None,
                                                        default: None,
                                                    },
                                                ))
                                            } else {
                                                Expression::Cast(Box::new(
                                                    crate::expressions::Cast {
                                                        this: value_expr,
                                                        to: dt,
                                                        trailing_comments: Vec::new(),
                                                        double_colon_syntax: false,
                                                        format: None,
                                                        default: None,
                                                    },
                                                ))
                                            };
                                            Ok(cast_expr)
                                        }
                                    } else {
                                        // No style - simple CAST
                                        let final_dt = if matches!(
                                            target,
                                            DialectType::MySQL | DialectType::SingleStore
                                        ) {
                                            match &dt {
                                                DataType::Int { .. }
                                                | DataType::BigInt { .. }
                                                | DataType::SmallInt { .. }
                                                | DataType::TinyInt { .. } => DataType::Custom {
                                                    name: "SIGNED".to_string(),
                                                },
                                                DataType::VarChar { length, .. } => {
                                                    DataType::Char { length: *length }
                                                }
                                                _ => dt,
                                            }
                                        } else {
                                            dt
                                        };
                                        let cast_expr = if is_try {
                                            Expression::TryCast(Box::new(
                                                crate::expressions::Cast {
                                                    this: value_expr,
                                                    to: final_dt,
                                                    trailing_comments: Vec::new(),
                                                    double_colon_syntax: false,
                                                    format: None,
                                                    default: None,
                                                },
                                            ))
                                        } else {
                                            Expression::Cast(Box::new(crate::expressions::Cast {
                                                this: value_expr,
                                                to: final_dt,
                                                trailing_comments: Vec::new(),
                                                double_colon_syntax: false,
                                                format: None,
                                                default: None,
                                            }))
                                        };
                                        Ok(cast_expr)
                                    }
                                } else {
                                    // Can't convert type expression - keep as CONVERT/TRY_CONVERT function
                                    Ok(Expression::Function(f))
                                }
                            }
                            // STRFTIME(val, fmt) from DuckDB / STRFTIME(fmt, val) from SQLite -> target-specific
                            "STRFTIME" if f.args.len() == 2 => {
                                // SQLite uses STRFTIME(fmt, val); DuckDB uses STRFTIME(val, fmt)
                                let (val, fmt_expr) = if matches!(source, DialectType::SQLite) {
                                    // SQLite: args[0] = format, args[1] = value
                                    (f.args[1].clone(), &f.args[0])
                                } else {
                                    // DuckDB and others: args[0] = value, args[1] = format
                                    (f.args[0].clone(), &f.args[1])
                                };

                                // Helper to convert C-style format to Java-style
                                fn c_to_java_format(fmt: &str) -> String {
                                    fmt.replace("%Y", "yyyy")
                                        .replace("%m", "MM")
                                        .replace("%d", "dd")
                                        .replace("%H", "HH")
                                        .replace("%M", "mm")
                                        .replace("%S", "ss")
                                        .replace("%f", "SSSSSS")
                                        .replace("%y", "yy")
                                        .replace("%-m", "M")
                                        .replace("%-d", "d")
                                        .replace("%-H", "H")
                                        .replace("%-I", "h")
                                        .replace("%I", "hh")
                                        .replace("%p", "a")
                                        .replace("%j", "DDD")
                                        .replace("%a", "EEE")
                                        .replace("%b", "MMM")
                                        .replace("%F", "yyyy-MM-dd")
                                        .replace("%T", "HH:mm:ss")
                                }

                                // Helper: recursively convert format strings within expressions (handles CONCAT)
                                fn convert_fmt_expr(
                                    expr: &Expression,
                                    converter: &dyn Fn(&str) -> String,
                                ) -> Expression {
                                    match expr {
                                        Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) => Expression::string(&converter(s)),
                                        Expression::Function(func)
                                            if func.name.eq_ignore_ascii_case("CONCAT") =>
                                        {
                                            let new_args: Vec<Expression> = func
                                                .args
                                                .iter()
                                                .map(|a| convert_fmt_expr(a, converter))
                                                .collect();
                                            Expression::Function(Box::new(Function::new(
                                                "CONCAT".to_string(),
                                                new_args,
                                            )))
                                        }
                                        other => other.clone(),
                                    }
                                }

                                match target {
                                    DialectType::DuckDB => {
                                        if matches!(source, DialectType::SQLite) {
                                            // SQLite STRFTIME(fmt, val) -> DuckDB STRFTIME(CAST(val AS TIMESTAMP), fmt)
                                            let cast_val = Expression::Cast(Box::new(Cast {
                                                this: val,
                                                to: crate::expressions::DataType::Timestamp {
                                                    precision: None,
                                                    timezone: false,
                                                },
                                                trailing_comments: Vec::new(),
                                                double_colon_syntax: false,
                                                format: None,
                                                default: None,
                                            }));
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "STRFTIME".to_string(),
                                                vec![cast_val, fmt_expr.clone()],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(f))
                                        }
                                    }
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => {
                                        // STRFTIME(val, fmt) -> DATE_FORMAT(val, java_fmt)
                                        let converted_fmt =
                                            convert_fmt_expr(fmt_expr, &c_to_java_format);
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_FORMAT".to_string(),
                                            vec![val, converted_fmt],
                                        ))))
                                    }
                                    DialectType::TSQL | DialectType::Fabric => {
                                        // STRFTIME(val, fmt) -> FORMAT(val, java_fmt)
                                        let converted_fmt =
                                            convert_fmt_expr(fmt_expr, &c_to_java_format);
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "FORMAT".to_string(),
                                            vec![val, converted_fmt],
                                        ))))
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        // STRFTIME(val, fmt) -> DATE_FORMAT(val, presto_fmt) (convert DuckDB format to Presto)
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = fmt_expr
                                        {
                                            let presto_fmt = duckdb_to_presto_format(s);
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_FORMAT".to_string(),
                                                vec![val, Expression::string(&presto_fmt)],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_FORMAT".to_string(),
                                                vec![val, fmt_expr.clone()],
                                            ))))
                                        }
                                    }
                                    DialectType::BigQuery => {
                                        // STRFTIME(val, fmt) -> FORMAT_DATE(bq_fmt, val) - note reversed arg order
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = fmt_expr
                                        {
                                            let bq_fmt = duckdb_to_bigquery_format(s);
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "FORMAT_DATE".to_string(),
                                                vec![Expression::string(&bq_fmt), val],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "FORMAT_DATE".to_string(),
                                                vec![fmt_expr.clone(), val],
                                            ))))
                                        }
                                    }
                                    DialectType::PostgreSQL | DialectType::Redshift => {
                                        // STRFTIME(val, fmt) -> TO_CHAR(val, pg_fmt)
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = fmt_expr
                                        {
                                            let pg_fmt = s
                                                .replace("%Y", "YYYY")
                                                .replace("%m", "MM")
                                                .replace("%d", "DD")
                                                .replace("%H", "HH24")
                                                .replace("%M", "MI")
                                                .replace("%S", "SS")
                                                .replace("%y", "YY")
                                                .replace("%-m", "FMMM")
                                                .replace("%-d", "FMDD")
                                                .replace("%-H", "FMHH24")
                                                .replace("%-I", "FMHH12")
                                                .replace("%p", "AM")
                                                .replace("%F", "YYYY-MM-DD")
                                                .replace("%T", "HH24:MI:SS");
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "TO_CHAR".to_string(),
                                                vec![val, Expression::string(&pg_fmt)],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "TO_CHAR".to_string(),
                                                vec![val, fmt_expr.clone()],
                                            ))))
                                        }
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // STRPTIME(val, fmt) from DuckDB -> target-specific date parse function
                            "STRPTIME" if f.args.len() == 2 => {
                                let val = f.args[0].clone();
                                let fmt_expr = &f.args[1];

                                fn c_to_java_format_parse(fmt: &str) -> String {
                                    fmt.replace("%Y", "yyyy")
                                        .replace("%m", "MM")
                                        .replace("%d", "dd")
                                        .replace("%H", "HH")
                                        .replace("%M", "mm")
                                        .replace("%S", "ss")
                                        .replace("%f", "SSSSSS")
                                        .replace("%y", "yy")
                                        .replace("%-m", "M")
                                        .replace("%-d", "d")
                                        .replace("%-H", "H")
                                        .replace("%-I", "h")
                                        .replace("%I", "hh")
                                        .replace("%p", "a")
                                        .replace("%F", "yyyy-MM-dd")
                                        .replace("%T", "HH:mm:ss")
                                }

                                match target {
                                    DialectType::DuckDB => Ok(Expression::Function(f)),
                                    DialectType::Spark | DialectType::Databricks => {
                                        // STRPTIME(val, fmt) -> TO_TIMESTAMP(val, java_fmt)
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = fmt_expr
                                        {
                                            let java_fmt = c_to_java_format_parse(s);
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "TO_TIMESTAMP".to_string(),
                                                vec![val, Expression::string(&java_fmt)],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "TO_TIMESTAMP".to_string(),
                                                vec![val, fmt_expr.clone()],
                                            ))))
                                        }
                                    }
                                    DialectType::Hive => {
                                        // STRPTIME(val, fmt) -> CAST(FROM_UNIXTIME(UNIX_TIMESTAMP(val, java_fmt)) AS TIMESTAMP)
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = fmt_expr
                                        {
                                            let java_fmt = c_to_java_format_parse(s);
                                            let unix_ts =
                                                Expression::Function(Box::new(Function::new(
                                                    "UNIX_TIMESTAMP".to_string(),
                                                    vec![val, Expression::string(&java_fmt)],
                                                )));
                                            let from_unix =
                                                Expression::Function(Box::new(Function::new(
                                                    "FROM_UNIXTIME".to_string(),
                                                    vec![unix_ts],
                                                )));
                                            Ok(Expression::Cast(Box::new(
                                                crate::expressions::Cast {
                                                    this: from_unix,
                                                    to: DataType::Timestamp {
                                                        timezone: false,
                                                        precision: None,
                                                    },
                                                    trailing_comments: Vec::new(),
                                                    double_colon_syntax: false,
                                                    format: None,
                                                    default: None,
                                                },
                                            )))
                                        } else {
                                            Ok(Expression::Function(f))
                                        }
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        // STRPTIME(val, fmt) -> DATE_PARSE(val, presto_fmt) (convert DuckDB format to Presto)
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = fmt_expr
                                        {
                                            let presto_fmt = duckdb_to_presto_format(s);
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_PARSE".to_string(),
                                                vec![val, Expression::string(&presto_fmt)],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_PARSE".to_string(),
                                                vec![val, fmt_expr.clone()],
                                            ))))
                                        }
                                    }
                                    DialectType::BigQuery => {
                                        // STRPTIME(val, fmt) -> PARSE_TIMESTAMP(bq_fmt, val) - note reversed arg order
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = fmt_expr
                                        {
                                            let bq_fmt = duckdb_to_bigquery_format(s);
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "PARSE_TIMESTAMP".to_string(),
                                                vec![Expression::string(&bq_fmt), val],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "PARSE_TIMESTAMP".to_string(),
                                                vec![fmt_expr.clone(), val],
                                            ))))
                                        }
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // DATE_FORMAT(val, fmt) from Presto source (C-style format) -> target-specific
                            "DATE_FORMAT"
                                if f.args.len() >= 2
                                    && matches!(
                                        source,
                                        DialectType::Presto
                                            | DialectType::Trino
                                            | DialectType::Athena
                                    ) =>
                            {
                                let val = f.args[0].clone();
                                let fmt_expr = &f.args[1];

                                match target {
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        // Presto -> Presto: normalize format (e.g., %H:%i:%S -> %T)
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = fmt_expr
                                        {
                                            let normalized = crate::dialects::presto::PrestoDialect::normalize_presto_format(s);
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_FORMAT".to_string(),
                                                vec![val, Expression::string(&normalized)],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(f))
                                        }
                                    }
                                    DialectType::Hive
                                    | DialectType::Spark
                                    | DialectType::Databricks => {
                                        // Convert Presto C-style to Java-style format
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = fmt_expr
                                        {
                                            let java_fmt = crate::dialects::presto::PrestoDialect::presto_to_java_format(s);
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_FORMAT".to_string(),
                                                vec![val, Expression::string(&java_fmt)],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(f))
                                        }
                                    }
                                    DialectType::DuckDB => {
                                        // Convert to STRFTIME(val, duckdb_fmt)
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = fmt_expr
                                        {
                                            let duckdb_fmt = crate::dialects::presto::PrestoDialect::presto_to_duckdb_format(s);
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "STRFTIME".to_string(),
                                                vec![val, Expression::string(&duckdb_fmt)],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "STRFTIME".to_string(),
                                                vec![val, fmt_expr.clone()],
                                            ))))
                                        }
                                    }
                                    DialectType::BigQuery => {
                                        // Convert to FORMAT_DATE(bq_fmt, val) - reversed args
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = fmt_expr
                                        {
                                            let bq_fmt = crate::dialects::presto::PrestoDialect::presto_to_bigquery_format(s);
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "FORMAT_DATE".to_string(),
                                                vec![Expression::string(&bq_fmt), val],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "FORMAT_DATE".to_string(),
                                                vec![fmt_expr.clone(), val],
                                            ))))
                                        }
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // DATE_PARSE(val, fmt) from Presto source -> target-specific parse function
                            "DATE_PARSE"
                                if f.args.len() >= 2
                                    && matches!(
                                        source,
                                        DialectType::Presto
                                            | DialectType::Trino
                                            | DialectType::Athena
                                    ) =>
                            {
                                let val = f.args[0].clone();
                                let fmt_expr = &f.args[1];

                                match target {
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        // Presto -> Presto: normalize format
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = fmt_expr
                                        {
                                            let normalized = crate::dialects::presto::PrestoDialect::normalize_presto_format(s);
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_PARSE".to_string(),
                                                vec![val, Expression::string(&normalized)],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(f))
                                        }
                                    }
                                    DialectType::Hive => {
                                        // Presto -> Hive: if default format, just CAST(x AS TIMESTAMP)
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = fmt_expr
                                        {
                                            if crate::dialects::presto::PrestoDialect::is_default_timestamp_format(s)
                                               || crate::dialects::presto::PrestoDialect::is_default_date_format(s) {
                                                Ok(Expression::Cast(Box::new(crate::expressions::Cast {
                                                    this: val,
                                                    to: DataType::Timestamp { timezone: false, precision: None },
                                                    trailing_comments: Vec::new(),
                                                    double_colon_syntax: false,
                                                    format: None,
                                                    default: None,
                                                })))
                                            } else {
                                                let java_fmt = crate::dialects::presto::PrestoDialect::presto_to_java_format(s);
                                                Ok(Expression::Function(Box::new(Function::new(
                                                    "TO_TIMESTAMP".to_string(),
                                                    vec![val, Expression::string(&java_fmt)],
                                                ))))
                                            }
                                        } else {
                                            Ok(Expression::Function(f))
                                        }
                                    }
                                    DialectType::Spark | DialectType::Databricks => {
                                        // Presto -> Spark: TO_TIMESTAMP(val, java_fmt)
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = fmt_expr
                                        {
                                            let java_fmt = crate::dialects::presto::PrestoDialect::presto_to_java_format(s);
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "TO_TIMESTAMP".to_string(),
                                                vec![val, Expression::string(&java_fmt)],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(f))
                                        }
                                    }
                                    DialectType::DuckDB => {
                                        // Presto -> DuckDB: STRPTIME(val, duckdb_fmt)
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = fmt_expr
                                        {
                                            let duckdb_fmt = crate::dialects::presto::PrestoDialect::presto_to_duckdb_format(s);
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "STRPTIME".to_string(),
                                                vec![val, Expression::string(&duckdb_fmt)],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "STRPTIME".to_string(),
                                                vec![val, fmt_expr.clone()],
                                            ))))
                                        }
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // FROM_BASE64(x) / TO_BASE64(x) from Presto -> Hive-specific renames
                            "FROM_BASE64"
                                if f.args.len() == 1 && matches!(target, DialectType::Hive) =>
                            {
                                Ok(Expression::Function(Box::new(Function::new(
                                    "UNBASE64".to_string(),
                                    f.args,
                                ))))
                            }
                            "TO_BASE64"
                                if f.args.len() == 1 && matches!(target, DialectType::Hive) =>
                            {
                                Ok(Expression::Function(Box::new(Function::new(
                                    "BASE64".to_string(),
                                    f.args,
                                ))))
                            }
                            // FROM_UNIXTIME(x) -> CAST(FROM_UNIXTIME(x) AS TIMESTAMP) for Spark
                            "FROM_UNIXTIME"
                                if f.args.len() == 1
                                    && matches!(
                                        source,
                                        DialectType::Presto
                                            | DialectType::Trino
                                            | DialectType::Athena
                                    )
                                    && matches!(
                                        target,
                                        DialectType::Spark | DialectType::Databricks
                                    ) =>
                            {
                                // Wrap FROM_UNIXTIME(x) in CAST(... AS TIMESTAMP)
                                let from_unix = Expression::Function(Box::new(Function::new(
                                    "FROM_UNIXTIME".to_string(),
                                    f.args,
                                )));
                                Ok(Expression::Cast(Box::new(crate::expressions::Cast {
                                    this: from_unix,
                                    to: DataType::Timestamp {
                                        timezone: false,
                                        precision: None,
                                    },
                                    trailing_comments: Vec::new(),
                                    double_colon_syntax: false,
                                    format: None,
                                    default: None,
                                })))
                            }
                            // DATE_FORMAT(val, fmt) from Hive/Spark/MySQL -> target-specific format function
                            "DATE_FORMAT"
                                if f.args.len() >= 2
                                    && !matches!(
                                        target,
                                        DialectType::Hive
                                            | DialectType::Spark
                                            | DialectType::Databricks
                                            | DialectType::MySQL
                                            | DialectType::SingleStore
                                    ) =>
                            {
                                let val = f.args[0].clone();
                                let fmt_expr = &f.args[1];
                                let is_hive_source = matches!(
                                    source,
                                    DialectType::Hive
                                        | DialectType::Spark
                                        | DialectType::Databricks
                                );

                                fn java_to_c_format(fmt: &str) -> String {
                                    // Replace Java patterns with C strftime patterns.
                                    // Uses multi-pass to handle patterns that conflict.
                                    // First pass: replace multi-char patterns (longer first)
                                    let result = fmt
                                        .replace("yyyy", "%Y")
                                        .replace("SSSSSS", "%f")
                                        .replace("EEEE", "%W")
                                        .replace("MM", "%m")
                                        .replace("dd", "%d")
                                        .replace("HH", "%H")
                                        .replace("mm", "%M")
                                        .replace("ss", "%S")
                                        .replace("yy", "%y");
                                    // Second pass: handle single-char timezone patterns
                                    // z -> %Z (timezone name), Z -> %z (timezone offset)
                                    // Must be careful not to replace 'z'/'Z' inside already-replaced %Y, %M etc.
                                    let mut out = String::new();
                                    let chars: Vec<char> = result.chars().collect();
                                    let mut i = 0;
                                    while i < chars.len() {
                                        if chars[i] == '%' && i + 1 < chars.len() {
                                            // Already a format specifier, skip both chars
                                            out.push(chars[i]);
                                            out.push(chars[i + 1]);
                                            i += 2;
                                        } else if chars[i] == 'z' {
                                            out.push_str("%Z");
                                            i += 1;
                                        } else if chars[i] == 'Z' {
                                            out.push_str("%z");
                                            i += 1;
                                        } else {
                                            out.push(chars[i]);
                                            i += 1;
                                        }
                                    }
                                    out
                                }

                                fn java_to_presto_format(fmt: &str) -> String {
                                    // Presto uses %T for HH:MM:SS
                                    let c_fmt = java_to_c_format(fmt);
                                    c_fmt.replace("%H:%M:%S", "%T")
                                }

                                fn java_to_bq_format(fmt: &str) -> String {
                                    // BigQuery uses %F for yyyy-MM-dd and %T for HH:mm:ss
                                    let c_fmt = java_to_c_format(fmt);
                                    c_fmt.replace("%Y-%m-%d", "%F").replace("%H:%M:%S", "%T")
                                }

                                // For Hive source, CAST string literals to appropriate type
                                let cast_val = if is_hive_source {
                                    match &val {
                                        Expression::Literal(
                                            crate::expressions::Literal::String(_),
                                        ) => {
                                            match target {
                                                DialectType::DuckDB
                                                | DialectType::Presto
                                                | DialectType::Trino
                                                | DialectType::Athena => {
                                                    Self::ensure_cast_timestamp(val.clone())
                                                }
                                                DialectType::BigQuery => {
                                                    // BigQuery: CAST(val AS DATETIME)
                                                    Expression::Cast(Box::new(
                                                        crate::expressions::Cast {
                                                            this: val.clone(),
                                                            to: DataType::Custom {
                                                                name: "DATETIME".to_string(),
                                                            },
                                                            trailing_comments: vec![],
                                                            double_colon_syntax: false,
                                                            format: None,
                                                            default: None,
                                                        },
                                                    ))
                                                }
                                                _ => val.clone(),
                                            }
                                        }
                                        // For CAST(x AS DATE) or DATE literal, Presto needs CAST(CAST(x AS DATE) AS TIMESTAMP)
                                        Expression::Cast(c)
                                            if matches!(c.to, DataType::Date)
                                                && matches!(
                                                    target,
                                                    DialectType::Presto
                                                        | DialectType::Trino
                                                        | DialectType::Athena
                                                ) =>
                                        {
                                            Expression::Cast(Box::new(crate::expressions::Cast {
                                                this: val.clone(),
                                                to: DataType::Timestamp {
                                                    timezone: false,
                                                    precision: None,
                                                },
                                                trailing_comments: vec![],
                                                double_colon_syntax: false,
                                                format: None,
                                                default: None,
                                            }))
                                        }
                                        Expression::Literal(crate::expressions::Literal::Date(
                                            _,
                                        )) if matches!(
                                            target,
                                            DialectType::Presto
                                                | DialectType::Trino
                                                | DialectType::Athena
                                        ) =>
                                        {
                                            // DATE 'x' -> CAST(CAST('x' AS DATE) AS TIMESTAMP)
                                            let cast_date = Self::date_literal_to_cast(val.clone());
                                            Expression::Cast(Box::new(crate::expressions::Cast {
                                                this: cast_date,
                                                to: DataType::Timestamp {
                                                    timezone: false,
                                                    precision: None,
                                                },
                                                trailing_comments: vec![],
                                                double_colon_syntax: false,
                                                format: None,
                                                default: None,
                                            }))
                                        }
                                        _ => val.clone(),
                                    }
                                } else {
                                    val.clone()
                                };

                                match target {
                                    DialectType::DuckDB => {
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = fmt_expr
                                        {
                                            let c_fmt = if is_hive_source {
                                                java_to_c_format(s)
                                            } else {
                                                s.clone()
                                            };
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "STRFTIME".to_string(),
                                                vec![cast_val, Expression::string(&c_fmt)],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "STRFTIME".to_string(),
                                                vec![cast_val, fmt_expr.clone()],
                                            ))))
                                        }
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        if is_hive_source {
                                            if let Expression::Literal(
                                                crate::expressions::Literal::String(s),
                                            ) = fmt_expr
                                            {
                                                let p_fmt = java_to_presto_format(s);
                                                Ok(Expression::Function(Box::new(Function::new(
                                                    "DATE_FORMAT".to_string(),
                                                    vec![cast_val, Expression::string(&p_fmt)],
                                                ))))
                                            } else {
                                                Ok(Expression::Function(Box::new(Function::new(
                                                    "DATE_FORMAT".to_string(),
                                                    vec![cast_val, fmt_expr.clone()],
                                                ))))
                                            }
                                        } else {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_FORMAT".to_string(),
                                                f.args,
                                            ))))
                                        }
                                    }
                                    DialectType::BigQuery => {
                                        // DATE_FORMAT(val, fmt) -> FORMAT_DATE(fmt, val)
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = fmt_expr
                                        {
                                            let bq_fmt = if is_hive_source {
                                                java_to_bq_format(s)
                                            } else {
                                                java_to_c_format(s)
                                            };
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "FORMAT_DATE".to_string(),
                                                vec![Expression::string(&bq_fmt), cast_val],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "FORMAT_DATE".to_string(),
                                                vec![fmt_expr.clone(), cast_val],
                                            ))))
                                        }
                                    }
                                    DialectType::PostgreSQL | DialectType::Redshift => {
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = fmt_expr
                                        {
                                            let pg_fmt = s
                                                .replace("yyyy", "YYYY")
                                                .replace("MM", "MM")
                                                .replace("dd", "DD")
                                                .replace("HH", "HH24")
                                                .replace("mm", "MI")
                                                .replace("ss", "SS")
                                                .replace("yy", "YY");
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "TO_CHAR".to_string(),
                                                vec![val, Expression::string(&pg_fmt)],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "TO_CHAR".to_string(),
                                                vec![val, fmt_expr.clone()],
                                            ))))
                                        }
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // DATEDIFF(unit, start, end) - 3-arg form
                            // SQLite uses DATEDIFF(date1, date2, unit_string) instead
                            "DATEDIFF" if f.args.len() == 3 => {
                                let mut args = f.args;
                                // SQLite source: args = (date1, date2, unit_string)
                                // Standard source: args = (unit, start, end)
                                let (_arg0, arg1, arg2, unit_str) =
                                    if matches!(source, DialectType::SQLite) {
                                        let date1 = args.remove(0);
                                        let date2 = args.remove(0);
                                        let unit_expr = args.remove(0);
                                        let unit_s = Self::get_unit_str_static(&unit_expr);

                                        // For SQLite target, generate JULIANDAY arithmetic directly
                                        if matches!(target, DialectType::SQLite) {
                                            let jd_first = Expression::Function(Box::new(
                                                Function::new("JULIANDAY".to_string(), vec![date1]),
                                            ));
                                            let jd_second = Expression::Function(Box::new(
                                                Function::new("JULIANDAY".to_string(), vec![date2]),
                                            ));
                                            let diff = Expression::Sub(Box::new(
                                                crate::expressions::BinaryOp::new(
                                                    jd_first, jd_second,
                                                ),
                                            ));
                                            let paren_diff = Expression::Paren(Box::new(
                                                crate::expressions::Paren {
                                                    this: diff,
                                                    trailing_comments: Vec::new(),
                                                },
                                            ));
                                            let adjusted = match unit_s.as_str() {
                                                "HOUR" => Expression::Mul(Box::new(
                                                    crate::expressions::BinaryOp::new(
                                                        paren_diff,
                                                        Expression::Literal(Literal::Number(
                                                            "24.0".to_string(),
                                                        )),
                                                    ),
                                                )),
                                                "MINUTE" => Expression::Mul(Box::new(
                                                    crate::expressions::BinaryOp::new(
                                                        paren_diff,
                                                        Expression::Literal(Literal::Number(
                                                            "1440.0".to_string(),
                                                        )),
                                                    ),
                                                )),
                                                "SECOND" => Expression::Mul(Box::new(
                                                    crate::expressions::BinaryOp::new(
                                                        paren_diff,
                                                        Expression::Literal(Literal::Number(
                                                            "86400.0".to_string(),
                                                        )),
                                                    ),
                                                )),
                                                "MONTH" => Expression::Div(Box::new(
                                                    crate::expressions::BinaryOp::new(
                                                        paren_diff,
                                                        Expression::Literal(Literal::Number(
                                                            "30.0".to_string(),
                                                        )),
                                                    ),
                                                )),
                                                "YEAR" => Expression::Div(Box::new(
                                                    crate::expressions::BinaryOp::new(
                                                        paren_diff,
                                                        Expression::Literal(Literal::Number(
                                                            "365.0".to_string(),
                                                        )),
                                                    ),
                                                )),
                                                _ => paren_diff,
                                            };
                                            return Ok(Expression::Cast(Box::new(Cast {
                                                this: adjusted,
                                                to: DataType::Int {
                                                    length: None,
                                                    integer_spelling: true,
                                                },
                                                trailing_comments: vec![],
                                                double_colon_syntax: false,
                                                format: None,
                                                default: None,
                                            })));
                                        }

                                        // For other targets, remap to standard (unit, start, end) form
                                        let unit_ident =
                                            Expression::Identifier(Identifier::new(&unit_s));
                                        (unit_ident, date1, date2, unit_s)
                                    } else {
                                        let arg0 = args.remove(0);
                                        let arg1 = args.remove(0);
                                        let arg2 = args.remove(0);
                                        let unit_s = Self::get_unit_str_static(&arg0);
                                        (arg0, arg1, arg2, unit_s)
                                    };

                                // For Hive/Spark source, string literal dates need to be cast
                                // Note: Databricks is excluded - it handles string args like standard SQL
                                let is_hive_spark =
                                    matches!(source, DialectType::Hive | DialectType::Spark);

                                match target {
                                    DialectType::Snowflake => {
                                        let unit =
                                            Expression::Identifier(Identifier::new(&unit_str));
                                        // Use ensure_to_date_preserved to add TO_DATE with a marker
                                        // that prevents the Snowflake TO_DATE handler from converting it to CAST
                                        let d1 = if is_hive_spark {
                                            Self::ensure_to_date_preserved(arg1)
                                        } else {
                                            arg1
                                        };
                                        let d2 = if is_hive_spark {
                                            Self::ensure_to_date_preserved(arg2)
                                        } else {
                                            arg2
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEDIFF".to_string(),
                                            vec![unit, d1, d2],
                                        ))))
                                    }
                                    DialectType::Redshift => {
                                        let unit =
                                            Expression::Identifier(Identifier::new(&unit_str));
                                        let d1 = if is_hive_spark {
                                            Self::ensure_cast_date(arg1)
                                        } else {
                                            arg1
                                        };
                                        let d2 = if is_hive_spark {
                                            Self::ensure_cast_date(arg2)
                                        } else {
                                            arg2
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEDIFF".to_string(),
                                            vec![unit, d1, d2],
                                        ))))
                                    }
                                    DialectType::TSQL => {
                                        let unit =
                                            Expression::Identifier(Identifier::new(&unit_str));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEDIFF".to_string(),
                                            vec![unit, arg1, arg2],
                                        ))))
                                    }
                                    DialectType::DuckDB => {
                                        let is_redshift_tsql = matches!(
                                            source,
                                            DialectType::Redshift | DialectType::TSQL
                                        );
                                        if is_hive_spark {
                                            // For Hive/Spark source, CAST string args to DATE and emit DATE_DIFF directly
                                            let d1 = Self::ensure_cast_date(arg1);
                                            let d2 = Self::ensure_cast_date(arg2);
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_DIFF".to_string(),
                                                vec![Expression::string(&unit_str), d1, d2],
                                            ))))
                                        } else if matches!(source, DialectType::Snowflake) {
                                            // For Snowflake source: special handling per unit
                                            match unit_str.as_str() {
                                                "NANOSECOND" => {
                                                    // DATEDIFF(NANOSECOND, start, end) -> EPOCH_NS(CAST(end AS TIMESTAMP_NS)) - EPOCH_NS(CAST(start AS TIMESTAMP_NS))
                                                    fn cast_to_timestamp_ns(
                                                        expr: Expression,
                                                    ) -> Expression
                                                    {
                                                        Expression::Cast(Box::new(Cast {
                                                            this: expr,
                                                            to: DataType::Custom {
                                                                name: "TIMESTAMP_NS".to_string(),
                                                            },
                                                            trailing_comments: vec![],
                                                            double_colon_syntax: false,
                                                            format: None,
                                                            default: None,
                                                        }))
                                                    }
                                                    let epoch_end = Expression::Function(Box::new(
                                                        Function::new(
                                                            "EPOCH_NS".to_string(),
                                                            vec![cast_to_timestamp_ns(arg2)],
                                                        ),
                                                    ));
                                                    let epoch_start = Expression::Function(
                                                        Box::new(Function::new(
                                                            "EPOCH_NS".to_string(),
                                                            vec![cast_to_timestamp_ns(arg1)],
                                                        )),
                                                    );
                                                    Ok(Expression::Sub(Box::new(BinaryOp::new(
                                                        epoch_end,
                                                        epoch_start,
                                                    ))))
                                                }
                                                "WEEK" => {
                                                    // DATE_DIFF('WEEK', DATE_TRUNC('WEEK', CAST(x AS DATE)), DATE_TRUNC('WEEK', CAST(y AS DATE)))
                                                    let d1 = Self::force_cast_date(arg1);
                                                    let d2 = Self::force_cast_date(arg2);
                                                    let dt1 = Expression::Function(Box::new(
                                                        Function::new(
                                                            "DATE_TRUNC".to_string(),
                                                            vec![Expression::string("WEEK"), d1],
                                                        ),
                                                    ));
                                                    let dt2 = Expression::Function(Box::new(
                                                        Function::new(
                                                            "DATE_TRUNC".to_string(),
                                                            vec![Expression::string("WEEK"), d2],
                                                        ),
                                                    ));
                                                    Ok(Expression::Function(Box::new(
                                                        Function::new(
                                                            "DATE_DIFF".to_string(),
                                                            vec![
                                                                Expression::string(&unit_str),
                                                                dt1,
                                                                dt2,
                                                            ],
                                                        ),
                                                    )))
                                                }
                                                _ => {
                                                    // YEAR, MONTH, QUARTER, DAY, etc.: CAST to DATE
                                                    let d1 = Self::force_cast_date(arg1);
                                                    let d2 = Self::force_cast_date(arg2);
                                                    Ok(Expression::Function(Box::new(
                                                        Function::new(
                                                            "DATE_DIFF".to_string(),
                                                            vec![
                                                                Expression::string(&unit_str),
                                                                d1,
                                                                d2,
                                                            ],
                                                        ),
                                                    )))
                                                }
                                            }
                                        } else if is_redshift_tsql {
                                            // For Redshift/TSQL source, CAST args to TIMESTAMP (always)
                                            let d1 = Self::force_cast_timestamp(arg1);
                                            let d2 = Self::force_cast_timestamp(arg2);
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_DIFF".to_string(),
                                                vec![Expression::string(&unit_str), d1, d2],
                                            ))))
                                        } else {
                                            // Keep as DATEDIFF so DuckDB's transform_datediff handles
                                            // DATE_TRUNC for WEEK, CAST for string literals, etc.
                                            let unit =
                                                Expression::Identifier(Identifier::new(&unit_str));
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATEDIFF".to_string(),
                                                vec![unit, arg1, arg2],
                                            ))))
                                        }
                                    }
                                    DialectType::BigQuery => {
                                        let is_redshift_tsql = matches!(
                                            source,
                                            DialectType::Redshift
                                                | DialectType::TSQL
                                                | DialectType::Snowflake
                                        );
                                        let cast_d1 = if is_hive_spark {
                                            Self::ensure_cast_date(arg1)
                                        } else if is_redshift_tsql {
                                            Self::force_cast_datetime(arg1)
                                        } else {
                                            Self::ensure_cast_datetime(arg1)
                                        };
                                        let cast_d2 = if is_hive_spark {
                                            Self::ensure_cast_date(arg2)
                                        } else if is_redshift_tsql {
                                            Self::force_cast_datetime(arg2)
                                        } else {
                                            Self::ensure_cast_datetime(arg2)
                                        };
                                        let unit =
                                            Expression::Identifier(Identifier::new(&unit_str));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_DIFF".to_string(),
                                            vec![cast_d2, cast_d1, unit],
                                        ))))
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        // For Hive/Spark source, string literals need double-cast: CAST(CAST(x AS TIMESTAMP) AS DATE)
                                        // For Redshift/TSQL source, args need CAST to TIMESTAMP (always)
                                        let is_redshift_tsql = matches!(
                                            source,
                                            DialectType::Redshift
                                                | DialectType::TSQL
                                                | DialectType::Snowflake
                                        );
                                        let d1 = if is_hive_spark {
                                            Self::double_cast_timestamp_date(arg1)
                                        } else if is_redshift_tsql {
                                            Self::force_cast_timestamp(arg1)
                                        } else {
                                            arg1
                                        };
                                        let d2 = if is_hive_spark {
                                            Self::double_cast_timestamp_date(arg2)
                                        } else if is_redshift_tsql {
                                            Self::force_cast_timestamp(arg2)
                                        } else {
                                            arg2
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_DIFF".to_string(),
                                            vec![Expression::string(&unit_str), d1, d2],
                                        ))))
                                    }
                                    DialectType::Hive => match unit_str.as_str() {
                                        "MONTH" => Ok(Expression::Cast(Box::new(Cast {
                                            this: Expression::Function(Box::new(Function::new(
                                                "MONTHS_BETWEEN".to_string(),
                                                vec![arg2, arg1],
                                            ))),
                                            to: DataType::Int {
                                                length: None,
                                                integer_spelling: false,
                                            },
                                            trailing_comments: vec![],
                                            double_colon_syntax: false,
                                            format: None,
                                            default: None,
                                        }))),
                                        "WEEK" => Ok(Expression::Cast(Box::new(Cast {
                                            this: Expression::Div(Box::new(
                                                crate::expressions::BinaryOp::new(
                                                    Expression::Function(Box::new(Function::new(
                                                        "DATEDIFF".to_string(),
                                                        vec![arg2, arg1],
                                                    ))),
                                                    Expression::number(7),
                                                ),
                                            )),
                                            to: DataType::Int {
                                                length: None,
                                                integer_spelling: false,
                                            },
                                            trailing_comments: vec![],
                                            double_colon_syntax: false,
                                            format: None,
                                            default: None,
                                        }))),
                                        _ => Ok(Expression::Function(Box::new(Function::new(
                                            "DATEDIFF".to_string(),
                                            vec![arg2, arg1],
                                        )))),
                                    },
                                    DialectType::Spark | DialectType::Databricks => {
                                        let unit =
                                            Expression::Identifier(Identifier::new(&unit_str));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEDIFF".to_string(),
                                            vec![unit, arg1, arg2],
                                        ))))
                                    }
                                    _ => {
                                        // For Hive/Spark source targeting PostgreSQL etc., cast string literals to DATE
                                        let d1 = if is_hive_spark {
                                            Self::ensure_cast_date(arg1)
                                        } else {
                                            arg1
                                        };
                                        let d2 = if is_hive_spark {
                                            Self::ensure_cast_date(arg2)
                                        } else {
                                            arg2
                                        };
                                        let unit =
                                            Expression::Identifier(Identifier::new(&unit_str));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEDIFF".to_string(),
                                            vec![unit, d1, d2],
                                        ))))
                                    }
                                }
                            }
                            // DATEDIFF(end, start) - 2-arg form from Hive/MySQL
                            "DATEDIFF" if f.args.len() == 2 => {
                                let mut args = f.args;
                                let arg0 = args.remove(0);
                                let arg1 = args.remove(0);

                                // Helper: unwrap TO_DATE(x) -> x (extracts inner arg)
                                // Also recognizes TryCast/Cast to DATE that may have been produced by
                                // cross-dialect TO_DATE -> TRY_CAST conversion
                                let unwrap_to_date = |e: Expression| -> (Expression, bool) {
                                    if let Expression::Function(ref f) = e {
                                        if f.name.eq_ignore_ascii_case("TO_DATE")
                                            && f.args.len() == 1
                                        {
                                            return (f.args[0].clone(), true);
                                        }
                                    }
                                    // Also recognize TryCast(x, Date) as an already-converted TO_DATE
                                    if let Expression::TryCast(ref c) = e {
                                        if matches!(c.to, DataType::Date) {
                                            return (e, true); // Already properly cast, return as-is
                                        }
                                    }
                                    (e, false)
                                };

                                match target {
                                    DialectType::DuckDB => {
                                        // For Hive source, always CAST to DATE
                                        // If arg is TO_DATE(x) or TRY_CAST(x AS DATE), use it directly
                                        let cast_d0 = if matches!(
                                            source,
                                            DialectType::Hive
                                                | DialectType::Spark
                                                | DialectType::Databricks
                                        ) {
                                            let (inner, was_to_date) = unwrap_to_date(arg1);
                                            if was_to_date {
                                                // Already a date expression, use directly
                                                if matches!(&inner, Expression::TryCast(_)) {
                                                    inner // Already TRY_CAST(x AS DATE)
                                                } else {
                                                    Self::try_cast_date(inner)
                                                }
                                            } else {
                                                Self::force_cast_date(inner)
                                            }
                                        } else {
                                            Self::ensure_cast_date(arg1)
                                        };
                                        let cast_d1 = if matches!(
                                            source,
                                            DialectType::Hive
                                                | DialectType::Spark
                                                | DialectType::Databricks
                                        ) {
                                            let (inner, was_to_date) = unwrap_to_date(arg0);
                                            if was_to_date {
                                                if matches!(&inner, Expression::TryCast(_)) {
                                                    inner
                                                } else {
                                                    Self::try_cast_date(inner)
                                                }
                                            } else {
                                                Self::force_cast_date(inner)
                                            }
                                        } else {
                                            Self::ensure_cast_date(arg0)
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_DIFF".to_string(),
                                            vec![Expression::string("DAY"), cast_d0, cast_d1],
                                        ))))
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        // For Hive/Spark source, apply double_cast_timestamp_date
                                        // For other sources (MySQL etc.), just swap args without casting
                                        if matches!(
                                            source,
                                            DialectType::Hive
                                                | DialectType::Spark
                                                | DialectType::Databricks
                                        ) {
                                            let cast_fn = |e: Expression| -> Expression {
                                                let (inner, was_to_date) = unwrap_to_date(e);
                                                if was_to_date {
                                                    let first_cast =
                                                        Self::double_cast_timestamp_date(inner);
                                                    Self::double_cast_timestamp_date(first_cast)
                                                } else {
                                                    Self::double_cast_timestamp_date(inner)
                                                }
                                            };
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_DIFF".to_string(),
                                                vec![
                                                    Expression::string("DAY"),
                                                    cast_fn(arg1),
                                                    cast_fn(arg0),
                                                ],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_DIFF".to_string(),
                                                vec![Expression::string("DAY"), arg1, arg0],
                                            ))))
                                        }
                                    }
                                    DialectType::Redshift => {
                                        let unit = Expression::Identifier(Identifier::new("DAY"));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEDIFF".to_string(),
                                            vec![unit, arg1, arg0],
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "DATEDIFF".to_string(),
                                        vec![arg0, arg1],
                                    )))),
                                }
                            }
                            // DATE_DIFF(unit, start, end) - 3-arg with string unit (ClickHouse/DuckDB style)
                            "DATE_DIFF" if f.args.len() == 3 => {
                                let mut args = f.args;
                                let arg0 = args.remove(0);
                                let arg1 = args.remove(0);
                                let arg2 = args.remove(0);
                                let unit_str = Self::get_unit_str_static(&arg0);

                                match target {
                                    DialectType::DuckDB => {
                                        // DuckDB: DATE_DIFF('UNIT', start, end)
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_DIFF".to_string(),
                                            vec![Expression::string(&unit_str), arg1, arg2],
                                        ))))
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_DIFF".to_string(),
                                            vec![Expression::string(&unit_str), arg1, arg2],
                                        ))))
                                    }
                                    DialectType::ClickHouse => {
                                        // ClickHouse: DATE_DIFF(UNIT, start, end) - identifier unit
                                        let unit =
                                            Expression::Identifier(Identifier::new(&unit_str));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_DIFF".to_string(),
                                            vec![unit, arg1, arg2],
                                        ))))
                                    }
                                    DialectType::Snowflake | DialectType::Redshift => {
                                        let unit =
                                            Expression::Identifier(Identifier::new(&unit_str));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEDIFF".to_string(),
                                            vec![unit, arg1, arg2],
                                        ))))
                                    }
                                    _ => {
                                        let unit =
                                            Expression::Identifier(Identifier::new(&unit_str));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEDIFF".to_string(),
                                            vec![unit, arg1, arg2],
                                        ))))
                                    }
                                }
                            }
                            // DATEADD(unit, val, date) - 3-arg form
                            "DATEADD" if f.args.len() == 3 => {
                                let mut args = f.args;
                                let arg0 = args.remove(0);
                                let arg1 = args.remove(0);
                                let arg2 = args.remove(0);
                                let unit_str = Self::get_unit_str_static(&arg0);

                                // Normalize TSQL unit abbreviations to standard names
                                let unit_str = match unit_str.as_str() {
                                    "YY" | "YYYY" => "YEAR".to_string(),
                                    "QQ" | "Q" => "QUARTER".to_string(),
                                    "MM" | "M" => "MONTH".to_string(),
                                    "WK" | "WW" => "WEEK".to_string(),
                                    "DD" | "D" | "DY" => "DAY".to_string(),
                                    "HH" => "HOUR".to_string(),
                                    "MI" | "N" => "MINUTE".to_string(),
                                    "SS" | "S" => "SECOND".to_string(),
                                    "MS" => "MILLISECOND".to_string(),
                                    "MCS" | "US" => "MICROSECOND".to_string(),
                                    _ => unit_str,
                                };
                                match target {
                                    DialectType::Snowflake => {
                                        let unit =
                                            Expression::Identifier(Identifier::new(&unit_str));
                                        // Cast string literal to TIMESTAMP, but not for Snowflake source
                                        // (Snowflake natively accepts string literals in DATEADD)
                                        let arg2 = if matches!(
                                            &arg2,
                                            Expression::Literal(Literal::String(_))
                                        ) && !matches!(source, DialectType::Snowflake)
                                        {
                                            Expression::Cast(Box::new(Cast {
                                                this: arg2,
                                                to: DataType::Timestamp {
                                                    precision: None,
                                                    timezone: false,
                                                },
                                                trailing_comments: Vec::new(),
                                                double_colon_syntax: false,
                                                format: None,
                                                default: None,
                                            }))
                                        } else {
                                            arg2
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEADD".to_string(),
                                            vec![unit, arg1, arg2],
                                        ))))
                                    }
                                    DialectType::TSQL => {
                                        let unit =
                                            Expression::Identifier(Identifier::new(&unit_str));
                                        // Cast string literal to DATETIME2, but not when source is Spark/Databricks family
                                        let arg2 = if matches!(
                                            &arg2,
                                            Expression::Literal(Literal::String(_))
                                        ) && !matches!(
                                            source,
                                            DialectType::Spark
                                                | DialectType::Databricks
                                                | DialectType::Hive
                                        ) {
                                            Expression::Cast(Box::new(Cast {
                                                this: arg2,
                                                to: DataType::Custom {
                                                    name: "DATETIME2".to_string(),
                                                },
                                                trailing_comments: Vec::new(),
                                                double_colon_syntax: false,
                                                format: None,
                                                default: None,
                                            }))
                                        } else {
                                            arg2
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEADD".to_string(),
                                            vec![unit, arg1, arg2],
                                        ))))
                                    }
                                    DialectType::Redshift => {
                                        let unit =
                                            Expression::Identifier(Identifier::new(&unit_str));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEADD".to_string(),
                                            vec![unit, arg1, arg2],
                                        ))))
                                    }
                                    DialectType::Databricks => {
                                        let unit =
                                            Expression::Identifier(Identifier::new(&unit_str));
                                        // Sources with native DATEADD (TSQL, Databricks, Snowflake) -> DATEADD
                                        // Other sources (Redshift TsOrDsAdd, etc.) -> DATE_ADD
                                        let func_name = if matches!(
                                            source,
                                            DialectType::TSQL
                                                | DialectType::Fabric
                                                | DialectType::Databricks
                                                | DialectType::Snowflake
                                        ) {
                                            "DATEADD"
                                        } else {
                                            "DATE_ADD"
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            func_name.to_string(),
                                            vec![unit, arg1, arg2],
                                        ))))
                                    }
                                    DialectType::DuckDB => {
                                        // Special handling for NANOSECOND from Snowflake
                                        if unit_str == "NANOSECOND"
                                            && matches!(source, DialectType::Snowflake)
                                        {
                                            // DATEADD(NANOSECOND, offset, ts) -> MAKE_TIMESTAMP_NS(EPOCH_NS(CAST(ts AS TIMESTAMP_NS)) + offset)
                                            let cast_ts = Expression::Cast(Box::new(Cast {
                                                this: arg2,
                                                to: DataType::Custom {
                                                    name: "TIMESTAMP_NS".to_string(),
                                                },
                                                trailing_comments: vec![],
                                                double_colon_syntax: false,
                                                format: None,
                                                default: None,
                                            }));
                                            let epoch_ns =
                                                Expression::Function(Box::new(Function::new(
                                                    "EPOCH_NS".to_string(),
                                                    vec![cast_ts],
                                                )));
                                            let sum = Expression::Add(Box::new(BinaryOp::new(
                                                epoch_ns, arg1,
                                            )));
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "MAKE_TIMESTAMP_NS".to_string(),
                                                vec![sum],
                                            ))))
                                        } else {
                                            // DuckDB: convert to date + INTERVAL syntax with CAST
                                            let iu = Self::parse_interval_unit_static(&unit_str);
                                            let interval = Expression::Interval(Box::new(crate::expressions::Interval {
                                                this: Some(arg1),
                                                unit: Some(crate::expressions::IntervalUnitSpec::Simple { unit: iu, use_plural: false }),
                                            }));
                                            // Cast string literal to TIMESTAMP
                                            let arg2 = if matches!(
                                                &arg2,
                                                Expression::Literal(Literal::String(_))
                                            ) {
                                                Expression::Cast(Box::new(Cast {
                                                    this: arg2,
                                                    to: DataType::Timestamp {
                                                        precision: None,
                                                        timezone: false,
                                                    },
                                                    trailing_comments: Vec::new(),
                                                    double_colon_syntax: false,
                                                    format: None,
                                                    default: None,
                                                }))
                                            } else {
                                                arg2
                                            };
                                            Ok(Expression::Add(Box::new(
                                                crate::expressions::BinaryOp::new(arg2, interval),
                                            )))
                                        }
                                    }
                                    DialectType::Spark => {
                                        // For TSQL source: convert to ADD_MONTHS/DATE_ADD(date, val)
                                        // For other sources: keep 3-arg DATE_ADD(UNIT, val, date) form
                                        if matches!(source, DialectType::TSQL | DialectType::Fabric)
                                        {
                                            fn multiply_expr_spark(
                                                expr: Expression,
                                                factor: i64,
                                            ) -> Expression
                                            {
                                                if let Expression::Literal(
                                                    crate::expressions::Literal::Number(n),
                                                ) = &expr
                                                {
                                                    if let Ok(val) = n.parse::<i64>() {
                                                        return Expression::Literal(
                                                            crate::expressions::Literal::Number(
                                                                (val * factor).to_string(),
                                                            ),
                                                        );
                                                    }
                                                }
                                                Expression::Mul(Box::new(
                                                    crate::expressions::BinaryOp::new(
                                                        expr,
                                                        Expression::Literal(
                                                            crate::expressions::Literal::Number(
                                                                factor.to_string(),
                                                            ),
                                                        ),
                                                    ),
                                                ))
                                            }
                                            let normalized_unit = match unit_str.as_str() {
                                                "YEAR" | "YY" | "YYYY" => "YEAR",
                                                "QUARTER" | "QQ" | "Q" => "QUARTER",
                                                "MONTH" | "MM" | "M" => "MONTH",
                                                "WEEK" | "WK" | "WW" => "WEEK",
                                                "DAY" | "DD" | "D" | "DY" => "DAY",
                                                _ => &unit_str,
                                            };
                                            match normalized_unit {
                                                "YEAR" => {
                                                    let months = multiply_expr_spark(arg1, 12);
                                                    Ok(Expression::Function(Box::new(
                                                        Function::new(
                                                            "ADD_MONTHS".to_string(),
                                                            vec![arg2, months],
                                                        ),
                                                    )))
                                                }
                                                "QUARTER" => {
                                                    let months = multiply_expr_spark(arg1, 3);
                                                    Ok(Expression::Function(Box::new(
                                                        Function::new(
                                                            "ADD_MONTHS".to_string(),
                                                            vec![arg2, months],
                                                        ),
                                                    )))
                                                }
                                                "MONTH" => Ok(Expression::Function(Box::new(
                                                    Function::new(
                                                        "ADD_MONTHS".to_string(),
                                                        vec![arg2, arg1],
                                                    ),
                                                ))),
                                                "WEEK" => {
                                                    let days = multiply_expr_spark(arg1, 7);
                                                    Ok(Expression::Function(Box::new(
                                                        Function::new(
                                                            "DATE_ADD".to_string(),
                                                            vec![arg2, days],
                                                        ),
                                                    )))
                                                }
                                                "DAY" => Ok(Expression::Function(Box::new(
                                                    Function::new(
                                                        "DATE_ADD".to_string(),
                                                        vec![arg2, arg1],
                                                    ),
                                                ))),
                                                _ => {
                                                    let unit = Expression::Identifier(
                                                        Identifier::new(&unit_str),
                                                    );
                                                    Ok(Expression::Function(Box::new(
                                                        Function::new(
                                                            "DATE_ADD".to_string(),
                                                            vec![unit, arg1, arg2],
                                                        ),
                                                    )))
                                                }
                                            }
                                        } else {
                                            // Non-TSQL source: keep 3-arg DATE_ADD(UNIT, val, date)
                                            let unit =
                                                Expression::Identifier(Identifier::new(&unit_str));
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_ADD".to_string(),
                                                vec![unit, arg1, arg2],
                                            ))))
                                        }
                                    }
                                    DialectType::Hive => match unit_str.as_str() {
                                        "MONTH" => {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "ADD_MONTHS".to_string(),
                                                vec![arg2, arg1],
                                            ))))
                                        }
                                        _ => Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_ADD".to_string(),
                                            vec![arg2, arg1],
                                        )))),
                                    },
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        // Cast string literal date to TIMESTAMP
                                        let arg2 = if matches!(
                                            &arg2,
                                            Expression::Literal(Literal::String(_))
                                        ) {
                                            Expression::Cast(Box::new(Cast {
                                                this: arg2,
                                                to: DataType::Timestamp {
                                                    precision: None,
                                                    timezone: false,
                                                },
                                                trailing_comments: Vec::new(),
                                                double_colon_syntax: false,
                                                format: None,
                                                default: None,
                                            }))
                                        } else {
                                            arg2
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_ADD".to_string(),
                                            vec![Expression::string(&unit_str), arg1, arg2],
                                        ))))
                                    }
                                    DialectType::MySQL => {
                                        let iu = Self::parse_interval_unit_static(&unit_str);
                                        Ok(Expression::DateAdd(Box::new(
                                            crate::expressions::DateAddFunc {
                                                this: arg2,
                                                interval: arg1,
                                                unit: iu,
                                            },
                                        )))
                                    }
                                    DialectType::PostgreSQL => {
                                        // Cast string literal date to TIMESTAMP
                                        let arg2 = if matches!(
                                            &arg2,
                                            Expression::Literal(Literal::String(_))
                                        ) {
                                            Expression::Cast(Box::new(Cast {
                                                this: arg2,
                                                to: DataType::Timestamp {
                                                    precision: None,
                                                    timezone: false,
                                                },
                                                trailing_comments: Vec::new(),
                                                double_colon_syntax: false,
                                                format: None,
                                                default: None,
                                            }))
                                        } else {
                                            arg2
                                        };
                                        let interval = Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(Expression::string(&format!(
                                                    "{} {}",
                                                    Self::expr_to_string_static(&arg1),
                                                    unit_str
                                                ))),
                                                unit: None,
                                            },
                                        ));
                                        Ok(Expression::Add(Box::new(
                                            crate::expressions::BinaryOp::new(arg2, interval),
                                        )))
                                    }
                                    DialectType::BigQuery => {
                                        let iu = Self::parse_interval_unit_static(&unit_str);
                                        let interval = Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(arg1),
                                                unit: Some(
                                                    crate::expressions::IntervalUnitSpec::Simple {
                                                        unit: iu,
                                                        use_plural: false,
                                                    },
                                                ),
                                            },
                                        ));
                                        // Non-TSQL sources: CAST string literal to DATETIME
                                        let arg2 = if !matches!(
                                            source,
                                            DialectType::TSQL | DialectType::Fabric
                                        ) && matches!(
                                            &arg2,
                                            Expression::Literal(Literal::String(_))
                                        ) {
                                            Expression::Cast(Box::new(Cast {
                                                this: arg2,
                                                to: DataType::Custom {
                                                    name: "DATETIME".to_string(),
                                                },
                                                trailing_comments: Vec::new(),
                                                double_colon_syntax: false,
                                                format: None,
                                                default: None,
                                            }))
                                        } else {
                                            arg2
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_ADD".to_string(),
                                            vec![arg2, interval],
                                        ))))
                                    }
                                    _ => {
                                        let unit =
                                            Expression::Identifier(Identifier::new(&unit_str));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEADD".to_string(),
                                            vec![unit, arg1, arg2],
                                        ))))
                                    }
                                }
                            }
                            // DATE_ADD - 3-arg: either (unit, val, date) from Presto/ClickHouse
                            // or (date, val, 'UNIT') from Generic canonical form
                            "DATE_ADD" if f.args.len() == 3 => {
                                let mut args = f.args;
                                let arg0 = args.remove(0);
                                let arg1 = args.remove(0);
                                let arg2 = args.remove(0);
                                // Detect Generic canonical form: DATE_ADD(date, amount, 'UNIT')
                                // where arg2 is a string literal matching a unit name
                                let arg2_unit = match &arg2 {
                                    Expression::Literal(Literal::String(s)) => {
                                        let u = s.to_uppercase();
                                        if matches!(
                                            u.as_str(),
                                            "DAY"
                                                | "MONTH"
                                                | "YEAR"
                                                | "HOUR"
                                                | "MINUTE"
                                                | "SECOND"
                                                | "WEEK"
                                                | "QUARTER"
                                                | "MILLISECOND"
                                                | "MICROSECOND"
                                        ) {
                                            Some(u)
                                        } else {
                                            None
                                        }
                                    }
                                    _ => None,
                                };
                                // Reorder: if arg2 is the unit, swap to (unit, val, date) form
                                let (unit_str, val, date) = if let Some(u) = arg2_unit {
                                    (u, arg1, arg0)
                                } else {
                                    (Self::get_unit_str_static(&arg0), arg1, arg2)
                                };
                                // Alias for backward compat with the rest of the match
                                let arg1 = val;
                                let arg2 = date;

                                match target {
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_ADD".to_string(),
                                            vec![Expression::string(&unit_str), arg1, arg2],
                                        ))))
                                    }
                                    DialectType::DuckDB => {
                                        let iu = Self::parse_interval_unit_static(&unit_str);
                                        let interval = Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(arg1),
                                                unit: Some(
                                                    crate::expressions::IntervalUnitSpec::Simple {
                                                        unit: iu,
                                                        use_plural: false,
                                                    },
                                                ),
                                            },
                                        ));
                                        Ok(Expression::Add(Box::new(
                                            crate::expressions::BinaryOp::new(arg2, interval),
                                        )))
                                    }
                                    DialectType::PostgreSQL
                                    | DialectType::Materialize
                                    | DialectType::RisingWave => {
                                        // PostgreSQL: x + INTERVAL '1 DAY'
                                        let amount_str = Self::expr_to_string_static(&arg1);
                                        let interval = Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(Expression::string(&format!(
                                                    "{} {}",
                                                    amount_str, unit_str
                                                ))),
                                                unit: None,
                                            },
                                        ));
                                        Ok(Expression::Add(Box::new(
                                            crate::expressions::BinaryOp::new(arg2, interval),
                                        )))
                                    }
                                    DialectType::Snowflake
                                    | DialectType::TSQL
                                    | DialectType::Redshift => {
                                        let unit =
                                            Expression::Identifier(Identifier::new(&unit_str));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEADD".to_string(),
                                            vec![unit, arg1, arg2],
                                        ))))
                                    }
                                    DialectType::BigQuery
                                    | DialectType::MySQL
                                    | DialectType::Doris
                                    | DialectType::StarRocks
                                    | DialectType::Drill => {
                                        // DATE_ADD(date, INTERVAL amount UNIT)
                                        let iu = Self::parse_interval_unit_static(&unit_str);
                                        let interval = Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(arg1),
                                                unit: Some(
                                                    crate::expressions::IntervalUnitSpec::Simple {
                                                        unit: iu,
                                                        use_plural: false,
                                                    },
                                                ),
                                            },
                                        ));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_ADD".to_string(),
                                            vec![arg2, interval],
                                        ))))
                                    }
                                    DialectType::SQLite => {
                                        // SQLite: DATE(x, '1 DAY')
                                        // Build the string '1 DAY' from amount and unit
                                        let amount_str = match &arg1 {
                                            Expression::Literal(Literal::Number(n)) => n.clone(),
                                            _ => "1".to_string(),
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE".to_string(),
                                            vec![
                                                arg2,
                                                Expression::string(format!(
                                                    "{} {}",
                                                    amount_str, unit_str
                                                )),
                                            ],
                                        ))))
                                    }
                                    DialectType::Dremio => {
                                        // Dremio: DATE_ADD(date, amount) - drops unit
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_ADD".to_string(),
                                            vec![arg2, arg1],
                                        ))))
                                    }
                                    DialectType::Spark => {
                                        // Spark: DATE_ADD(date, val) for DAY, or DATEADD(UNIT, val, date)
                                        if unit_str == "DAY" {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_ADD".to_string(),
                                                vec![arg2, arg1],
                                            ))))
                                        } else {
                                            let unit =
                                                Expression::Identifier(Identifier::new(&unit_str));
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_ADD".to_string(),
                                                vec![unit, arg1, arg2],
                                            ))))
                                        }
                                    }
                                    DialectType::Databricks => {
                                        let unit =
                                            Expression::Identifier(Identifier::new(&unit_str));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_ADD".to_string(),
                                            vec![unit, arg1, arg2],
                                        ))))
                                    }
                                    DialectType::Hive => {
                                        // Hive: DATE_ADD(date, val) for DAY
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_ADD".to_string(),
                                            vec![arg2, arg1],
                                        ))))
                                    }
                                    _ => {
                                        let unit =
                                            Expression::Identifier(Identifier::new(&unit_str));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_ADD".to_string(),
                                            vec![unit, arg1, arg2],
                                        ))))
                                    }
                                }
                            }
                            // DATE_ADD(date, days) - 2-arg Hive/Spark/Generic form (add days)
                            "DATE_ADD"
                                if f.args.len() == 2
                                    && matches!(
                                        source,
                                        DialectType::Hive
                                            | DialectType::Spark
                                            | DialectType::Databricks
                                            | DialectType::Generic
                                    ) =>
                            {
                                let mut args = f.args;
                                let date = args.remove(0);
                                let days = args.remove(0);
                                match target {
                                    DialectType::Hive | DialectType::Spark => {
                                        // Keep as DATE_ADD(date, days) for Hive/Spark
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_ADD".to_string(),
                                            vec![date, days],
                                        ))))
                                    }
                                    DialectType::Databricks => {
                                        // Databricks: DATEADD(DAY, days, date)
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEADD".to_string(),
                                            vec![
                                                Expression::Identifier(Identifier::new("DAY")),
                                                days,
                                                date,
                                            ],
                                        ))))
                                    }
                                    DialectType::DuckDB => {
                                        // DuckDB: CAST(date AS DATE) + INTERVAL days DAY
                                        let cast_date = Self::ensure_cast_date(date);
                                        // Wrap complex expressions (like Mul from DATE_SUB negation) in Paren
                                        let interval_val = if matches!(
                                            days,
                                            Expression::Mul(_)
                                                | Expression::Sub(_)
                                                | Expression::Add(_)
                                        ) {
                                            Expression::Paren(Box::new(crate::expressions::Paren {
                                                this: days,
                                                trailing_comments: vec![],
                                            }))
                                        } else {
                                            days
                                        };
                                        let interval = Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(interval_val),
                                                unit: Some(
                                                    crate::expressions::IntervalUnitSpec::Simple {
                                                        unit: crate::expressions::IntervalUnit::Day,
                                                        use_plural: false,
                                                    },
                                                ),
                                            },
                                        ));
                                        Ok(Expression::Add(Box::new(
                                            crate::expressions::BinaryOp::new(cast_date, interval),
                                        )))
                                    }
                                    DialectType::Snowflake => {
                                        // For Hive source with string literal date, use CAST(CAST(date AS TIMESTAMP) AS DATE)
                                        let cast_date = if matches!(
                                            source,
                                            DialectType::Hive
                                                | DialectType::Spark
                                                | DialectType::Databricks
                                        ) {
                                            if matches!(
                                                date,
                                                Expression::Literal(Literal::String(_))
                                            ) {
                                                Self::double_cast_timestamp_date(date)
                                            } else {
                                                date
                                            }
                                        } else {
                                            date
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEADD".to_string(),
                                            vec![
                                                Expression::Identifier(Identifier::new("DAY")),
                                                days,
                                                cast_date,
                                            ],
                                        ))))
                                    }
                                    DialectType::Redshift => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEADD".to_string(),
                                            vec![
                                                Expression::Identifier(Identifier::new("DAY")),
                                                days,
                                                date,
                                            ],
                                        ))))
                                    }
                                    DialectType::TSQL | DialectType::Fabric => {
                                        // For Hive source with string literal date, use CAST(CAST(date AS DATETIME2) AS DATE)
                                        // But Databricks DATE_ADD doesn't need this wrapping for TSQL
                                        let cast_date = if matches!(
                                            source,
                                            DialectType::Hive | DialectType::Spark
                                        ) {
                                            if matches!(
                                                date,
                                                Expression::Literal(Literal::String(_))
                                            ) {
                                                Self::double_cast_datetime2_date(date)
                                            } else {
                                                date
                                            }
                                        } else {
                                            date
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEADD".to_string(),
                                            vec![
                                                Expression::Identifier(Identifier::new("DAY")),
                                                days,
                                                cast_date,
                                            ],
                                        ))))
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        // For Hive source with string literal date, use CAST(CAST(date AS TIMESTAMP) AS DATE)
                                        let cast_date = if matches!(
                                            source,
                                            DialectType::Hive
                                                | DialectType::Spark
                                                | DialectType::Databricks
                                        ) {
                                            if matches!(
                                                date,
                                                Expression::Literal(Literal::String(_))
                                            ) {
                                                Self::double_cast_timestamp_date(date)
                                            } else {
                                                date
                                            }
                                        } else {
                                            date
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_ADD".to_string(),
                                            vec![Expression::string("DAY"), days, cast_date],
                                        ))))
                                    }
                                    DialectType::BigQuery => {
                                        // For Hive/Spark source, wrap date in CAST(CAST(date AS DATETIME) AS DATE)
                                        let cast_date = if matches!(
                                            source,
                                            DialectType::Hive
                                                | DialectType::Spark
                                                | DialectType::Databricks
                                        ) {
                                            Self::double_cast_datetime_date(date)
                                        } else {
                                            date
                                        };
                                        // Wrap complex expressions in Paren for interval
                                        let interval_val = if matches!(
                                            days,
                                            Expression::Mul(_)
                                                | Expression::Sub(_)
                                                | Expression::Add(_)
                                        ) {
                                            Expression::Paren(Box::new(crate::expressions::Paren {
                                                this: days,
                                                trailing_comments: vec![],
                                            }))
                                        } else {
                                            days
                                        };
                                        let interval = Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(interval_val),
                                                unit: Some(
                                                    crate::expressions::IntervalUnitSpec::Simple {
                                                        unit: crate::expressions::IntervalUnit::Day,
                                                        use_plural: false,
                                                    },
                                                ),
                                            },
                                        ));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_ADD".to_string(),
                                            vec![cast_date, interval],
                                        ))))
                                    }
                                    DialectType::MySQL => {
                                        let iu = crate::expressions::IntervalUnit::Day;
                                        Ok(Expression::DateAdd(Box::new(
                                            crate::expressions::DateAddFunc {
                                                this: date,
                                                interval: days,
                                                unit: iu,
                                            },
                                        )))
                                    }
                                    DialectType::PostgreSQL => {
                                        let interval = Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(Expression::string(&format!(
                                                    "{} DAY",
                                                    Self::expr_to_string_static(&days)
                                                ))),
                                                unit: None,
                                            },
                                        ));
                                        Ok(Expression::Add(Box::new(
                                            crate::expressions::BinaryOp::new(date, interval),
                                        )))
                                    }
                                    DialectType::Doris
                                    | DialectType::StarRocks
                                    | DialectType::Drill => {
                                        // DATE_ADD(date, INTERVAL days DAY)
                                        let interval = Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(days),
                                                unit: Some(
                                                    crate::expressions::IntervalUnitSpec::Simple {
                                                        unit: crate::expressions::IntervalUnit::Day,
                                                        use_plural: false,
                                                    },
                                                ),
                                            },
                                        ));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_ADD".to_string(),
                                            vec![date, interval],
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "DATE_ADD".to_string(),
                                        vec![date, days],
                                    )))),
                                }
                            }
                            // DATE_SUB(date, days) - 2-arg Hive/Spark form (subtract days)
                            "DATE_SUB"
                                if f.args.len() == 2
                                    && matches!(
                                        source,
                                        DialectType::Hive
                                            | DialectType::Spark
                                            | DialectType::Databricks
                                    ) =>
                            {
                                let mut args = f.args;
                                let date = args.remove(0);
                                let days = args.remove(0);
                                // Helper to create days * -1
                                let make_neg_days = |d: Expression| -> Expression {
                                    Expression::Mul(Box::new(crate::expressions::BinaryOp::new(
                                        d,
                                        Expression::Literal(Literal::Number("-1".to_string())),
                                    )))
                                };
                                let is_string_literal =
                                    matches!(date, Expression::Literal(Literal::String(_)));
                                match target {
                                    DialectType::Hive
                                    | DialectType::Spark
                                    | DialectType::Databricks => {
                                        // Keep as DATE_SUB(date, days) for Hive/Spark
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_SUB".to_string(),
                                            vec![date, days],
                                        ))))
                                    }
                                    DialectType::DuckDB => {
                                        let cast_date = Self::ensure_cast_date(date);
                                        let neg = make_neg_days(days);
                                        let interval = Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(Expression::Paren(Box::new(
                                                    crate::expressions::Paren {
                                                        this: neg,
                                                        trailing_comments: vec![],
                                                    },
                                                ))),
                                                unit: Some(
                                                    crate::expressions::IntervalUnitSpec::Simple {
                                                        unit: crate::expressions::IntervalUnit::Day,
                                                        use_plural: false,
                                                    },
                                                ),
                                            },
                                        ));
                                        Ok(Expression::Add(Box::new(
                                            crate::expressions::BinaryOp::new(cast_date, interval),
                                        )))
                                    }
                                    DialectType::Snowflake => {
                                        let cast_date = if is_string_literal {
                                            Self::double_cast_timestamp_date(date)
                                        } else {
                                            date
                                        };
                                        let neg = make_neg_days(days);
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEADD".to_string(),
                                            vec![
                                                Expression::Identifier(Identifier::new("DAY")),
                                                neg,
                                                cast_date,
                                            ],
                                        ))))
                                    }
                                    DialectType::Redshift => {
                                        let neg = make_neg_days(days);
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEADD".to_string(),
                                            vec![
                                                Expression::Identifier(Identifier::new("DAY")),
                                                neg,
                                                date,
                                            ],
                                        ))))
                                    }
                                    DialectType::TSQL | DialectType::Fabric => {
                                        let cast_date = if is_string_literal {
                                            Self::double_cast_datetime2_date(date)
                                        } else {
                                            date
                                        };
                                        let neg = make_neg_days(days);
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEADD".to_string(),
                                            vec![
                                                Expression::Identifier(Identifier::new("DAY")),
                                                neg,
                                                cast_date,
                                            ],
                                        ))))
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        let cast_date = if is_string_literal {
                                            Self::double_cast_timestamp_date(date)
                                        } else {
                                            date
                                        };
                                        let neg = make_neg_days(days);
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_ADD".to_string(),
                                            vec![Expression::string("DAY"), neg, cast_date],
                                        ))))
                                    }
                                    DialectType::BigQuery => {
                                        let cast_date = if is_string_literal {
                                            Self::double_cast_datetime_date(date)
                                        } else {
                                            date
                                        };
                                        let neg = make_neg_days(days);
                                        let interval = Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(Expression::Paren(Box::new(
                                                    crate::expressions::Paren {
                                                        this: neg,
                                                        trailing_comments: vec![],
                                                    },
                                                ))),
                                                unit: Some(
                                                    crate::expressions::IntervalUnitSpec::Simple {
                                                        unit: crate::expressions::IntervalUnit::Day,
                                                        use_plural: false,
                                                    },
                                                ),
                                            },
                                        ));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_ADD".to_string(),
                                            vec![cast_date, interval],
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "DATE_SUB".to_string(),
                                        vec![date, days],
                                    )))),
                                }
                            }
                            // ADD_MONTHS(date, val) -> target-specific
                            "ADD_MONTHS" if f.args.len() == 2 => {
                                let mut args = f.args;
                                let date = args.remove(0);
                                let val = args.remove(0);
                                match target {
                                    DialectType::TSQL => {
                                        let cast_date = Self::ensure_cast_datetime2(date);
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEADD".to_string(),
                                            vec![
                                                Expression::Identifier(Identifier::new("MONTH")),
                                                val,
                                                cast_date,
                                            ],
                                        ))))
                                    }
                                    DialectType::DuckDB => {
                                        let interval = Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(val),
                                                unit: Some(
                                                    crate::expressions::IntervalUnitSpec::Simple {
                                                        unit:
                                                            crate::expressions::IntervalUnit::Month,
                                                        use_plural: false,
                                                    },
                                                ),
                                            },
                                        ));
                                        Ok(Expression::Add(Box::new(
                                            crate::expressions::BinaryOp::new(date, interval),
                                        )))
                                    }
                                    DialectType::Snowflake => {
                                        // Keep ADD_MONTHS when source is Snowflake
                                        if matches!(source, DialectType::Snowflake) {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "ADD_MONTHS".to_string(),
                                                vec![date, val],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATEADD".to_string(),
                                                vec![
                                                    Expression::Identifier(Identifier::new(
                                                        "MONTH",
                                                    )),
                                                    val,
                                                    date,
                                                ],
                                            ))))
                                        }
                                    }
                                    DialectType::Redshift => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEADD".to_string(),
                                            vec![
                                                Expression::Identifier(Identifier::new("MONTH")),
                                                val,
                                                date,
                                            ],
                                        ))))
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_ADD".to_string(),
                                            vec![Expression::string("MONTH"), val, date],
                                        ))))
                                    }
                                    DialectType::BigQuery => {
                                        let interval = Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(val),
                                                unit: Some(
                                                    crate::expressions::IntervalUnitSpec::Simple {
                                                        unit:
                                                            crate::expressions::IntervalUnit::Month,
                                                        use_plural: false,
                                                    },
                                                ),
                                            },
                                        ));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_ADD".to_string(),
                                            vec![date, interval],
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "ADD_MONTHS".to_string(),
                                        vec![date, val],
                                    )))),
                                }
                            }
                            // DATETRUNC(unit, date) - TSQL form -> DATE_TRUNC for other targets
                            "DATETRUNC" if f.args.len() == 2 => {
                                let mut args = f.args;
                                let arg0 = args.remove(0);
                                let arg1 = args.remove(0);
                                let unit_str = Self::get_unit_str_static(&arg0);
                                match target {
                                    DialectType::TSQL | DialectType::Fabric => {
                                        // Keep as DATETRUNC for TSQL - the target handler will uppercase the unit
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATETRUNC".to_string(),
                                            vec![
                                                Expression::Identifier(Identifier::new(&unit_str)),
                                                arg1,
                                            ],
                                        ))))
                                    }
                                    DialectType::DuckDB => {
                                        // DuckDB: DATE_TRUNC('UNIT', expr) with CAST for string literals
                                        let date = Self::ensure_cast_timestamp(arg1);
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_TRUNC".to_string(),
                                            vec![Expression::string(&unit_str), date],
                                        ))))
                                    }
                                    DialectType::ClickHouse => {
                                        // ClickHouse: dateTrunc('UNIT', expr)
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "dateTrunc".to_string(),
                                            vec![Expression::string(&unit_str), arg1],
                                        ))))
                                    }
                                    _ => {
                                        // Standard: DATE_TRUNC('UNIT', expr)
                                        let unit = Expression::string(&unit_str);
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_TRUNC".to_string(),
                                            vec![unit, arg1],
                                        ))))
                                    }
                                }
                            }
                            // GETDATE() -> CURRENT_TIMESTAMP for non-TSQL targets
                            "GETDATE" if f.args.is_empty() => match target {
                                DialectType::TSQL => Ok(Expression::Function(f)),
                                DialectType::Redshift => Ok(Expression::Function(Box::new(
                                    Function::new("GETDATE".to_string(), vec![]),
                                ))),
                                _ => Ok(Expression::CurrentTimestamp(
                                    crate::expressions::CurrentTimestamp {
                                        precision: None,
                                        sysdate: false,
                                    },
                                )),
                            },
                            // TO_HEX(x) / HEX(x) -> target-specific hex function
                            "TO_HEX" | "HEX" if f.args.len() == 1 => {
                                let name = match target {
                                    DialectType::Presto | DialectType::Trino => "TO_HEX",
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => "HEX",
                                    DialectType::DuckDB
                                    | DialectType::PostgreSQL
                                    | DialectType::Redshift => "TO_HEX",
                                    _ => &f.name,
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // FROM_HEX(x) / UNHEX(x) -> target-specific hex decode function
                            "FROM_HEX" | "UNHEX" if f.args.len() == 1 => {
                                match target {
                                    DialectType::BigQuery => {
                                        // BigQuery: UNHEX(x) -> FROM_HEX(x)
                                        // Special case: UNHEX(MD5(x)) -> FROM_HEX(TO_HEX(MD5(x)))
                                        // because BigQuery MD5 returns BYTES, not hex string
                                        let arg = &f.args[0];
                                        let wrapped_arg = match arg {
                                            Expression::Function(inner_f)
                                                if inner_f.name.to_uppercase() == "MD5"
                                                    || inner_f.name.to_uppercase() == "SHA1"
                                                    || inner_f.name.to_uppercase() == "SHA256"
                                                    || inner_f.name.to_uppercase() == "SHA512" =>
                                            {
                                                // Wrap hash function in TO_HEX for BigQuery
                                                Expression::Function(Box::new(Function::new(
                                                    "TO_HEX".to_string(),
                                                    vec![arg.clone()],
                                                )))
                                            }
                                            _ => f.args.into_iter().next().unwrap(),
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "FROM_HEX".to_string(),
                                            vec![wrapped_arg],
                                        ))))
                                    }
                                    _ => {
                                        let name = match target {
                                            DialectType::Presto | DialectType::Trino => "FROM_HEX",
                                            DialectType::Spark
                                            | DialectType::Databricks
                                            | DialectType::Hive => "UNHEX",
                                            _ => &f.name,
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            name.to_string(),
                                            f.args,
                                        ))))
                                    }
                                }
                            }
                            // TO_UTF8(x) -> ENCODE(x, 'utf-8') for Spark
                            "TO_UTF8" if f.args.len() == 1 => match target {
                                DialectType::Spark | DialectType::Databricks => {
                                    let mut args = f.args;
                                    args.push(Expression::string("utf-8"));
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "ENCODE".to_string(),
                                        args,
                                    ))))
                                }
                                _ => Ok(Expression::Function(f)),
                            },
                            // FROM_UTF8(x) -> DECODE(x, 'utf-8') for Spark
                            "FROM_UTF8" if f.args.len() == 1 => match target {
                                DialectType::Spark | DialectType::Databricks => {
                                    let mut args = f.args;
                                    args.push(Expression::string("utf-8"));
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "DECODE".to_string(),
                                        args,
                                    ))))
                                }
                                _ => Ok(Expression::Function(f)),
                            },
                            // STARTS_WITH(x, y) / STARTSWITH(x, y) -> target-specific
                            "STARTS_WITH" | "STARTSWITH" if f.args.len() == 2 => {
                                let name = match target {
                                    DialectType::Spark | DialectType::Databricks => "STARTSWITH",
                                    DialectType::Presto | DialectType::Trino => "STARTS_WITH",
                                    DialectType::PostgreSQL | DialectType::Redshift => {
                                        "STARTS_WITH"
                                    }
                                    _ => &f.name,
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // APPROX_COUNT_DISTINCT(x) <-> APPROX_DISTINCT(x)
                            "APPROX_COUNT_DISTINCT" if f.args.len() >= 1 => {
                                let name = match target {
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => "APPROX_DISTINCT",
                                    _ => "APPROX_COUNT_DISTINCT",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // JSON_EXTRACT -> GET_JSON_OBJECT for Spark/Hive
                            "JSON_EXTRACT"
                                if f.args.len() == 2
                                    && !matches!(source, DialectType::BigQuery)
                                    && matches!(
                                        target,
                                        DialectType::Spark
                                            | DialectType::Databricks
                                            | DialectType::Hive
                                    ) =>
                            {
                                Ok(Expression::Function(Box::new(Function::new(
                                    "GET_JSON_OBJECT".to_string(),
                                    f.args,
                                ))))
                            }
                            // JSON_EXTRACT(x, path) -> x -> path for SQLite (arrow syntax)
                            "JSON_EXTRACT"
                                if f.args.len() == 2 && matches!(target, DialectType::SQLite) =>
                            {
                                let mut args = f.args;
                                let path = args.remove(1);
                                let this = args.remove(0);
                                Ok(Expression::JsonExtract(Box::new(
                                    crate::expressions::JsonExtractFunc {
                                        this,
                                        path,
                                        returning: None,
                                        arrow_syntax: true,
                                        hash_arrow_syntax: false,
                                        wrapper_option: None,
                                        quotes_option: None,
                                        on_scalar_string: false,
                                        on_error: None,
                                    },
                                )))
                            }
                            // JSON_FORMAT(x) -> TO_JSON(x) for Spark, TO_JSON_STRING for BigQuery, CAST(TO_JSON(x) AS TEXT) for DuckDB
                            "JSON_FORMAT" if f.args.len() == 1 => {
                                match target {
                                    DialectType::Spark | DialectType::Databricks => {
                                        // Presto JSON_FORMAT(JSON '...') needs Spark's string-unquoting flow:
                                        // REGEXP_EXTRACT(TO_JSON(FROM_JSON('[...]', SCHEMA_OF_JSON('[...]'))), '^.(.*).$', 1)
                                        if matches!(
                                            source,
                                            DialectType::Presto
                                                | DialectType::Trino
                                                | DialectType::Athena
                                        ) {
                                            if let Some(Expression::ParseJson(pj)) = f.args.first()
                                            {
                                                if let Expression::Literal(Literal::String(s)) =
                                                    &pj.this
                                                {
                                                    let wrapped = Expression::Literal(
                                                        Literal::String(format!("[{}]", s)),
                                                    );
                                                    let schema_of_json = Expression::Function(
                                                        Box::new(Function::new(
                                                            "SCHEMA_OF_JSON".to_string(),
                                                            vec![wrapped.clone()],
                                                        )),
                                                    );
                                                    let from_json = Expression::Function(Box::new(
                                                        Function::new(
                                                            "FROM_JSON".to_string(),
                                                            vec![wrapped, schema_of_json],
                                                        ),
                                                    ));
                                                    let to_json = Expression::Function(Box::new(
                                                        Function::new(
                                                            "TO_JSON".to_string(),
                                                            vec![from_json],
                                                        ),
                                                    ));
                                                    return Ok(Expression::Function(Box::new(
                                                        Function::new(
                                                            "REGEXP_EXTRACT".to_string(),
                                                            vec![
                                                                to_json,
                                                                Expression::Literal(
                                                                    Literal::String(
                                                                        "^.(.*).$".to_string(),
                                                                    ),
                                                                ),
                                                                Expression::Literal(
                                                                    Literal::Number(
                                                                        "1".to_string(),
                                                                    ),
                                                                ),
                                                            ],
                                                        ),
                                                    )));
                                                }
                                            }
                                        }

                                        // Strip inner CAST(... AS JSON) or TO_JSON() if present
                                        // The CastToJsonForSpark may have already converted CAST(x AS JSON) to TO_JSON(x)
                                        let mut args = f.args;
                                        if let Some(Expression::Cast(ref c)) = args.first() {
                                            if matches!(&c.to, DataType::Json | DataType::JsonB) {
                                                args = vec![c.this.clone()];
                                            }
                                        } else if let Some(Expression::Function(ref inner_f)) =
                                            args.first()
                                        {
                                            if inner_f.name.eq_ignore_ascii_case("TO_JSON")
                                                && inner_f.args.len() == 1
                                            {
                                                // Already TO_JSON(x) from CastToJsonForSpark, just use the inner arg
                                                args = inner_f.args.clone();
                                            }
                                        }
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "TO_JSON".to_string(),
                                            args,
                                        ))))
                                    }
                                    DialectType::BigQuery => Ok(Expression::Function(Box::new(
                                        Function::new("TO_JSON_STRING".to_string(), f.args),
                                    ))),
                                    DialectType::DuckDB => {
                                        // CAST(TO_JSON(x) AS TEXT)
                                        let to_json = Expression::Function(Box::new(
                                            Function::new("TO_JSON".to_string(), f.args),
                                        ));
                                        Ok(Expression::Cast(Box::new(Cast {
                                            this: to_json,
                                            to: DataType::Text,
                                            trailing_comments: Vec::new(),
                                            double_colon_syntax: false,
                                            format: None,
                                            default: None,
                                        })))
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // SYSDATE -> CURRENT_TIMESTAMP for non-Oracle/Redshift/Snowflake targets
                            "SYSDATE" if f.args.is_empty() => {
                                match target {
                                    DialectType::Oracle | DialectType::Redshift => {
                                        Ok(Expression::Function(f))
                                    }
                                    DialectType::Snowflake => {
                                        // Snowflake uses SYSDATE() with parens
                                        let mut f = *f;
                                        f.no_parens = false;
                                        Ok(Expression::Function(Box::new(f)))
                                    }
                                    DialectType::DuckDB => {
                                        // DuckDB: SYSDATE() -> CURRENT_TIMESTAMP AT TIME ZONE 'UTC'
                                        Ok(Expression::AtTimeZone(Box::new(
                                            crate::expressions::AtTimeZone {
                                                this: Expression::CurrentTimestamp(
                                                    crate::expressions::CurrentTimestamp {
                                                        precision: None,
                                                        sysdate: false,
                                                    },
                                                ),
                                                zone: Expression::Literal(Literal::String(
                                                    "UTC".to_string(),
                                                )),
                                            },
                                        )))
                                    }
                                    _ => Ok(Expression::CurrentTimestamp(
                                        crate::expressions::CurrentTimestamp {
                                            precision: None,
                                            sysdate: true,
                                        },
                                    )),
                                }
                            }
                            // LOGICAL_OR(x) -> BOOL_OR(x)
                            "LOGICAL_OR" if f.args.len() == 1 => {
                                let name = match target {
                                    DialectType::Spark | DialectType::Databricks => "BOOL_OR",
                                    _ => &f.name,
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // LOGICAL_AND(x) -> BOOL_AND(x)
                            "LOGICAL_AND" if f.args.len() == 1 => {
                                let name = match target {
                                    DialectType::Spark | DialectType::Databricks => "BOOL_AND",
                                    _ => &f.name,
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // MONTHS_ADD(d, n) -> ADD_MONTHS(d, n) for Oracle
                            "MONTHS_ADD" if f.args.len() == 2 => match target {
                                DialectType::Oracle => Ok(Expression::Function(Box::new(
                                    Function::new("ADD_MONTHS".to_string(), f.args),
                                ))),
                                _ => Ok(Expression::Function(f)),
                            },
                            // ARRAY_JOIN(arr, sep[, null_replacement]) -> target-specific
                            "ARRAY_JOIN" if f.args.len() >= 2 => {
                                match target {
                                    DialectType::Spark | DialectType::Databricks => {
                                        // Keep as ARRAY_JOIN for Spark (it supports null_replacement)
                                        Ok(Expression::Function(f))
                                    }
                                    DialectType::Hive => {
                                        // ARRAY_JOIN(arr, sep[, null_rep]) -> CONCAT_WS(sep, arr) (drop null_replacement)
                                        let mut args = f.args;
                                        let arr = args.remove(0);
                                        let sep = args.remove(0);
                                        // Drop any remaining args (null_replacement)
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "CONCAT_WS".to_string(),
                                            vec![sep, arr],
                                        ))))
                                    }
                                    DialectType::Presto | DialectType::Trino => {
                                        Ok(Expression::Function(f))
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // LOCATE(substr, str, pos) 3-arg -> target-specific
                            // For Presto/DuckDB: STRPOS doesn't support 3-arg, need complex expansion
                            "LOCATE"
                                if f.args.len() == 3
                                    && matches!(
                                        target,
                                        DialectType::Presto
                                            | DialectType::Trino
                                            | DialectType::Athena
                                            | DialectType::DuckDB
                                    ) =>
                            {
                                let mut args = f.args;
                                let substr = args.remove(0);
                                let string = args.remove(0);
                                let pos = args.remove(0);
                                // STRPOS(SUBSTRING(string, pos), substr)
                                let substring_call = Expression::Function(Box::new(Function::new(
                                    "SUBSTRING".to_string(),
                                    vec![string.clone(), pos.clone()],
                                )));
                                let strpos_call = Expression::Function(Box::new(Function::new(
                                    "STRPOS".to_string(),
                                    vec![substring_call, substr.clone()],
                                )));
                                // STRPOS(...) + pos - 1
                                let pos_adjusted =
                                    Expression::Sub(Box::new(crate::expressions::BinaryOp::new(
                                        Expression::Add(Box::new(
                                            crate::expressions::BinaryOp::new(
                                                strpos_call.clone(),
                                                pos.clone(),
                                            ),
                                        )),
                                        Expression::number(1),
                                    )));
                                // STRPOS(...) = 0
                                let is_zero =
                                    Expression::Eq(Box::new(crate::expressions::BinaryOp::new(
                                        strpos_call.clone(),
                                        Expression::number(0),
                                    )));

                                match target {
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        // IF(STRPOS(...) = 0, 0, STRPOS(...) + pos - 1)
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "IF".to_string(),
                                            vec![is_zero, Expression::number(0), pos_adjusted],
                                        ))))
                                    }
                                    DialectType::DuckDB => {
                                        // CASE WHEN STRPOS(...) = 0 THEN 0 ELSE STRPOS(...) + pos - 1 END
                                        Ok(Expression::Case(Box::new(crate::expressions::Case {
                                            operand: None,
                                            whens: vec![(is_zero, Expression::number(0))],
                                            else_: Some(pos_adjusted),
                                            comments: Vec::new(),
                                        })))
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "LOCATE".to_string(),
                                        vec![substr, string, pos],
                                    )))),
                                }
                            }
                            // STRPOS(haystack, needle, occurrence) 3-arg -> INSTR(haystack, needle, 1, occurrence)
                            "STRPOS"
                                if f.args.len() == 3
                                    && matches!(
                                        target,
                                        DialectType::BigQuery
                                            | DialectType::Oracle
                                            | DialectType::Teradata
                                    ) =>
                            {
                                let mut args = f.args;
                                let haystack = args.remove(0);
                                let needle = args.remove(0);
                                let occurrence = args.remove(0);
                                Ok(Expression::Function(Box::new(Function::new(
                                    "INSTR".to_string(),
                                    vec![haystack, needle, Expression::number(1), occurrence],
                                ))))
                            }
                            // SCHEMA_NAME(id) -> target-specific
                            "SCHEMA_NAME" if f.args.len() <= 1 => match target {
                                DialectType::MySQL | DialectType::SingleStore => {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "SCHEMA".to_string(),
                                        vec![],
                                    ))))
                                }
                                DialectType::PostgreSQL => Ok(Expression::CurrentSchema(Box::new(
                                    crate::expressions::CurrentSchema { this: None },
                                ))),
                                DialectType::SQLite => Ok(Expression::string("main")),
                                _ => Ok(Expression::Function(f)),
                            },
                            // STRTOL(str, base) -> FROM_BASE(str, base) for Trino/Presto
                            "STRTOL" if f.args.len() == 2 => match target {
                                DialectType::Presto | DialectType::Trino => {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "FROM_BASE".to_string(),
                                        f.args,
                                    ))))
                                }
                                _ => Ok(Expression::Function(f)),
                            },
                            // EDITDIST3(a, b) -> LEVENSHTEIN(a, b) for Spark
                            "EDITDIST3" if f.args.len() == 2 => match target {
                                DialectType::Spark | DialectType::Databricks => {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "LEVENSHTEIN".to_string(),
                                        f.args,
                                    ))))
                                }
                                _ => Ok(Expression::Function(f)),
                            },
                            // FORMAT(num, decimals) from MySQL -> DuckDB FORMAT('{:,.Xf}', num)
                            "FORMAT"
                                if f.args.len() == 2
                                    && matches!(
                                        source,
                                        DialectType::MySQL | DialectType::SingleStore
                                    )
                                    && matches!(target, DialectType::DuckDB) =>
                            {
                                let mut args = f.args;
                                let num_expr = args.remove(0);
                                let decimals_expr = args.remove(0);
                                // Extract decimal count
                                let dec_count = match &decimals_expr {
                                    Expression::Literal(Literal::Number(n)) => n.clone(),
                                    _ => "0".to_string(),
                                };
                                let fmt_str = format!("{{:,.{}f}}", dec_count);
                                Ok(Expression::Function(Box::new(Function::new(
                                    "FORMAT".to_string(),
                                    vec![Expression::string(&fmt_str), num_expr],
                                ))))
                            }
                            // FORMAT(x, fmt) from TSQL -> DATE_FORMAT for Spark, or expand short codes
                            "FORMAT"
                                if f.args.len() == 2
                                    && matches!(
                                        source,
                                        DialectType::TSQL | DialectType::Fabric
                                    ) =>
                            {
                                let val_expr = f.args[0].clone();
                                let fmt_expr = f.args[1].clone();
                                // Expand unambiguous .NET single-char date format shortcodes to full patterns.
                                // Only expand shortcodes that are NOT also valid numeric format specifiers.
                                // Ambiguous: d, D, f, F, g, G (used for both dates and numbers)
                                // Unambiguous date: m/M (Month day), t/T (Time), y/Y (Year month)
                                let (expanded_fmt, is_shortcode) = match &fmt_expr {
                                    Expression::Literal(crate::expressions::Literal::String(s)) => {
                                        match s.as_str() {
                                            "m" | "M" => (Expression::string("MMMM d"), true),
                                            "t" => (Expression::string("h:mm tt"), true),
                                            "T" => (Expression::string("h:mm:ss tt"), true),
                                            "y" | "Y" => (Expression::string("MMMM yyyy"), true),
                                            _ => (fmt_expr.clone(), false),
                                        }
                                    }
                                    _ => (fmt_expr.clone(), false),
                                };
                                // Check if the format looks like a date format
                                let is_date_format = is_shortcode
                                    || match &expanded_fmt {
                                        Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) => {
                                            // Date formats typically contain yyyy, MM, dd, MMMM, HH, etc.
                                            s.contains("yyyy")
                                                || s.contains("YYYY")
                                                || s.contains("MM")
                                                || s.contains("dd")
                                                || s.contains("MMMM")
                                                || s.contains("HH")
                                                || s.contains("hh")
                                                || s.contains("ss")
                                        }
                                        _ => false,
                                    };
                                match target {
                                    DialectType::Spark | DialectType::Databricks => {
                                        let func_name = if is_date_format {
                                            "DATE_FORMAT"
                                        } else {
                                            "FORMAT_NUMBER"
                                        };
                                        Ok(Expression::Function(Box::new(Function::new(
                                            func_name.to_string(),
                                            vec![val_expr, expanded_fmt],
                                        ))))
                                    }
                                    _ => {
                                        // For TSQL and other targets, expand shortcodes but keep FORMAT
                                        if is_shortcode {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "FORMAT".to_string(),
                                                vec![val_expr, expanded_fmt],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(f))
                                        }
                                    }
                                }
                            }
                            // FORMAT('%s', x) from Trino/Presto -> target-specific
                            "FORMAT"
                                if f.args.len() >= 2
                                    && matches!(
                                        source,
                                        DialectType::Trino
                                            | DialectType::Presto
                                            | DialectType::Athena
                                    ) =>
                            {
                                let fmt_expr = f.args[0].clone();
                                let value_args: Vec<Expression> = f.args[1..].to_vec();
                                match target {
                                    // DuckDB: replace %s with {} in format string
                                    DialectType::DuckDB => {
                                        let new_fmt = match &fmt_expr {
                                            Expression::Literal(Literal::String(s)) => {
                                                Expression::Literal(Literal::String(
                                                    s.replace("%s", "{}"),
                                                ))
                                            }
                                            _ => fmt_expr,
                                        };
                                        let mut args = vec![new_fmt];
                                        args.extend(value_args);
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "FORMAT".to_string(),
                                            args,
                                        ))))
                                    }
                                    // Snowflake: FORMAT('%s', x) -> TO_CHAR(x) when just %s
                                    DialectType::Snowflake => match &fmt_expr {
                                        Expression::Literal(Literal::String(s))
                                            if s == "%s" && value_args.len() == 1 =>
                                        {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "TO_CHAR".to_string(),
                                                value_args,
                                            ))))
                                        }
                                        _ => Ok(Expression::Function(f)),
                                    },
                                    // Default: keep FORMAT as-is
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // LIST_CONTAINS / LIST_HAS / ARRAY_CONTAINS -> target-specific
                            "LIST_CONTAINS" | "LIST_HAS" | "ARRAY_CONTAINS"
                                if f.args.len() == 2 =>
                            {
                                match target {
                                    DialectType::PostgreSQL | DialectType::Redshift => {
                                        // CASE WHEN needle IS NULL THEN NULL ELSE COALESCE(needle = ANY(arr), FALSE) END
                                        let arr = f.args[0].clone();
                                        let needle = f.args[1].clone();
                                        // Convert [] to ARRAY[] for PostgreSQL
                                        let pg_arr = match arr {
                                            Expression::Array(a) => Expression::ArrayFunc(
                                                Box::new(crate::expressions::ArrayConstructor {
                                                    expressions: a.expressions,
                                                    bracket_notation: false,
                                                    use_list_keyword: false,
                                                }),
                                            ),
                                            _ => arr,
                                        };
                                        // needle = ANY(arr) using the Any quantified expression
                                        let any_expr = Expression::Any(Box::new(
                                            crate::expressions::QuantifiedExpr {
                                                this: needle.clone(),
                                                subquery: pg_arr,
                                                op: Some(crate::expressions::QuantifiedOp::Eq),
                                            },
                                        ));
                                        let coalesce = Expression::Coalesce(Box::new(
                                            crate::expressions::VarArgFunc {
                                                expressions: vec![
                                                    any_expr,
                                                    Expression::Boolean(
                                                        crate::expressions::BooleanLiteral {
                                                            value: false,
                                                        },
                                                    ),
                                                ],
                                                original_name: None,
                                            },
                                        ));
                                        let is_null_check = Expression::IsNull(Box::new(
                                            crate::expressions::IsNull {
                                                this: needle,
                                                not: false,
                                                postfix_form: false,
                                            },
                                        ));
                                        Ok(Expression::Case(Box::new(Case {
                                            operand: None,
                                            whens: vec![(
                                                is_null_check,
                                                Expression::Null(crate::expressions::Null),
                                            )],
                                            else_: Some(coalesce),
                                            comments: Vec::new(),
                                        })))
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "ARRAY_CONTAINS".to_string(),
                                        f.args,
                                    )))),
                                }
                            }
                            // LIST_HAS_ANY / ARRAY_HAS_ANY -> target-specific overlap operator
                            "LIST_HAS_ANY" | "ARRAY_HAS_ANY" if f.args.len() == 2 => {
                                match target {
                                    DialectType::PostgreSQL | DialectType::Redshift => {
                                        // arr1 && arr2 with ARRAY[] syntax
                                        let mut args = f.args;
                                        let arr1 = args.remove(0);
                                        let arr2 = args.remove(0);
                                        let pg_arr1 = match arr1 {
                                            Expression::Array(a) => Expression::ArrayFunc(
                                                Box::new(crate::expressions::ArrayConstructor {
                                                    expressions: a.expressions,
                                                    bracket_notation: false,
                                                    use_list_keyword: false,
                                                }),
                                            ),
                                            _ => arr1,
                                        };
                                        let pg_arr2 = match arr2 {
                                            Expression::Array(a) => Expression::ArrayFunc(
                                                Box::new(crate::expressions::ArrayConstructor {
                                                    expressions: a.expressions,
                                                    bracket_notation: false,
                                                    use_list_keyword: false,
                                                }),
                                            ),
                                            _ => arr2,
                                        };
                                        Ok(Expression::ArrayOverlaps(Box::new(BinaryOp::new(
                                            pg_arr1, pg_arr2,
                                        ))))
                                    }
                                    DialectType::DuckDB => {
                                        // DuckDB: arr1 && arr2 (native support)
                                        let mut args = f.args;
                                        let arr1 = args.remove(0);
                                        let arr2 = args.remove(0);
                                        Ok(Expression::ArrayOverlaps(Box::new(BinaryOp::new(
                                            arr1, arr2,
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "LIST_HAS_ANY".to_string(),
                                        f.args,
                                    )))),
                                }
                            }
                            // APPROX_QUANTILE(x, q) -> target-specific
                            "APPROX_QUANTILE" if f.args.len() == 2 => match target {
                                DialectType::Snowflake => Ok(Expression::Function(Box::new(
                                    Function::new("APPROX_PERCENTILE".to_string(), f.args),
                                ))),
                                DialectType::DuckDB => Ok(Expression::Function(f)),
                                _ => Ok(Expression::Function(f)),
                            },
                            // MAKE_DATE(y, m, d) -> DATE(y, m, d) for BigQuery
                            "MAKE_DATE" if f.args.len() == 3 => match target {
                                DialectType::BigQuery => Ok(Expression::Function(Box::new(
                                    Function::new("DATE".to_string(), f.args),
                                ))),
                                _ => Ok(Expression::Function(f)),
                            },
                            // RANGE(start, end[, step]) -> target-specific
                            "RANGE"
                                if f.args.len() >= 2 && !matches!(target, DialectType::DuckDB) =>
                            {
                                let start = f.args[0].clone();
                                let end = f.args[1].clone();
                                let step = f.args.get(2).cloned();
                                match target {
                                    DialectType::Spark | DialectType::Databricks => {
                                        // RANGE(start, end) -> SEQUENCE(start, end-1)
                                        // RANGE(start, end, step) -> SEQUENCE(start, end-step, step) when step constant
                                        // RANGE(start, start) -> ARRAY() (empty)
                                        // RANGE(start, end, 0) -> ARRAY() (empty)
                                        // When end is variable: IF((end - 1) <= start, ARRAY(), SEQUENCE(start, (end - 1)))

                                        // Check for constant args
                                        fn extract_i64(e: &Expression) -> Option<i64> {
                                            match e {
                                                Expression::Literal(Literal::Number(n)) => {
                                                    n.parse::<i64>().ok()
                                                }
                                                Expression::Neg(u) => {
                                                    if let Expression::Literal(Literal::Number(n)) =
                                                        &u.this
                                                    {
                                                        n.parse::<i64>().ok().map(|v| -v)
                                                    } else {
                                                        None
                                                    }
                                                }
                                                _ => None,
                                            }
                                        }
                                        let start_val = extract_i64(&start);
                                        let end_val = extract_i64(&end);
                                        let step_val = step.as_ref().and_then(|s| extract_i64(s));

                                        // Check for RANGE(x, x) or RANGE(x, y, 0) -> empty array
                                        if step_val == Some(0) {
                                            return Ok(Expression::Function(Box::new(
                                                Function::new("ARRAY".to_string(), vec![]),
                                            )));
                                        }
                                        if let (Some(s), Some(e_val)) = (start_val, end_val) {
                                            if s == e_val {
                                                return Ok(Expression::Function(Box::new(
                                                    Function::new("ARRAY".to_string(), vec![]),
                                                )));
                                            }
                                        }

                                        if let (Some(_s_val), Some(e_val)) = (start_val, end_val) {
                                            // All constants - compute new end = end - step (if step provided) or end - 1
                                            match step_val {
                                                Some(st) if st < 0 => {
                                                    // Negative step: SEQUENCE(start, end - step, step)
                                                    let new_end = e_val - st; // end - step (= end + |step|)
                                                    let mut args =
                                                        vec![start, Expression::number(new_end)];
                                                    if let Some(s) = step {
                                                        args.push(s);
                                                    }
                                                    Ok(Expression::Function(Box::new(
                                                        Function::new("SEQUENCE".to_string(), args),
                                                    )))
                                                }
                                                Some(st) => {
                                                    let new_end = e_val - st;
                                                    let mut args =
                                                        vec![start, Expression::number(new_end)];
                                                    if let Some(s) = step {
                                                        args.push(s);
                                                    }
                                                    Ok(Expression::Function(Box::new(
                                                        Function::new("SEQUENCE".to_string(), args),
                                                    )))
                                                }
                                                None => {
                                                    // No step: SEQUENCE(start, end - 1)
                                                    let new_end = e_val - 1;
                                                    Ok(Expression::Function(Box::new(
                                                        Function::new(
                                                            "SEQUENCE".to_string(),
                                                            vec![
                                                                start,
                                                                Expression::number(new_end),
                                                            ],
                                                        ),
                                                    )))
                                                }
                                            }
                                        } else {
                                            // Variable end: IF((end - 1) <= start, ARRAY(), SEQUENCE(start, (end - 1)))
                                            let end_m1 = Expression::Sub(Box::new(BinaryOp::new(
                                                end.clone(),
                                                Expression::number(1),
                                            )));
                                            let cond = Expression::Lte(Box::new(BinaryOp::new(
                                                Expression::Paren(Box::new(Paren {
                                                    this: end_m1.clone(),
                                                    trailing_comments: Vec::new(),
                                                })),
                                                start.clone(),
                                            )));
                                            let empty = Expression::Function(Box::new(
                                                Function::new("ARRAY".to_string(), vec![]),
                                            ));
                                            let mut seq_args = vec![
                                                start,
                                                Expression::Paren(Box::new(Paren {
                                                    this: end_m1,
                                                    trailing_comments: Vec::new(),
                                                })),
                                            ];
                                            if let Some(s) = step {
                                                seq_args.push(s);
                                            }
                                            let seq = Expression::Function(Box::new(
                                                Function::new("SEQUENCE".to_string(), seq_args),
                                            ));
                                            Ok(Expression::IfFunc(Box::new(
                                                crate::expressions::IfFunc {
                                                    condition: cond,
                                                    true_value: empty,
                                                    false_value: Some(seq),
                                                    original_name: None,
                                                },
                                            )))
                                        }
                                    }
                                    DialectType::SQLite => {
                                        // RANGE(start, end) -> GENERATE_SERIES(start, end)
                                        // The subquery wrapping is handled at the Alias level
                                        let mut args = vec![start, end];
                                        if let Some(s) = step {
                                            args.push(s);
                                        }
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "GENERATE_SERIES".to_string(),
                                            args,
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // ARRAY_REVERSE_SORT -> target-specific
                            // (handled above as well, but also need DuckDB self-normalization)
                            // MAP_FROM_ARRAYS(keys, values) -> target-specific map construction
                            "MAP_FROM_ARRAYS" if f.args.len() == 2 => match target {
                                DialectType::Snowflake => Ok(Expression::Function(Box::new(
                                    Function::new("OBJECT_CONSTRUCT".to_string(), f.args),
                                ))),
                                DialectType::Spark | DialectType::Databricks => {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "MAP_FROM_ARRAYS".to_string(),
                                        f.args,
                                    ))))
                                }
                                _ => Ok(Expression::Function(Box::new(Function::new(
                                    "MAP".to_string(),
                                    f.args,
                                )))),
                            },
                            // VARIANCE(x) -> varSamp(x) for ClickHouse
                            "VARIANCE" if f.args.len() == 1 => match target {
                                DialectType::ClickHouse => Ok(Expression::Function(Box::new(
                                    Function::new("varSamp".to_string(), f.args),
                                ))),
                                _ => Ok(Expression::Function(f)),
                            },
                            // STDDEV(x) -> stddevSamp(x) for ClickHouse
                            "STDDEV" if f.args.len() == 1 => match target {
                                DialectType::ClickHouse => Ok(Expression::Function(Box::new(
                                    Function::new("stddevSamp".to_string(), f.args),
                                ))),
                                _ => Ok(Expression::Function(f)),
                            },
                            // ISINF(x) -> IS_INF(x) for BigQuery
                            "ISINF" if f.args.len() == 1 => match target {
                                DialectType::BigQuery => Ok(Expression::Function(Box::new(
                                    Function::new("IS_INF".to_string(), f.args),
                                ))),
                                _ => Ok(Expression::Function(f)),
                            },
                            // CONTAINS(arr, x) -> ARRAY_CONTAINS(arr, x) for Spark/Hive
                            "CONTAINS" if f.args.len() == 2 => match target {
                                DialectType::Spark
                                | DialectType::Databricks
                                | DialectType::Hive => Ok(Expression::Function(Box::new(
                                    Function::new("ARRAY_CONTAINS".to_string(), f.args),
                                ))),
                                _ => Ok(Expression::Function(f)),
                            },
                            // ARRAY_CONTAINS(arr, x) -> CONTAINS(arr, x) for Presto
                            "ARRAY_CONTAINS" if f.args.len() == 2 => match target {
                                DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "CONTAINS".to_string(),
                                        f.args,
                                    ))))
                                }
                                DialectType::DuckDB => Ok(Expression::Function(Box::new(
                                    Function::new("ARRAY_CONTAINS".to_string(), f.args),
                                ))),
                                _ => Ok(Expression::Function(f)),
                            },
                            // TO_UNIXTIME(x) -> UNIX_TIMESTAMP(x) for Hive/Spark
                            "TO_UNIXTIME" if f.args.len() == 1 => match target {
                                DialectType::Hive
                                | DialectType::Spark
                                | DialectType::Databricks => Ok(Expression::Function(Box::new(
                                    Function::new("UNIX_TIMESTAMP".to_string(), f.args),
                                ))),
                                _ => Ok(Expression::Function(f)),
                            },
                            // FROM_UNIXTIME(x) -> target-specific
                            "FROM_UNIXTIME" if f.args.len() == 1 => {
                                match target {
                                    DialectType::Hive
                                    | DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Presto
                                    | DialectType::Trino => Ok(Expression::Function(f)),
                                    DialectType::DuckDB => {
                                        // DuckDB: TO_TIMESTAMP(x)
                                        let arg = f.args.into_iter().next().unwrap();
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "TO_TIMESTAMP".to_string(),
                                            vec![arg],
                                        ))))
                                    }
                                    DialectType::PostgreSQL => {
                                        // PG: TO_TIMESTAMP(col)
                                        let arg = f.args.into_iter().next().unwrap();
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "TO_TIMESTAMP".to_string(),
                                            vec![arg],
                                        ))))
                                    }
                                    DialectType::Redshift => {
                                        // Redshift: (TIMESTAMP 'epoch' + col * INTERVAL '1 SECOND')
                                        let arg = f.args.into_iter().next().unwrap();
                                        let epoch_ts = Expression::Literal(Literal::Timestamp(
                                            "epoch".to_string(),
                                        ));
                                        let interval = Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(Expression::string("1 SECOND")),
                                                unit: None,
                                            },
                                        ));
                                        let mul =
                                            Expression::Mul(Box::new(BinaryOp::new(arg, interval)));
                                        let add =
                                            Expression::Add(Box::new(BinaryOp::new(epoch_ts, mul)));
                                        Ok(Expression::Paren(Box::new(crate::expressions::Paren {
                                            this: add,
                                            trailing_comments: Vec::new(),
                                        })))
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // FROM_UNIXTIME(x, fmt) with 2 args from Hive/Spark -> target-specific
                            "FROM_UNIXTIME"
                                if f.args.len() == 2
                                    && matches!(
                                        source,
                                        DialectType::Hive
                                            | DialectType::Spark
                                            | DialectType::Databricks
                                    ) =>
                            {
                                let mut args = f.args;
                                let unix_ts = args.remove(0);
                                let fmt_expr = args.remove(0);
                                match target {
                                    DialectType::DuckDB => {
                                        // DuckDB: STRFTIME(TO_TIMESTAMP(x), c_fmt)
                                        let to_ts = Expression::Function(Box::new(Function::new(
                                            "TO_TIMESTAMP".to_string(),
                                            vec![unix_ts],
                                        )));
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = &fmt_expr
                                        {
                                            let c_fmt = Self::hive_format_to_c_format(s);
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "STRFTIME".to_string(),
                                                vec![to_ts, Expression::string(&c_fmt)],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "STRFTIME".to_string(),
                                                vec![to_ts, fmt_expr],
                                            ))))
                                        }
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        // Presto: DATE_FORMAT(FROM_UNIXTIME(x), presto_fmt)
                                        let from_unix =
                                            Expression::Function(Box::new(Function::new(
                                                "FROM_UNIXTIME".to_string(),
                                                vec![unix_ts],
                                            )));
                                        if let Expression::Literal(
                                            crate::expressions::Literal::String(s),
                                        ) = &fmt_expr
                                        {
                                            let p_fmt = Self::hive_format_to_presto_format(s);
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_FORMAT".to_string(),
                                                vec![from_unix, Expression::string(&p_fmt)],
                                            ))))
                                        } else {
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_FORMAT".to_string(),
                                                vec![from_unix, fmt_expr],
                                            ))))
                                        }
                                    }
                                    _ => {
                                        // Keep as FROM_UNIXTIME(x, fmt) for other targets
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "FROM_UNIXTIME".to_string(),
                                            vec![unix_ts, fmt_expr],
                                        ))))
                                    }
                                }
                            }
                            // DATEPART(unit, expr) -> EXTRACT(unit FROM expr) for Spark
                            "DATEPART" | "DATE_PART" if f.args.len() == 2 => {
                                let unit_str = Self::get_unit_str_static(&f.args[0]);
                                // Get the raw unit text preserving original case
                                let raw_unit = match &f.args[0] {
                                    Expression::Identifier(id) => id.name.clone(),
                                    Expression::Literal(crate::expressions::Literal::String(s)) => {
                                        s.clone()
                                    }
                                    Expression::Column(col) => col.name.name.clone(),
                                    _ => unit_str.clone(),
                                };
                                match target {
                                    DialectType::TSQL | DialectType::Fabric => {
                                        // Preserve original case of unit for TSQL
                                        let unit_name = match unit_str.as_str() {
                                            "YY" | "YYYY" => "YEAR".to_string(),
                                            "QQ" | "Q" => "QUARTER".to_string(),
                                            "MM" | "M" => "MONTH".to_string(),
                                            "WK" | "WW" => "WEEK".to_string(),
                                            "DD" | "D" | "DY" => "DAY".to_string(),
                                            "HH" => "HOUR".to_string(),
                                            "MI" | "N" => "MINUTE".to_string(),
                                            "SS" | "S" => "SECOND".to_string(),
                                            _ => raw_unit.clone(), // preserve original case
                                        };
                                        let mut args = f.args;
                                        args[0] =
                                            Expression::Identifier(Identifier::new(&unit_name));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEPART".to_string(),
                                            args,
                                        ))))
                                    }
                                    DialectType::Spark | DialectType::Databricks => {
                                        // DATEPART(unit, expr) -> EXTRACT(unit FROM expr)
                                        // Preserve original case for non-abbreviation units
                                        let unit = match unit_str.as_str() {
                                            "YY" | "YYYY" => "YEAR".to_string(),
                                            "QQ" | "Q" => "QUARTER".to_string(),
                                            "MM" | "M" => "MONTH".to_string(),
                                            "WK" | "WW" => "WEEK".to_string(),
                                            "DD" | "D" | "DY" => "DAY".to_string(),
                                            "HH" => "HOUR".to_string(),
                                            "MI" | "N" => "MINUTE".to_string(),
                                            "SS" | "S" => "SECOND".to_string(),
                                            _ => raw_unit, // preserve original case
                                        };
                                        Ok(Expression::Extract(Box::new(
                                            crate::expressions::ExtractFunc {
                                                this: f.args[1].clone(),
                                                field: crate::expressions::DateTimeField::Custom(
                                                    unit,
                                                ),
                                            },
                                        )))
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "DATE_PART".to_string(),
                                        f.args,
                                    )))),
                                }
                            }
                            // DATENAME(mm, date) -> FORMAT(CAST(date AS DATETIME2), 'MMMM') for TSQL
                            // DATENAME(dw, date) -> FORMAT(CAST(date AS DATETIME2), 'dddd') for TSQL
                            // DATENAME(mm, date) -> DATE_FORMAT(CAST(date AS TIMESTAMP), 'MMMM') for Spark
                            // DATENAME(dw, date) -> DATE_FORMAT(CAST(date AS TIMESTAMP), 'EEEE') for Spark
                            "DATENAME" if f.args.len() == 2 => {
                                let unit_str = Self::get_unit_str_static(&f.args[0]);
                                let date_expr = f.args[1].clone();
                                match unit_str.as_str() {
                                    "MM" | "M" | "MONTH" => match target {
                                        DialectType::TSQL => {
                                            let cast_date = Expression::Cast(Box::new(
                                                crate::expressions::Cast {
                                                    this: date_expr,
                                                    to: DataType::Custom {
                                                        name: "DATETIME2".to_string(),
                                                    },
                                                    trailing_comments: Vec::new(),
                                                    double_colon_syntax: false,
                                                    format: None,
                                                    default: None,
                                                },
                                            ));
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "FORMAT".to_string(),
                                                vec![cast_date, Expression::string("MMMM")],
                                            ))))
                                        }
                                        DialectType::Spark | DialectType::Databricks => {
                                            let cast_date = Expression::Cast(Box::new(
                                                crate::expressions::Cast {
                                                    this: date_expr,
                                                    to: DataType::Timestamp {
                                                        timezone: false,
                                                        precision: None,
                                                    },
                                                    trailing_comments: Vec::new(),
                                                    double_colon_syntax: false,
                                                    format: None,
                                                    default: None,
                                                },
                                            ));
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_FORMAT".to_string(),
                                                vec![cast_date, Expression::string("MMMM")],
                                            ))))
                                        }
                                        _ => Ok(Expression::Function(f)),
                                    },
                                    "DW" | "WEEKDAY" => match target {
                                        DialectType::TSQL => {
                                            let cast_date = Expression::Cast(Box::new(
                                                crate::expressions::Cast {
                                                    this: date_expr,
                                                    to: DataType::Custom {
                                                        name: "DATETIME2".to_string(),
                                                    },
                                                    trailing_comments: Vec::new(),
                                                    double_colon_syntax: false,
                                                    format: None,
                                                    default: None,
                                                },
                                            ));
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "FORMAT".to_string(),
                                                vec![cast_date, Expression::string("dddd")],
                                            ))))
                                        }
                                        DialectType::Spark | DialectType::Databricks => {
                                            let cast_date = Expression::Cast(Box::new(
                                                crate::expressions::Cast {
                                                    this: date_expr,
                                                    to: DataType::Timestamp {
                                                        timezone: false,
                                                        precision: None,
                                                    },
                                                    trailing_comments: Vec::new(),
                                                    double_colon_syntax: false,
                                                    format: None,
                                                    default: None,
                                                },
                                            ));
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "DATE_FORMAT".to_string(),
                                                vec![cast_date, Expression::string("EEEE")],
                                            ))))
                                        }
                                        _ => Ok(Expression::Function(f)),
                                    },
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // STRING_AGG(x, sep) without WITHIN GROUP -> target-specific
                            "STRING_AGG" if f.args.len() >= 2 => {
                                let x = f.args[0].clone();
                                let sep = f.args[1].clone();
                                match target {
                                    DialectType::MySQL
                                    | DialectType::SingleStore
                                    | DialectType::Doris
                                    | DialectType::StarRocks => Ok(Expression::GroupConcat(
                                        Box::new(crate::expressions::GroupConcatFunc {
                                            this: x,
                                            separator: Some(sep),
                                            order_by: None,
                                            distinct: false,
                                            filter: None,
                                        }),
                                    )),
                                    DialectType::SQLite => Ok(Expression::GroupConcat(Box::new(
                                        crate::expressions::GroupConcatFunc {
                                            this: x,
                                            separator: Some(sep),
                                            order_by: None,
                                            distinct: false,
                                            filter: None,
                                        },
                                    ))),
                                    DialectType::PostgreSQL | DialectType::Redshift => {
                                        Ok(Expression::StringAgg(Box::new(
                                            crate::expressions::StringAggFunc {
                                                this: x,
                                                separator: Some(sep),
                                                order_by: None,
                                                distinct: false,
                                                filter: None,
                                                limit: None,
                                            },
                                        )))
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // JSON_ARRAYAGG -> JSON_AGG for PostgreSQL
                            "JSON_ARRAYAGG" => match target {
                                DialectType::PostgreSQL => {
                                    Ok(Expression::Function(Box::new(Function {
                                        name: "JSON_AGG".to_string(),
                                        ..(*f)
                                    })))
                                }
                                _ => Ok(Expression::Function(f)),
                            },
                            // SCHEMA_NAME(id) -> CURRENT_SCHEMA for PostgreSQL, 'main' for SQLite
                            "SCHEMA_NAME" => match target {
                                DialectType::PostgreSQL => Ok(Expression::CurrentSchema(Box::new(
                                    crate::expressions::CurrentSchema { this: None },
                                ))),
                                DialectType::SQLite => Ok(Expression::string("main")),
                                _ => Ok(Expression::Function(f)),
                            },
                            // TO_TIMESTAMP(x, fmt) 2-arg from Spark/Hive: convert Java format to target format
                            "TO_TIMESTAMP"
                                if f.args.len() == 2
                                    && matches!(
                                        source,
                                        DialectType::Spark
                                            | DialectType::Databricks
                                            | DialectType::Hive
                                    )
                                    && matches!(target, DialectType::DuckDB) =>
                            {
                                let mut args = f.args;
                                let val = args.remove(0);
                                let fmt_expr = args.remove(0);
                                if let Expression::Literal(Literal::String(ref s)) = fmt_expr {
                                    // Convert Java/Spark format to C strptime format
                                    fn java_to_c_fmt(fmt: &str) -> String {
                                        let result = fmt
                                            .replace("yyyy", "%Y")
                                            .replace("SSSSSS", "%f")
                                            .replace("EEEE", "%W")
                                            .replace("MM", "%m")
                                            .replace("dd", "%d")
                                            .replace("HH", "%H")
                                            .replace("mm", "%M")
                                            .replace("ss", "%S")
                                            .replace("yy", "%y");
                                        let mut out = String::new();
                                        let chars: Vec<char> = result.chars().collect();
                                        let mut i = 0;
                                        while i < chars.len() {
                                            if chars[i] == '%' && i + 1 < chars.len() {
                                                out.push(chars[i]);
                                                out.push(chars[i + 1]);
                                                i += 2;
                                            } else if chars[i] == 'z' {
                                                out.push_str("%Z");
                                                i += 1;
                                            } else if chars[i] == 'Z' {
                                                out.push_str("%z");
                                                i += 1;
                                            } else {
                                                out.push(chars[i]);
                                                i += 1;
                                            }
                                        }
                                        out
                                    }
                                    let c_fmt = java_to_c_fmt(s);
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "STRPTIME".to_string(),
                                        vec![val, Expression::string(&c_fmt)],
                                    ))))
                                } else {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "STRPTIME".to_string(),
                                        vec![val, fmt_expr],
                                    ))))
                                }
                            }
                            // TO_DATE(x) 1-arg from Doris: date conversion
                            "TO_DATE"
                                if f.args.len() == 1
                                    && matches!(
                                        source,
                                        DialectType::Doris | DialectType::StarRocks
                                    ) =>
                            {
                                let arg = f.args.into_iter().next().unwrap();
                                match target {
                                    DialectType::Oracle
                                    | DialectType::DuckDB
                                    | DialectType::TSQL => {
                                        // CAST(x AS DATE)
                                        Ok(Expression::Cast(Box::new(Cast {
                                            this: arg,
                                            to: DataType::Date,
                                            double_colon_syntax: false,
                                            trailing_comments: vec![],
                                            format: None,
                                            default: None,
                                        })))
                                    }
                                    DialectType::MySQL | DialectType::SingleStore => {
                                        // DATE(x)
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE".to_string(),
                                            vec![arg],
                                        ))))
                                    }
                                    _ => {
                                        // Default: keep as TO_DATE(x) (Spark, PostgreSQL, etc.)
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "TO_DATE".to_string(),
                                            vec![arg],
                                        ))))
                                    }
                                }
                            }
                            // TO_DATE(x) 1-arg from Spark/Hive: safe date conversion
                            "TO_DATE"
                                if f.args.len() == 1
                                    && matches!(
                                        source,
                                        DialectType::Spark
                                            | DialectType::Databricks
                                            | DialectType::Hive
                                    ) =>
                            {
                                let arg = f.args.into_iter().next().unwrap();
                                match target {
                                    DialectType::DuckDB => {
                                        // Spark TO_DATE is safe -> TRY_CAST(x AS DATE)
                                        Ok(Expression::TryCast(Box::new(Cast {
                                            this: arg,
                                            to: DataType::Date,
                                            double_colon_syntax: false,
                                            trailing_comments: vec![],
                                            format: None,
                                            default: None,
                                        })))
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        // CAST(CAST(x AS TIMESTAMP) AS DATE)
                                        Ok(Self::double_cast_timestamp_date(arg))
                                    }
                                    DialectType::Snowflake => {
                                        // Spark's TO_DATE is safe -> TRY_TO_DATE(x, 'yyyy-mm-DD')
                                        // The default Spark format 'yyyy-MM-dd' maps to Snowflake 'yyyy-mm-DD'
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "TRY_TO_DATE".to_string(),
                                            vec![arg, Expression::string("yyyy-mm-DD")],
                                        ))))
                                    }
                                    _ => {
                                        // Default: keep as TO_DATE(x)
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "TO_DATE".to_string(),
                                            vec![arg],
                                        ))))
                                    }
                                }
                            }
                            // TO_DATE(x, fmt) 2-arg from Spark/Hive: format-based date conversion
                            "TO_DATE"
                                if f.args.len() == 2
                                    && matches!(
                                        source,
                                        DialectType::Spark
                                            | DialectType::Databricks
                                            | DialectType::Hive
                                    ) =>
                            {
                                let mut args = f.args;
                                let val = args.remove(0);
                                let fmt_expr = args.remove(0);
                                let is_default_format = matches!(&fmt_expr, Expression::Literal(Literal::String(s)) if s == "yyyy-MM-dd");

                                if is_default_format {
                                    // Default format: same as 1-arg form
                                    match target {
                                        DialectType::DuckDB => {
                                            Ok(Expression::TryCast(Box::new(Cast {
                                                this: val,
                                                to: DataType::Date,
                                                double_colon_syntax: false,
                                                trailing_comments: vec![],
                                                format: None,
                                                default: None,
                                            })))
                                        }
                                        DialectType::Presto
                                        | DialectType::Trino
                                        | DialectType::Athena => {
                                            Ok(Self::double_cast_timestamp_date(val))
                                        }
                                        DialectType::Snowflake => {
                                            // TRY_TO_DATE(x, format) with Snowflake format mapping
                                            let sf_fmt = "yyyy-MM-dd"
                                                .replace("yyyy", "yyyy")
                                                .replace("MM", "mm")
                                                .replace("dd", "DD");
                                            Ok(Expression::Function(Box::new(Function::new(
                                                "TRY_TO_DATE".to_string(),
                                                vec![val, Expression::string(&sf_fmt)],
                                            ))))
                                        }
                                        _ => Ok(Expression::Function(Box::new(Function::new(
                                            "TO_DATE".to_string(),
                                            vec![val],
                                        )))),
                                    }
                                } else {
                                    // Non-default format: use format-based parsing
                                    if let Expression::Literal(Literal::String(ref s)) = fmt_expr {
                                        match target {
                                            DialectType::DuckDB => {
                                                // CAST(CAST(TRY_STRPTIME(x, c_fmt) AS TIMESTAMP) AS DATE)
                                                fn java_to_c_fmt_todate(fmt: &str) -> String {
                                                    let result = fmt
                                                        .replace("yyyy", "%Y")
                                                        .replace("SSSSSS", "%f")
                                                        .replace("EEEE", "%W")
                                                        .replace("MM", "%m")
                                                        .replace("dd", "%d")
                                                        .replace("HH", "%H")
                                                        .replace("mm", "%M")
                                                        .replace("ss", "%S")
                                                        .replace("yy", "%y");
                                                    let mut out = String::new();
                                                    let chars: Vec<char> = result.chars().collect();
                                                    let mut i = 0;
                                                    while i < chars.len() {
                                                        if chars[i] == '%' && i + 1 < chars.len() {
                                                            out.push(chars[i]);
                                                            out.push(chars[i + 1]);
                                                            i += 2;
                                                        } else if chars[i] == 'z' {
                                                            out.push_str("%Z");
                                                            i += 1;
                                                        } else if chars[i] == 'Z' {
                                                            out.push_str("%z");
                                                            i += 1;
                                                        } else {
                                                            out.push(chars[i]);
                                                            i += 1;
                                                        }
                                                    }
                                                    out
                                                }
                                                let c_fmt = java_to_c_fmt_todate(s);
                                                // CAST(CAST(TRY_STRPTIME(x, fmt) AS TIMESTAMP) AS DATE)
                                                let try_strptime =
                                                    Expression::Function(Box::new(Function::new(
                                                        "TRY_STRPTIME".to_string(),
                                                        vec![val, Expression::string(&c_fmt)],
                                                    )));
                                                let cast_ts = Expression::Cast(Box::new(Cast {
                                                    this: try_strptime,
                                                    to: DataType::Timestamp {
                                                        precision: None,
                                                        timezone: false,
                                                    },
                                                    double_colon_syntax: false,
                                                    trailing_comments: vec![],
                                                    format: None,
                                                    default: None,
                                                }));
                                                Ok(Expression::Cast(Box::new(Cast {
                                                    this: cast_ts,
                                                    to: DataType::Date,
                                                    double_colon_syntax: false,
                                                    trailing_comments: vec![],
                                                    format: None,
                                                    default: None,
                                                })))
                                            }
                                            DialectType::Presto
                                            | DialectType::Trino
                                            | DialectType::Athena => {
                                                // CAST(DATE_PARSE(x, presto_fmt) AS DATE)
                                                let p_fmt = s
                                                    .replace("yyyy", "%Y")
                                                    .replace("SSSSSS", "%f")
                                                    .replace("MM", "%m")
                                                    .replace("dd", "%d")
                                                    .replace("HH", "%H")
                                                    .replace("mm", "%M")
                                                    .replace("ss", "%S")
                                                    .replace("yy", "%y");
                                                let date_parse =
                                                    Expression::Function(Box::new(Function::new(
                                                        "DATE_PARSE".to_string(),
                                                        vec![val, Expression::string(&p_fmt)],
                                                    )));
                                                Ok(Expression::Cast(Box::new(Cast {
                                                    this: date_parse,
                                                    to: DataType::Date,
                                                    double_colon_syntax: false,
                                                    trailing_comments: vec![],
                                                    format: None,
                                                    default: None,
                                                })))
                                            }
                                            DialectType::Snowflake => {
                                                // TRY_TO_DATE(x, snowflake_fmt)
                                                Ok(Expression::Function(Box::new(Function::new(
                                                    "TRY_TO_DATE".to_string(),
                                                    vec![val, Expression::string(s)],
                                                ))))
                                            }
                                            _ => Ok(Expression::Function(Box::new(Function::new(
                                                "TO_DATE".to_string(),
                                                vec![val, fmt_expr],
                                            )))),
                                        }
                                    } else {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "TO_DATE".to_string(),
                                            vec![val, fmt_expr],
                                        ))))
                                    }
                                }
                            }
                            // TO_TIMESTAMP(x) 1-arg: epoch conversion
                            "TO_TIMESTAMP"
                                if f.args.len() == 1
                                    && matches!(source, DialectType::DuckDB)
                                    && matches!(
                                        target,
                                        DialectType::BigQuery
                                            | DialectType::Presto
                                            | DialectType::Trino
                                            | DialectType::Hive
                                            | DialectType::Spark
                                            | DialectType::Databricks
                                            | DialectType::Athena
                                    ) =>
                            {
                                let arg = f.args.into_iter().next().unwrap();
                                let func_name = match target {
                                    DialectType::BigQuery => "TIMESTAMP_SECONDS",
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena
                                    | DialectType::Hive
                                    | DialectType::Spark
                                    | DialectType::Databricks => "FROM_UNIXTIME",
                                    _ => "TO_TIMESTAMP",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    func_name.to_string(),
                                    vec![arg],
                                ))))
                            }
                            // CONCAT(x) single-arg: -> CONCAT(COALESCE(x, '')) for Spark
                            "CONCAT" if f.args.len() == 1 => {
                                let arg = f.args.into_iter().next().unwrap();
                                match target {
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        // CONCAT(a) -> CAST(a AS VARCHAR)
                                        Ok(Expression::Cast(Box::new(Cast {
                                            this: arg,
                                            to: DataType::VarChar {
                                                length: None,
                                                parenthesized_length: false,
                                            },
                                            trailing_comments: vec![],
                                            double_colon_syntax: false,
                                            format: None,
                                            default: None,
                                        })))
                                    }
                                    DialectType::TSQL => {
                                        // CONCAT(a) -> a
                                        Ok(arg)
                                    }
                                    DialectType::DuckDB => {
                                        // Keep CONCAT(a) for DuckDB (native support)
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "CONCAT".to_string(),
                                            vec![arg],
                                        ))))
                                    }
                                    DialectType::Spark | DialectType::Databricks => {
                                        let coalesced = Expression::Coalesce(Box::new(
                                            crate::expressions::VarArgFunc {
                                                expressions: vec![arg, Expression::string("")],
                                                original_name: None,
                                            },
                                        ));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "CONCAT".to_string(),
                                            vec![coalesced],
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(Box::new(Function::new(
                                        "CONCAT".to_string(),
                                        vec![arg],
                                    )))),
                                }
                            }
                            // REGEXP_EXTRACT(a, p) 2-arg: BigQuery default group is 0 (no 3rd arg needed)
                            "REGEXP_EXTRACT"
                                if f.args.len() == 3 && matches!(target, DialectType::BigQuery) =>
                            {
                                // If group_index is 0, drop it
                                let drop_group = match &f.args[2] {
                                    Expression::Literal(Literal::Number(n)) => n == "0",
                                    _ => false,
                                };
                                if drop_group {
                                    let mut args = f.args;
                                    args.truncate(2);
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "REGEXP_EXTRACT".to_string(),
                                        args,
                                    ))))
                                } else {
                                    Ok(Expression::Function(f))
                                }
                            }
                            // REGEXP_EXTRACT(a, pattern, group, flags) 4-arg -> REGEXP_SUBSTR for Snowflake
                            "REGEXP_EXTRACT"
                                if f.args.len() == 4
                                    && matches!(target, DialectType::Snowflake) =>
                            {
                                // REGEXP_EXTRACT(a, 'pattern', 2, 'i') -> REGEXP_SUBSTR(a, 'pattern', 1, 1, 'i', 2)
                                let mut args = f.args;
                                let this = args.remove(0);
                                let pattern = args.remove(0);
                                let group = args.remove(0);
                                let flags = args.remove(0);
                                Ok(Expression::Function(Box::new(Function::new(
                                    "REGEXP_SUBSTR".to_string(),
                                    vec![
                                        this,
                                        pattern,
                                        Expression::number(1),
                                        Expression::number(1),
                                        flags,
                                        group,
                                    ],
                                ))))
                            }
                            // REGEXP_SUBSTR(a, pattern, position) 3-arg -> REGEXP_EXTRACT(SUBSTRING(a, pos), pattern)
                            "REGEXP_SUBSTR"
                                if f.args.len() == 3
                                    && matches!(
                                        target,
                                        DialectType::DuckDB
                                            | DialectType::Presto
                                            | DialectType::Trino
                                            | DialectType::Spark
                                            | DialectType::Databricks
                                    ) =>
                            {
                                let mut args = f.args;
                                let this = args.remove(0);
                                let pattern = args.remove(0);
                                let position = args.remove(0);
                                // Wrap subject in SUBSTRING(this, position) to apply the offset
                                let substring_expr = Expression::Function(Box::new(Function::new(
                                    "SUBSTRING".to_string(),
                                    vec![this, position],
                                )));
                                let target_name = match target {
                                    DialectType::DuckDB => "REGEXP_EXTRACT",
                                    _ => "REGEXP_EXTRACT",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    target_name.to_string(),
                                    vec![substring_expr, pattern],
                                ))))
                            }
                            // TO_DAYS(x) -> (DATEDIFF(x, '0000-01-01') + 1) or target-specific
                            "TO_DAYS" if f.args.len() == 1 => {
                                let x = f.args.into_iter().next().unwrap();
                                let epoch = Expression::string("0000-01-01");
                                // Build the final target-specific expression directly
                                let datediff_expr = match target {
                                    DialectType::MySQL | DialectType::SingleStore => {
                                        // MySQL: (DATEDIFF(x, '0000-01-01') + 1)
                                        Expression::Function(Box::new(Function::new(
                                            "DATEDIFF".to_string(),
                                            vec![x, epoch],
                                        )))
                                    }
                                    DialectType::DuckDB => {
                                        // DuckDB: (DATE_DIFF('DAY', CAST('0000-01-01' AS DATE), CAST(x AS DATE)) + 1)
                                        let cast_epoch = Expression::Cast(Box::new(Cast {
                                            this: epoch,
                                            to: DataType::Date,
                                            trailing_comments: Vec::new(),
                                            double_colon_syntax: false,
                                            format: None,
                                            default: None,
                                        }));
                                        let cast_x = Expression::Cast(Box::new(Cast {
                                            this: x,
                                            to: DataType::Date,
                                            trailing_comments: Vec::new(),
                                            double_colon_syntax: false,
                                            format: None,
                                            default: None,
                                        }));
                                        Expression::Function(Box::new(Function::new(
                                            "DATE_DIFF".to_string(),
                                            vec![Expression::string("DAY"), cast_epoch, cast_x],
                                        )))
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        // Presto: (DATE_DIFF('DAY', CAST(CAST('0000-01-01' AS TIMESTAMP) AS DATE), CAST(CAST(x AS TIMESTAMP) AS DATE)) + 1)
                                        let cast_epoch = Self::double_cast_timestamp_date(epoch);
                                        let cast_x = Self::double_cast_timestamp_date(x);
                                        Expression::Function(Box::new(Function::new(
                                            "DATE_DIFF".to_string(),
                                            vec![Expression::string("DAY"), cast_epoch, cast_x],
                                        )))
                                    }
                                    _ => {
                                        // Default: (DATEDIFF(x, '0000-01-01') + 1)
                                        Expression::Function(Box::new(Function::new(
                                            "DATEDIFF".to_string(),
                                            vec![x, epoch],
                                        )))
                                    }
                                };
                                let add_one = Expression::Add(Box::new(BinaryOp::new(
                                    datediff_expr,
                                    Expression::number(1),
                                )));
                                Ok(Expression::Paren(Box::new(crate::expressions::Paren {
                                    this: add_one,
                                    trailing_comments: Vec::new(),
                                })))
                            }
                            // STR_TO_DATE(x, format) -> DATE_PARSE / STRPTIME / TO_DATE etc.
                            "STR_TO_DATE"
                                if f.args.len() == 2
                                    && matches!(
                                        target,
                                        DialectType::Presto | DialectType::Trino
                                    ) =>
                            {
                                let mut args = f.args;
                                let x = args.remove(0);
                                let format_expr = args.remove(0);
                                // Check if the format contains time components
                                let has_time =
                                    if let Expression::Literal(Literal::String(ref fmt)) =
                                        format_expr
                                    {
                                        fmt.contains("%H")
                                            || fmt.contains("%T")
                                            || fmt.contains("%M")
                                            || fmt.contains("%S")
                                            || fmt.contains("%I")
                                            || fmt.contains("%p")
                                    } else {
                                        false
                                    };
                                let date_parse = Expression::Function(Box::new(Function::new(
                                    "DATE_PARSE".to_string(),
                                    vec![x, format_expr],
                                )));
                                if has_time {
                                    // Has time components: just DATE_PARSE
                                    Ok(date_parse)
                                } else {
                                    // Date-only: CAST(DATE_PARSE(...) AS DATE)
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this: date_parse,
                                        to: DataType::Date,
                                        trailing_comments: Vec::new(),
                                        double_colon_syntax: false,
                                        format: None,
                                        default: None,
                                    })))
                                }
                            }
                            "STR_TO_DATE"
                                if f.args.len() == 2
                                    && matches!(
                                        target,
                                        DialectType::PostgreSQL | DialectType::Redshift
                                    ) =>
                            {
                                let mut args = f.args;
                                let x = args.remove(0);
                                let fmt = args.remove(0);
                                let pg_fmt = match fmt {
                                    Expression::Literal(Literal::String(s)) => Expression::string(
                                        &s.replace("%Y", "YYYY")
                                            .replace("%m", "MM")
                                            .replace("%d", "DD")
                                            .replace("%H", "HH24")
                                            .replace("%M", "MI")
                                            .replace("%S", "SS"),
                                    ),
                                    other => other,
                                };
                                let to_date = Expression::Function(Box::new(Function::new(
                                    "TO_DATE".to_string(),
                                    vec![x, pg_fmt],
                                )));
                                Ok(Expression::Cast(Box::new(Cast {
                                    this: to_date,
                                    to: DataType::Timestamp {
                                        timezone: false,
                                        precision: None,
                                    },
                                    trailing_comments: Vec::new(),
                                    double_colon_syntax: false,
                                    format: None,
                                    default: None,
                                })))
                            }
                            // RANGE(start, end) -> GENERATE_SERIES for SQLite
                            "RANGE"
                                if (f.args.len() == 1 || f.args.len() == 2)
                                    && matches!(target, DialectType::SQLite) =>
                            {
                                if f.args.len() == 2 {
                                    // RANGE(start, end) -> (SELECT value AS col_alias FROM GENERATE_SERIES(start, end))
                                    // For SQLite, RANGE is exclusive on end, GENERATE_SERIES is inclusive
                                    let mut args = f.args;
                                    let start = args.remove(0);
                                    let end = args.remove(0);
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "GENERATE_SERIES".to_string(),
                                        vec![start, end],
                                    ))))
                                } else {
                                    Ok(Expression::Function(f))
                                }
                            }
                            // UNIFORM(low, high[, seed]) -> UNIFORM(low, high, RANDOM([seed])) for Snowflake
                            // When source is Snowflake, keep as-is (args already in correct form)
                            "UNIFORM"
                                if matches!(target, DialectType::Snowflake)
                                    && (f.args.len() == 2 || f.args.len() == 3) =>
                            {
                                if matches!(source, DialectType::Snowflake) {
                                    // Snowflake -> Snowflake: keep as-is
                                    Ok(Expression::Function(f))
                                } else {
                                    let mut args = f.args;
                                    let low = args.remove(0);
                                    let high = args.remove(0);
                                    let random = if !args.is_empty() {
                                        let seed = args.remove(0);
                                        Expression::Function(Box::new(Function::new(
                                            "RANDOM".to_string(),
                                            vec![seed],
                                        )))
                                    } else {
                                        Expression::Function(Box::new(Function::new(
                                            "RANDOM".to_string(),
                                            vec![],
                                        )))
                                    };
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "UNIFORM".to_string(),
                                        vec![low, high, random],
                                    ))))
                                }
                            }
                            // TO_UTC_TIMESTAMP(ts, tz) -> target-specific UTC conversion
                            "TO_UTC_TIMESTAMP" if f.args.len() == 2 => {
                                let mut args = f.args;
                                let ts_arg = args.remove(0);
                                let tz_arg = args.remove(0);
                                // Cast string literal to TIMESTAMP for all targets
                                let ts_cast =
                                    if matches!(&ts_arg, Expression::Literal(Literal::String(_))) {
                                        Expression::Cast(Box::new(Cast {
                                            this: ts_arg,
                                            to: DataType::Timestamp {
                                                timezone: false,
                                                precision: None,
                                            },
                                            trailing_comments: vec![],
                                            double_colon_syntax: false,
                                            format: None,
                                            default: None,
                                        }))
                                    } else {
                                        ts_arg
                                    };
                                match target {
                                    DialectType::Spark | DialectType::Databricks => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "TO_UTC_TIMESTAMP".to_string(),
                                            vec![ts_cast, tz_arg],
                                        ))))
                                    }
                                    DialectType::Snowflake => {
                                        // CONVERT_TIMEZONE(tz, 'UTC', CAST(ts AS TIMESTAMP))
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "CONVERT_TIMEZONE".to_string(),
                                            vec![tz_arg, Expression::string("UTC"), ts_cast],
                                        ))))
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        // WITH_TIMEZONE(CAST(ts AS TIMESTAMP), tz) AT TIME ZONE 'UTC'
                                        let wtz = Expression::Function(Box::new(Function::new(
                                            "WITH_TIMEZONE".to_string(),
                                            vec![ts_cast, tz_arg],
                                        )));
                                        Ok(Expression::AtTimeZone(Box::new(
                                            crate::expressions::AtTimeZone {
                                                this: wtz,
                                                zone: Expression::string("UTC"),
                                            },
                                        )))
                                    }
                                    DialectType::BigQuery => {
                                        // DATETIME(TIMESTAMP(CAST(ts AS DATETIME), tz), 'UTC')
                                        let cast_dt = Expression::Cast(Box::new(Cast {
                                            this: if let Expression::Cast(c) = ts_cast {
                                                c.this
                                            } else {
                                                ts_cast.clone()
                                            },
                                            to: DataType::Custom {
                                                name: "DATETIME".to_string(),
                                            },
                                            trailing_comments: vec![],
                                            double_colon_syntax: false,
                                            format: None,
                                            default: None,
                                        }));
                                        let ts_func =
                                            Expression::Function(Box::new(Function::new(
                                                "TIMESTAMP".to_string(),
                                                vec![cast_dt, tz_arg],
                                            )));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATETIME".to_string(),
                                            vec![ts_func, Expression::string("UTC")],
                                        ))))
                                    }
                                    _ => {
                                        // DuckDB, PostgreSQL, Redshift: CAST(ts AS TIMESTAMP) AT TIME ZONE tz AT TIME ZONE 'UTC'
                                        let atz1 = Expression::AtTimeZone(Box::new(
                                            crate::expressions::AtTimeZone {
                                                this: ts_cast,
                                                zone: tz_arg,
                                            },
                                        ));
                                        Ok(Expression::AtTimeZone(Box::new(
                                            crate::expressions::AtTimeZone {
                                                this: atz1,
                                                zone: Expression::string("UTC"),
                                            },
                                        )))
                                    }
                                }
                            }
                            // FROM_UTC_TIMESTAMP(ts, tz) -> target-specific UTC conversion
                            "FROM_UTC_TIMESTAMP" if f.args.len() == 2 => {
                                let mut args = f.args;
                                let ts_arg = args.remove(0);
                                let tz_arg = args.remove(0);
                                // Cast string literal to TIMESTAMP
                                let ts_cast =
                                    if matches!(&ts_arg, Expression::Literal(Literal::String(_))) {
                                        Expression::Cast(Box::new(Cast {
                                            this: ts_arg,
                                            to: DataType::Timestamp {
                                                timezone: false,
                                                precision: None,
                                            },
                                            trailing_comments: vec![],
                                            double_colon_syntax: false,
                                            format: None,
                                            default: None,
                                        }))
                                    } else {
                                        ts_arg
                                    };
                                match target {
                                    DialectType::Spark | DialectType::Databricks => {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "FROM_UTC_TIMESTAMP".to_string(),
                                            vec![ts_cast, tz_arg],
                                        ))))
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        // AT_TIMEZONE(CAST(ts AS TIMESTAMP), tz)
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "AT_TIMEZONE".to_string(),
                                            vec![ts_cast, tz_arg],
                                        ))))
                                    }
                                    DialectType::Snowflake => {
                                        // CONVERT_TIMEZONE('UTC', tz, CAST(ts AS TIMESTAMP))
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "CONVERT_TIMEZONE".to_string(),
                                            vec![Expression::string("UTC"), tz_arg, ts_cast],
                                        ))))
                                    }
                                    _ => {
                                        // DuckDB, PostgreSQL, Redshift: CAST(ts AS TIMESTAMP) AT TIME ZONE tz
                                        Ok(Expression::AtTimeZone(Box::new(
                                            crate::expressions::AtTimeZone {
                                                this: ts_cast,
                                                zone: tz_arg,
                                            },
                                        )))
                                    }
                                }
                            }
                            // MAP_FROM_ARRAYS(keys, values) -> target-specific map construction
                            "MAP_FROM_ARRAYS" if f.args.len() == 2 => {
                                let name = match target {
                                    DialectType::Snowflake => "OBJECT_CONSTRUCT",
                                    _ => "MAP",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // STR_TO_MAP(s, pair_delim, kv_delim) -> SPLIT_TO_MAP for Presto
                            "STR_TO_MAP" if f.args.len() >= 1 => match target {
                                DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "SPLIT_TO_MAP".to_string(),
                                        f.args,
                                    ))))
                                }
                                _ => Ok(Expression::Function(f)),
                            },
                            // TIME_TO_STR(x, fmt) -> Expression::TimeToStr for proper generation
                            "TIME_TO_STR" if f.args.len() == 2 => {
                                let mut args = f.args;
                                let this = args.remove(0);
                                let fmt_expr = args.remove(0);
                                let format =
                                    if let Expression::Literal(Literal::String(s)) = fmt_expr {
                                        s
                                    } else {
                                        "%Y-%m-%d %H:%M:%S".to_string()
                                    };
                                Ok(Expression::TimeToStr(Box::new(
                                    crate::expressions::TimeToStr {
                                        this: Box::new(this),
                                        format,
                                        culture: None,
                                        zone: None,
                                    },
                                )))
                            }
                            // STR_TO_TIME(x, fmt) -> Expression::StrToTime for proper generation
                            "STR_TO_TIME" if f.args.len() == 2 => {
                                let mut args = f.args;
                                let this = args.remove(0);
                                let fmt_expr = args.remove(0);
                                let format =
                                    if let Expression::Literal(Literal::String(s)) = fmt_expr {
                                        s
                                    } else {
                                        "%Y-%m-%d %H:%M:%S".to_string()
                                    };
                                Ok(Expression::StrToTime(Box::new(
                                    crate::expressions::StrToTime {
                                        this: Box::new(this),
                                        format,
                                        zone: None,
                                        safe: None,
                                        target_type: None,
                                    },
                                )))
                            }
                            // STR_TO_UNIX(x, fmt) -> Expression::StrToUnix for proper generation
                            "STR_TO_UNIX" if f.args.len() >= 1 => {
                                let mut args = f.args;
                                let this = args.remove(0);
                                let format = if !args.is_empty() {
                                    if let Expression::Literal(Literal::String(s)) = args.remove(0)
                                    {
                                        Some(s)
                                    } else {
                                        None
                                    }
                                } else {
                                    None
                                };
                                Ok(Expression::StrToUnix(Box::new(
                                    crate::expressions::StrToUnix {
                                        this: Some(Box::new(this)),
                                        format,
                                    },
                                )))
                            }
                            // TIME_TO_UNIX(x) -> Expression::TimeToUnix for proper generation
                            "TIME_TO_UNIX" if f.args.len() == 1 => {
                                let mut args = f.args;
                                let this = args.remove(0);
                                Ok(Expression::TimeToUnix(Box::new(
                                    crate::expressions::UnaryFunc {
                                        this,
                                        original_name: None,
                                    },
                                )))
                            }
                            // UNIX_TO_STR(x, fmt) -> Expression::UnixToStr for proper generation
                            "UNIX_TO_STR" if f.args.len() >= 1 => {
                                let mut args = f.args;
                                let this = args.remove(0);
                                let format = if !args.is_empty() {
                                    if let Expression::Literal(Literal::String(s)) = args.remove(0)
                                    {
                                        Some(s)
                                    } else {
                                        None
                                    }
                                } else {
                                    None
                                };
                                Ok(Expression::UnixToStr(Box::new(
                                    crate::expressions::UnixToStr {
                                        this: Box::new(this),
                                        format,
                                    },
                                )))
                            }
                            // UNIX_TO_TIME(x) -> Expression::UnixToTime for proper generation
                            "UNIX_TO_TIME" if f.args.len() == 1 => {
                                let mut args = f.args;
                                let this = args.remove(0);
                                Ok(Expression::UnixToTime(Box::new(
                                    crate::expressions::UnixToTime {
                                        this: Box::new(this),
                                        scale: None,
                                        zone: None,
                                        hours: None,
                                        minutes: None,
                                        format: None,
                                        target_type: None,
                                    },
                                )))
                            }
                            // TIME_STR_TO_DATE(x) -> Expression::TimeStrToDate for proper generation
                            "TIME_STR_TO_DATE" if f.args.len() == 1 => {
                                let mut args = f.args;
                                let this = args.remove(0);
                                Ok(Expression::TimeStrToDate(Box::new(
                                    crate::expressions::UnaryFunc {
                                        this,
                                        original_name: None,
                                    },
                                )))
                            }
                            // TIME_STR_TO_TIME(x) -> Expression::TimeStrToTime for proper generation
                            "TIME_STR_TO_TIME" if f.args.len() == 1 => {
                                let mut args = f.args;
                                let this = args.remove(0);
                                Ok(Expression::TimeStrToTime(Box::new(
                                    crate::expressions::TimeStrToTime {
                                        this: Box::new(this),
                                        zone: None,
                                    },
                                )))
                            }
                            // MONTHS_BETWEEN(end, start) -> DuckDB complex expansion
                            "MONTHS_BETWEEN" if f.args.len() == 2 => {
                                match target {
                                    DialectType::DuckDB => {
                                        let mut args = f.args;
                                        let end_date = args.remove(0);
                                        let start_date = args.remove(0);
                                        let cast_end = Self::ensure_cast_date(end_date);
                                        let cast_start = Self::ensure_cast_date(start_date);
                                        // DATE_DIFF('MONTH', start, end) + CASE WHEN DAY(end) = DAY(LAST_DAY(end)) AND DAY(start) = DAY(LAST_DAY(start)) THEN 0 ELSE (DAY(end) - DAY(start)) / 31.0 END
                                        let dd = Expression::Function(Box::new(Function::new(
                                            "DATE_DIFF".to_string(),
                                            vec![
                                                Expression::string("MONTH"),
                                                cast_start.clone(),
                                                cast_end.clone(),
                                            ],
                                        )));
                                        let day_end =
                                            Expression::Function(Box::new(Function::new(
                                                "DAY".to_string(),
                                                vec![cast_end.clone()],
                                            )));
                                        let day_start =
                                            Expression::Function(Box::new(Function::new(
                                                "DAY".to_string(),
                                                vec![cast_start.clone()],
                                            )));
                                        let last_day_end =
                                            Expression::Function(Box::new(Function::new(
                                                "LAST_DAY".to_string(),
                                                vec![cast_end.clone()],
                                            )));
                                        let last_day_start =
                                            Expression::Function(Box::new(Function::new(
                                                "LAST_DAY".to_string(),
                                                vec![cast_start.clone()],
                                            )));
                                        let day_last_end = Expression::Function(Box::new(
                                            Function::new("DAY".to_string(), vec![last_day_end]),
                                        ));
                                        let day_last_start = Expression::Function(Box::new(
                                            Function::new("DAY".to_string(), vec![last_day_start]),
                                        ));
                                        let cond1 = Expression::Eq(Box::new(BinaryOp::new(
                                            day_end.clone(),
                                            day_last_end,
                                        )));
                                        let cond2 = Expression::Eq(Box::new(BinaryOp::new(
                                            day_start.clone(),
                                            day_last_start,
                                        )));
                                        let both_cond =
                                            Expression::And(Box::new(BinaryOp::new(cond1, cond2)));
                                        let day_diff = Expression::Sub(Box::new(BinaryOp::new(
                                            day_end, day_start,
                                        )));
                                        let day_diff_paren = Expression::Paren(Box::new(
                                            crate::expressions::Paren {
                                                this: day_diff,
                                                trailing_comments: Vec::new(),
                                            },
                                        ));
                                        let frac = Expression::Div(Box::new(BinaryOp::new(
                                            day_diff_paren,
                                            Expression::Literal(Literal::Number(
                                                "31.0".to_string(),
                                            )),
                                        )));
                                        let case_expr = Expression::Case(Box::new(Case {
                                            operand: None,
                                            whens: vec![(both_cond, Expression::number(0))],
                                            else_: Some(frac),
                                            comments: Vec::new(),
                                        }));
                                        Ok(Expression::Add(Box::new(BinaryOp::new(dd, case_expr))))
                                    }
                                    DialectType::Snowflake | DialectType::Redshift => {
                                        let mut args = f.args;
                                        let end_date = args.remove(0);
                                        let start_date = args.remove(0);
                                        let unit = Expression::Identifier(Identifier::new("MONTH"));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATEDIFF".to_string(),
                                            vec![unit, start_date, end_date],
                                        ))))
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        let mut args = f.args;
                                        let end_date = args.remove(0);
                                        let start_date = args.remove(0);
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_DIFF".to_string(),
                                            vec![Expression::string("MONTH"), start_date, end_date],
                                        ))))
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // MONTHS_BETWEEN(end, start, roundOff) - 3-arg form (Spark-specific)
                            // Drop the roundOff arg for non-Spark targets, keep it for Spark
                            "MONTHS_BETWEEN" if f.args.len() == 3 => {
                                match target {
                                    DialectType::Spark | DialectType::Databricks => {
                                        Ok(Expression::Function(f))
                                    }
                                    _ => {
                                        // Drop the 3rd arg and delegate to the 2-arg logic
                                        let mut args = f.args;
                                        let end_date = args.remove(0);
                                        let start_date = args.remove(0);
                                        // Re-create as 2-arg and process
                                        let f2 = Function::new(
                                            "MONTHS_BETWEEN".to_string(),
                                            vec![end_date, start_date],
                                        );
                                        let e2 = Expression::Function(Box::new(f2));
                                        Self::cross_dialect_normalize(e2, source, target)
                                    }
                                }
                            }
                            // TO_TIMESTAMP(x) with 1 arg -> CAST(x AS TIMESTAMP) for most targets
                            "TO_TIMESTAMP"
                                if f.args.len() == 1
                                    && matches!(
                                        source,
                                        DialectType::Spark
                                            | DialectType::Databricks
                                            | DialectType::Hive
                                    ) =>
                            {
                                let arg = f.args.into_iter().next().unwrap();
                                Ok(Expression::Cast(Box::new(Cast {
                                    this: arg,
                                    to: DataType::Timestamp {
                                        timezone: false,
                                        precision: None,
                                    },
                                    trailing_comments: vec![],
                                    double_colon_syntax: false,
                                    format: None,
                                    default: None,
                                })))
                            }
                            // STRING(x) -> CAST(x AS STRING) for Spark target
                            "STRING"
                                if f.args.len() == 1
                                    && matches!(
                                        source,
                                        DialectType::Spark | DialectType::Databricks
                                    ) =>
                            {
                                let arg = f.args.into_iter().next().unwrap();
                                let dt = match target {
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => DataType::Custom {
                                        name: "STRING".to_string(),
                                    },
                                    _ => DataType::Text,
                                };
                                Ok(Expression::Cast(Box::new(Cast {
                                    this: arg,
                                    to: dt,
                                    trailing_comments: vec![],
                                    double_colon_syntax: false,
                                    format: None,
                                    default: None,
                                })))
                            }
                            // LOGICAL_OR(x) -> BOOL_OR(x) for Spark target
                            "LOGICAL_OR" if f.args.len() == 1 => {
                                let name = match target {
                                    DialectType::Spark | DialectType::Databricks => "BOOL_OR",
                                    _ => "LOGICAL_OR",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // SPLIT(x, pattern) from Spark -> STR_SPLIT_REGEX for DuckDB, REGEXP_SPLIT for Presto
                            "SPLIT"
                                if f.args.len() == 2
                                    && matches!(
                                        source,
                                        DialectType::Spark
                                            | DialectType::Databricks
                                            | DialectType::Hive
                                    ) =>
                            {
                                let name = match target {
                                    DialectType::DuckDB => "STR_SPLIT_REGEX",
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => "REGEXP_SPLIT",
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => "SPLIT",
                                    _ => "SPLIT",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // TRY_ELEMENT_AT -> ELEMENT_AT for Presto, array[idx] for DuckDB
                            "TRY_ELEMENT_AT" if f.args.len() == 2 => match target {
                                DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "ELEMENT_AT".to_string(),
                                        f.args,
                                    ))))
                                }
                                DialectType::DuckDB => {
                                    let mut args = f.args;
                                    let arr = args.remove(0);
                                    let idx = args.remove(0);
                                    Ok(Expression::Subscript(Box::new(
                                        crate::expressions::Subscript {
                                            this: arr,
                                            index: idx,
                                        },
                                    )))
                                }
                                _ => Ok(Expression::Function(f)),
                            },
                            // ARRAY_FILTER(arr, lambda) -> FILTER for Hive/Spark/Presto, LIST_FILTER for DuckDB
                            "ARRAY_FILTER" if f.args.len() == 2 => {
                                let name = match target {
                                    DialectType::DuckDB => "LIST_FILTER",
                                    DialectType::StarRocks => "ARRAY_FILTER",
                                    _ => "FILTER",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // FILTER(arr, lambda) -> ARRAY_FILTER for StarRocks, LIST_FILTER for DuckDB
                            "FILTER" if f.args.len() == 2 => {
                                let name = match target {
                                    DialectType::DuckDB => "LIST_FILTER",
                                    DialectType::StarRocks => "ARRAY_FILTER",
                                    _ => "FILTER",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // REDUCE(arr, init, lambda1, lambda2) -> AGGREGATE for Spark
                            "REDUCE" if f.args.len() >= 3 => {
                                let name = match target {
                                    DialectType::Spark | DialectType::Databricks => "AGGREGATE",
                                    _ => "REDUCE",
                                };
                                Ok(Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    f.args,
                                ))))
                            }
                            // CURRENT_SCHEMA() -> dialect-specific
                            "CURRENT_SCHEMA" => {
                                match target {
                                    DialectType::PostgreSQL => {
                                        // PostgreSQL: CURRENT_SCHEMA (no parens)
                                        Ok(Expression::Function(Box::new(Function {
                                            name: "CURRENT_SCHEMA".to_string(),
                                            args: vec![],
                                            distinct: false,
                                            trailing_comments: vec![],
                                            use_bracket_syntax: false,
                                            no_parens: true,
                                            quoted: false,
                                        })))
                                    }
                                    DialectType::MySQL
                                    | DialectType::Doris
                                    | DialectType::StarRocks => Ok(Expression::Function(Box::new(
                                        Function::new("SCHEMA".to_string(), vec![]),
                                    ))),
                                    DialectType::TSQL => Ok(Expression::Function(Box::new(
                                        Function::new("SCHEMA_NAME".to_string(), vec![]),
                                    ))),
                                    DialectType::SQLite => {
                                        Ok(Expression::Literal(Literal::String("main".to_string())))
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // LTRIM(str, chars) 2-arg -> TRIM(LEADING chars FROM str) for Spark/Hive/Databricks/ClickHouse
                            "LTRIM" if f.args.len() == 2 => match target {
                                DialectType::Spark
                                | DialectType::Hive
                                | DialectType::Databricks
                                | DialectType::ClickHouse => {
                                    let mut args = f.args;
                                    let str_expr = args.remove(0);
                                    let chars = args.remove(0);
                                    Ok(Expression::Trim(Box::new(crate::expressions::TrimFunc {
                                        this: str_expr,
                                        characters: Some(chars),
                                        position: crate::expressions::TrimPosition::Leading,
                                        sql_standard_syntax: true,
                                        position_explicit: true,
                                    })))
                                }
                                _ => Ok(Expression::Function(f)),
                            },
                            // RTRIM(str, chars) 2-arg -> TRIM(TRAILING chars FROM str) for Spark/Hive/Databricks/ClickHouse
                            "RTRIM" if f.args.len() == 2 => match target {
                                DialectType::Spark
                                | DialectType::Hive
                                | DialectType::Databricks
                                | DialectType::ClickHouse => {
                                    let mut args = f.args;
                                    let str_expr = args.remove(0);
                                    let chars = args.remove(0);
                                    Ok(Expression::Trim(Box::new(crate::expressions::TrimFunc {
                                        this: str_expr,
                                        characters: Some(chars),
                                        position: crate::expressions::TrimPosition::Trailing,
                                        sql_standard_syntax: true,
                                        position_explicit: true,
                                    })))
                                }
                                _ => Ok(Expression::Function(f)),
                            },
                            // ARRAY_REVERSE(x) -> arrayReverse(x) for ClickHouse
                            "ARRAY_REVERSE" if f.args.len() == 1 => match target {
                                DialectType::ClickHouse => {
                                    let mut new_f = *f;
                                    new_f.name = "arrayReverse".to_string();
                                    Ok(Expression::Function(Box::new(new_f)))
                                }
                                _ => Ok(Expression::Function(f)),
                            },
                            // UUID() -> NEWID() for TSQL
                            "UUID" if f.args.is_empty() => match target {
                                DialectType::TSQL | DialectType::Fabric => {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "NEWID".to_string(),
                                        vec![],
                                    ))))
                                }
                                _ => Ok(Expression::Function(f)),
                            },
                            // FARM_FINGERPRINT(x) -> farmFingerprint64(x) for ClickHouse, FARMFINGERPRINT64(x) for Redshift
                            "FARM_FINGERPRINT" if f.args.len() == 1 => match target {
                                DialectType::ClickHouse => {
                                    let mut new_f = *f;
                                    new_f.name = "farmFingerprint64".to_string();
                                    Ok(Expression::Function(Box::new(new_f)))
                                }
                                DialectType::Redshift => {
                                    let mut new_f = *f;
                                    new_f.name = "FARMFINGERPRINT64".to_string();
                                    Ok(Expression::Function(Box::new(new_f)))
                                }
                                _ => Ok(Expression::Function(f)),
                            },
                            // JSON_KEYS(x) -> JSON_OBJECT_KEYS(x) for Databricks/Spark, OBJECT_KEYS(x) for Snowflake
                            "JSON_KEYS" => match target {
                                DialectType::Databricks | DialectType::Spark => {
                                    let mut new_f = *f;
                                    new_f.name = "JSON_OBJECT_KEYS".to_string();
                                    Ok(Expression::Function(Box::new(new_f)))
                                }
                                DialectType::Snowflake => {
                                    let mut new_f = *f;
                                    new_f.name = "OBJECT_KEYS".to_string();
                                    Ok(Expression::Function(Box::new(new_f)))
                                }
                                _ => Ok(Expression::Function(f)),
                            },
                            // WEEKOFYEAR(x) -> WEEKISO(x) for Snowflake
                            "WEEKOFYEAR" => match target {
                                DialectType::Snowflake => {
                                    let mut new_f = *f;
                                    new_f.name = "WEEKISO".to_string();
                                    Ok(Expression::Function(Box::new(new_f)))
                                }
                                _ => Ok(Expression::Function(f)),
                            },
                            // FORMAT(fmt, args...) -> FORMAT_STRING(fmt, args...) for Databricks
                            "FORMAT"
                                if f.args.len() >= 2 && matches!(source, DialectType::Generic) =>
                            {
                                match target {
                                    DialectType::Databricks | DialectType::Spark => {
                                        let mut new_f = *f;
                                        new_f.name = "FORMAT_STRING".to_string();
                                        Ok(Expression::Function(Box::new(new_f)))
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // CONCAT_WS('-', args...) -> CONCAT_WS('-', CAST(arg AS VARCHAR), ...) for Presto/Trino
                            "CONCAT_WS" if f.args.len() >= 2 => match target {
                                DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                    let mut args = f.args;
                                    let sep = args.remove(0);
                                    let cast_args: Vec<Expression> = args
                                        .into_iter()
                                        .map(|a| {
                                            Expression::Cast(Box::new(Cast {
                                                this: a,
                                                to: DataType::VarChar {
                                                    length: None,
                                                    parenthesized_length: false,
                                                },
                                                double_colon_syntax: false,
                                                trailing_comments: Vec::new(),
                                                format: None,
                                                default: None,
                                            }))
                                        })
                                        .collect();
                                    let mut new_args = vec![sep];
                                    new_args.extend(cast_args);
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "CONCAT_WS".to_string(),
                                        new_args,
                                    ))))
                                }
                                _ => Ok(Expression::Function(f)),
                            },
                            // ARRAY_SLICE(x, start, end) -> SLICE(x, start, end) for Presto/Trino/Databricks, arraySlice for ClickHouse
                            "ARRAY_SLICE" if f.args.len() >= 2 => match target {
                                DialectType::Presto
                                | DialectType::Trino
                                | DialectType::Athena
                                | DialectType::Databricks
                                | DialectType::Spark => {
                                    let mut new_f = *f;
                                    new_f.name = "SLICE".to_string();
                                    Ok(Expression::Function(Box::new(new_f)))
                                }
                                DialectType::ClickHouse => {
                                    let mut new_f = *f;
                                    new_f.name = "arraySlice".to_string();
                                    Ok(Expression::Function(Box::new(new_f)))
                                }
                                _ => Ok(Expression::Function(f)),
                            },
                            // ARRAY_PREPEND(arr, x) -> LIST_PREPEND(x, arr) for DuckDB (swap args)
                            "ARRAY_PREPEND" if f.args.len() == 2 => match target {
                                DialectType::DuckDB => {
                                    let mut args = f.args;
                                    let arr = args.remove(0);
                                    let val = args.remove(0);
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "LIST_PREPEND".to_string(),
                                        vec![val, arr],
                                    ))))
                                }
                                _ => Ok(Expression::Function(f)),
                            },
                            // ARRAY_REMOVE(arr, target) -> dialect-specific
                            "ARRAY_REMOVE" if f.args.len() == 2 => {
                                match target {
                                    DialectType::DuckDB => {
                                        let mut args = f.args;
                                        let arr = args.remove(0);
                                        let target_val = args.remove(0);
                                        let u_id = crate::expressions::Identifier::new("_u");
                                        // LIST_FILTER(arr, _u -> _u <> target)
                                        let lambda = Expression::Lambda(Box::new(
                                            crate::expressions::LambdaExpr {
                                                parameters: vec![u_id.clone()],
                                                body: Expression::Neq(Box::new(BinaryOp {
                                                    left: Expression::Identifier(u_id),
                                                    right: target_val,
                                                    left_comments: Vec::new(),
                                                    operator_comments: Vec::new(),
                                                    trailing_comments: Vec::new(),
                                                })),
                                                colon: false,
                                                parameter_types: Vec::new(),
                                            },
                                        ));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "LIST_FILTER".to_string(),
                                            vec![arr, lambda],
                                        ))))
                                    }
                                    DialectType::ClickHouse => {
                                        let mut args = f.args;
                                        let arr = args.remove(0);
                                        let target_val = args.remove(0);
                                        let u_id = crate::expressions::Identifier::new("_u");
                                        // arrayFilter(_u -> _u <> target, arr)
                                        let lambda = Expression::Lambda(Box::new(
                                            crate::expressions::LambdaExpr {
                                                parameters: vec![u_id.clone()],
                                                body: Expression::Neq(Box::new(BinaryOp {
                                                    left: Expression::Identifier(u_id),
                                                    right: target_val,
                                                    left_comments: Vec::new(),
                                                    operator_comments: Vec::new(),
                                                    trailing_comments: Vec::new(),
                                                })),
                                                colon: false,
                                                parameter_types: Vec::new(),
                                            },
                                        ));
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "arrayFilter".to_string(),
                                            vec![lambda, arr],
                                        ))))
                                    }
                                    DialectType::BigQuery => {
                                        // ARRAY(SELECT _u FROM UNNEST(the_array) AS _u WHERE _u <> target)
                                        let mut args = f.args;
                                        let arr = args.remove(0);
                                        let target_val = args.remove(0);
                                        let u_id = crate::expressions::Identifier::new("_u");
                                        let u_col =
                                            Expression::Column(crate::expressions::Column {
                                                name: u_id.clone(),
                                                table: None,
                                                join_mark: false,
                                                trailing_comments: Vec::new(),
                                            });
                                        // UNNEST(the_array) AS _u
                                        let unnest_expr = Expression::Unnest(Box::new(
                                            crate::expressions::UnnestFunc {
                                                this: arr,
                                                expressions: Vec::new(),
                                                with_ordinality: false,
                                                alias: None,
                                                offset_alias: None,
                                            },
                                        ));
                                        let aliased_unnest = Expression::Alias(Box::new(
                                            crate::expressions::Alias {
                                                this: unnest_expr,
                                                alias: u_id.clone(),
                                                column_aliases: Vec::new(),
                                                pre_alias_comments: Vec::new(),
                                                trailing_comments: Vec::new(),
                                            },
                                        ));
                                        // _u <> target
                                        let where_cond = Expression::Neq(Box::new(BinaryOp {
                                            left: u_col.clone(),
                                            right: target_val,
                                            left_comments: Vec::new(),
                                            operator_comments: Vec::new(),
                                            trailing_comments: Vec::new(),
                                        }));
                                        // SELECT _u FROM UNNEST(the_array) AS _u WHERE _u <> target
                                        let subquery = Expression::Select(Box::new(
                                            crate::expressions::Select::new()
                                                .column(u_col)
                                                .from(aliased_unnest)
                                                .where_(where_cond),
                                        ));
                                        // ARRAY(subquery) -- use ArrayFunc with subquery as single element
                                        Ok(Expression::ArrayFunc(Box::new(
                                            crate::expressions::ArrayConstructor {
                                                expressions: vec![subquery],
                                                bracket_notation: false,
                                                use_list_keyword: false,
                                            },
                                        )))
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // PARSE_JSON(str) -> remove for SQLite/Doris (just use the string literal)
                            "PARSE_JSON" if f.args.len() == 1 => {
                                match target {
                                    DialectType::SQLite
                                    | DialectType::Doris
                                    | DialectType::MySQL
                                    | DialectType::StarRocks => {
                                        // Strip PARSE_JSON, return the inner argument
                                        Ok(f.args.into_iter().next().unwrap())
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // JSON_REMOVE(PARSE_JSON(str), path...) -> for SQLite strip PARSE_JSON
                            // This is handled by PARSE_JSON stripping above; JSON_REMOVE is passed through
                            "JSON_REMOVE" => Ok(Expression::Function(f)),
                            // JSON_SET(PARSE_JSON(str), path, PARSE_JSON(val)) -> for SQLite strip PARSE_JSON
                            // This is handled by PARSE_JSON stripping above; JSON_SET is passed through
                            "JSON_SET" => Ok(Expression::Function(f)),
                            // DECODE(x, search1, result1, ..., default) -> CASE WHEN
                            // Behavior per search value type:
                            //   NULL literal -> CASE WHEN x IS NULL THEN result
                            //   Literal (number, string, bool) -> CASE WHEN x = literal THEN result
                            //   Non-literal (column, expr) -> CASE WHEN x = search OR (x IS NULL AND search IS NULL) THEN result
                            "DECODE" if f.args.len() >= 3 => {
                                // Keep as DECODE for targets that support it natively
                                let keep_as_decode = matches!(
                                    target,
                                    DialectType::Oracle
                                        | DialectType::Snowflake
                                        | DialectType::Redshift
                                        | DialectType::Teradata
                                        | DialectType::Spark
                                        | DialectType::Databricks
                                );
                                if keep_as_decode {
                                    return Ok(Expression::Function(f));
                                }

                                let mut args = f.args;
                                let this_expr = args.remove(0);
                                let mut pairs = Vec::new();
                                let mut default = None;
                                let mut i = 0;
                                while i + 1 < args.len() {
                                    pairs.push((args[i].clone(), args[i + 1].clone()));
                                    i += 2;
                                }
                                if i < args.len() {
                                    default = Some(args[i].clone());
                                }
                                // Helper: check if expression is a literal value
                                fn is_literal(e: &Expression) -> bool {
                                    matches!(
                                        e,
                                        Expression::Literal(_)
                                            | Expression::Boolean(_)
                                            | Expression::Neg(_)
                                    )
                                }
                                let whens: Vec<(Expression, Expression)> = pairs
                                    .into_iter()
                                    .map(|(search, result)| {
                                        if matches!(&search, Expression::Null(_)) {
                                            // NULL search -> IS NULL
                                            let condition = Expression::Is(Box::new(BinaryOp {
                                                left: this_expr.clone(),
                                                right: Expression::Null(crate::expressions::Null),
                                                left_comments: Vec::new(),
                                                operator_comments: Vec::new(),
                                                trailing_comments: Vec::new(),
                                            }));
                                            (condition, result)
                                        } else if is_literal(&search) {
                                            // Literal search -> simple equality
                                            let eq = Expression::Eq(Box::new(BinaryOp {
                                                left: this_expr.clone(),
                                                right: search,
                                                left_comments: Vec::new(),
                                                operator_comments: Vec::new(),
                                                trailing_comments: Vec::new(),
                                            }));
                                            (eq, result)
                                        } else {
                                            // Non-literal (column ref, expression) -> null-safe comparison
                                            let needs_paren = matches!(
                                                &search,
                                                Expression::Eq(_)
                                                    | Expression::Neq(_)
                                                    | Expression::Gt(_)
                                                    | Expression::Gte(_)
                                                    | Expression::Lt(_)
                                                    | Expression::Lte(_)
                                            );
                                            let search_for_eq = if needs_paren {
                                                Expression::Paren(Box::new(
                                                    crate::expressions::Paren {
                                                        this: search.clone(),
                                                        trailing_comments: Vec::new(),
                                                    },
                                                ))
                                            } else {
                                                search.clone()
                                            };
                                            let eq = Expression::Eq(Box::new(BinaryOp {
                                                left: this_expr.clone(),
                                                right: search_for_eq,
                                                left_comments: Vec::new(),
                                                operator_comments: Vec::new(),
                                                trailing_comments: Vec::new(),
                                            }));
                                            let search_for_null = if needs_paren {
                                                Expression::Paren(Box::new(
                                                    crate::expressions::Paren {
                                                        this: search.clone(),
                                                        trailing_comments: Vec::new(),
                                                    },
                                                ))
                                            } else {
                                                search.clone()
                                            };
                                            let x_is_null = Expression::Is(Box::new(BinaryOp {
                                                left: this_expr.clone(),
                                                right: Expression::Null(crate::expressions::Null),
                                                left_comments: Vec::new(),
                                                operator_comments: Vec::new(),
                                                trailing_comments: Vec::new(),
                                            }));
                                            let s_is_null = Expression::Is(Box::new(BinaryOp {
                                                left: search_for_null,
                                                right: Expression::Null(crate::expressions::Null),
                                                left_comments: Vec::new(),
                                                operator_comments: Vec::new(),
                                                trailing_comments: Vec::new(),
                                            }));
                                            let both_null = Expression::And(Box::new(BinaryOp {
                                                left: x_is_null,
                                                right: s_is_null,
                                                left_comments: Vec::new(),
                                                operator_comments: Vec::new(),
                                                trailing_comments: Vec::new(),
                                            }));
                                            let condition = Expression::Or(Box::new(BinaryOp {
                                                left: eq,
                                                right: Expression::Paren(Box::new(
                                                    crate::expressions::Paren {
                                                        this: both_null,
                                                        trailing_comments: Vec::new(),
                                                    },
                                                )),
                                                left_comments: Vec::new(),
                                                operator_comments: Vec::new(),
                                                trailing_comments: Vec::new(),
                                            }));
                                            (condition, result)
                                        }
                                    })
                                    .collect();
                                Ok(Expression::Case(Box::new(Case {
                                    operand: None,
                                    whens,
                                    else_: default,
                                    comments: Vec::new(),
                                })))
                            }
                            // LEVENSHTEIN(a, b, ...) -> dialect-specific
                            "LEVENSHTEIN" => {
                                match target {
                                    DialectType::BigQuery => {
                                        let mut new_f = *f;
                                        new_f.name = "EDIT_DISTANCE".to_string();
                                        Ok(Expression::Function(Box::new(new_f)))
                                    }
                                    DialectType::Drill => {
                                        let mut new_f = *f;
                                        new_f.name = "LEVENSHTEIN_DISTANCE".to_string();
                                        Ok(Expression::Function(Box::new(new_f)))
                                    }
                                    DialectType::PostgreSQL if f.args.len() == 6 => {
                                        // PostgreSQL: LEVENSHTEIN(src, tgt, ins, del, sub, max_d) -> LEVENSHTEIN_LESS_EQUAL
                                        // 2 args: basic, 5 args: with costs, 6 args: with costs + max_distance
                                        let mut new_f = *f;
                                        new_f.name = "LEVENSHTEIN_LESS_EQUAL".to_string();
                                        Ok(Expression::Function(Box::new(new_f)))
                                    }
                                    _ => Ok(Expression::Function(f)),
                                }
                            }
                            // ARRAY_REVERSE(x) -> arrayReverse(x) for ClickHouse
                            "ARRAY_REVERSE" => match target {
                                DialectType::ClickHouse => {
                                    let mut new_f = *f;
                                    new_f.name = "arrayReverse".to_string();
                                    Ok(Expression::Function(Box::new(new_f)))
                                }
                                _ => Ok(Expression::Function(f)),
                            },
                            // GENERATE_DATE_ARRAY(start, end[, step]) -> target-specific
                            "GENERATE_DATE_ARRAY" => {
                                let mut args = f.args;
                                if matches!(target, DialectType::BigQuery) {
                                    // BigQuery keeps GENERATE_DATE_ARRAY; add default interval if not present
                                    if args.len() == 2 {
                                        let default_interval = Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(Expression::Literal(Literal::String(
                                                    "1".to_string(),
                                                ))),
                                                unit: Some(
                                                    crate::expressions::IntervalUnitSpec::Simple {
                                                        unit: crate::expressions::IntervalUnit::Day,
                                                        use_plural: false,
                                                    },
                                                ),
                                            },
                                        ));
                                        args.push(default_interval);
                                    }
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "GENERATE_DATE_ARRAY".to_string(),
                                        args,
                                    ))))
                                } else if matches!(target, DialectType::DuckDB) {
                                    // DuckDB: CAST(GENERATE_SERIES(start, end, step) AS DATE[])
                                    let start = args.get(0).cloned();
                                    let end = args.get(1).cloned();
                                    let step = args.get(2).cloned().or_else(|| {
                                        Some(Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(Expression::Literal(Literal::String(
                                                    "1".to_string(),
                                                ))),
                                                unit: Some(
                                                    crate::expressions::IntervalUnitSpec::Simple {
                                                        unit: crate::expressions::IntervalUnit::Day,
                                                        use_plural: false,
                                                    },
                                                ),
                                            },
                                        )))
                                    });
                                    let gen_series = Expression::GenerateSeries(Box::new(
                                        crate::expressions::GenerateSeries {
                                            start: start.map(Box::new),
                                            end: end.map(Box::new),
                                            step: step.map(Box::new),
                                            is_end_exclusive: None,
                                        },
                                    ));
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this: gen_series,
                                        to: DataType::Array {
                                            element_type: Box::new(DataType::Date),
                                            dimension: None,
                                        },
                                        trailing_comments: vec![],
                                        double_colon_syntax: false,
                                        format: None,
                                        default: None,
                                    })))
                                } else if matches!(
                                    target,
                                    DialectType::Presto | DialectType::Trino | DialectType::Athena
                                ) {
                                    // Presto/Trino: SEQUENCE(start, end, interval) with interval normalization
                                    let start = args.get(0).cloned();
                                    let end = args.get(1).cloned();
                                    let step = args.get(2).cloned().or_else(|| {
                                        Some(Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(Expression::Literal(Literal::String(
                                                    "1".to_string(),
                                                ))),
                                                unit: Some(
                                                    crate::expressions::IntervalUnitSpec::Simple {
                                                        unit: crate::expressions::IntervalUnit::Day,
                                                        use_plural: false,
                                                    },
                                                ),
                                            },
                                        )))
                                    });
                                    let gen_series = Expression::GenerateSeries(Box::new(
                                        crate::expressions::GenerateSeries {
                                            start: start.map(Box::new),
                                            end: end.map(Box::new),
                                            step: step.map(Box::new),
                                            is_end_exclusive: None,
                                        },
                                    ));
                                    Ok(gen_series)
                                } else if matches!(
                                    target,
                                    DialectType::Spark | DialectType::Databricks
                                ) {
                                    // Spark/Databricks: SEQUENCE(start, end, step) - keep step as-is
                                    let start = args.get(0).cloned();
                                    let end = args.get(1).cloned();
                                    let step = args.get(2).cloned().or_else(|| {
                                        Some(Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(Expression::Literal(Literal::String(
                                                    "1".to_string(),
                                                ))),
                                                unit: Some(
                                                    crate::expressions::IntervalUnitSpec::Simple {
                                                        unit: crate::expressions::IntervalUnit::Day,
                                                        use_plural: false,
                                                    },
                                                ),
                                            },
                                        )))
                                    });
                                    let gen_series = Expression::GenerateSeries(Box::new(
                                        crate::expressions::GenerateSeries {
                                            start: start.map(Box::new),
                                            end: end.map(Box::new),
                                            step: step.map(Box::new),
                                            is_end_exclusive: None,
                                        },
                                    ));
                                    Ok(gen_series)
                                } else if matches!(target, DialectType::Snowflake) {
                                    // Snowflake: keep as GENERATE_DATE_ARRAY for later transform
                                    if args.len() == 2 {
                                        let default_interval = Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(Expression::Literal(Literal::String(
                                                    "1".to_string(),
                                                ))),
                                                unit: Some(
                                                    crate::expressions::IntervalUnitSpec::Simple {
                                                        unit: crate::expressions::IntervalUnit::Day,
                                                        use_plural: false,
                                                    },
                                                ),
                                            },
                                        ));
                                        args.push(default_interval);
                                    }
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "GENERATE_DATE_ARRAY".to_string(),
                                        args,
                                    ))))
                                } else if matches!(
                                    target,
                                    DialectType::MySQL
                                        | DialectType::TSQL
                                        | DialectType::Fabric
                                        | DialectType::Redshift
                                ) {
                                    // MySQL/TSQL/Redshift: keep as GENERATE_DATE_ARRAY for the preprocess
                                    // step (unnest_generate_date_array_using_recursive_cte) to convert to CTE
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "GENERATE_DATE_ARRAY".to_string(),
                                        args,
                                    ))))
                                } else {
                                    // PostgreSQL/others: convert to GenerateSeries
                                    let start = args.get(0).cloned();
                                    let end = args.get(1).cloned();
                                    let step = args.get(2).cloned().or_else(|| {
                                        Some(Expression::Interval(Box::new(
                                            crate::expressions::Interval {
                                                this: Some(Expression::Literal(Literal::String(
                                                    "1".to_string(),
                                                ))),
                                                unit: Some(
                                                    crate::expressions::IntervalUnitSpec::Simple {
                                                        unit: crate::expressions::IntervalUnit::Day,
                                                        use_plural: false,
                                                    },
                                                ),
                                            },
                                        )))
                                    });
                                    Ok(Expression::GenerateSeries(Box::new(
                                        crate::expressions::GenerateSeries {
                                            start: start.map(Box::new),
                                            end: end.map(Box::new),
                                            step: step.map(Box::new),
                                            is_end_exclusive: None,
                                        },
                                    )))
                                }
                            }
                            _ => Ok(Expression::Function(f)),
                        }
                    } else if let Expression::AggregateFunction(mut af) = e {
                        let name = af.name.to_uppercase();
                        match name.as_str() {
                            "ARBITRARY" if af.args.len() == 1 => {
                                let arg = af.args.into_iter().next().unwrap();
                                Ok(convert_arbitrary(arg, target))
                            }
                            "JSON_ARRAYAGG" => {
                                match target {
                                    DialectType::PostgreSQL => {
                                        af.name = "JSON_AGG".to_string();
                                        // Add NULLS FIRST to ORDER BY items for PostgreSQL
                                        for ordered in af.order_by.iter_mut() {
                                            if ordered.nulls_first.is_none() {
                                                ordered.nulls_first = Some(true);
                                            }
                                        }
                                        Ok(Expression::AggregateFunction(af))
                                    }
                                    _ => Ok(Expression::AggregateFunction(af)),
                                }
                            }
                            _ => Ok(Expression::AggregateFunction(af)),
                        }
                    } else if let Expression::JSONArrayAgg(ja) = e {
                        // JSONArrayAgg -> JSON_AGG for PostgreSQL, JSON_ARRAYAGG for others
                        match target {
                            DialectType::PostgreSQL => {
                                let mut order_by = Vec::new();
                                if let Some(order_expr) = ja.order {
                                    if let Expression::OrderBy(ob) = *order_expr {
                                        for mut ordered in ob.expressions {
                                            if ordered.nulls_first.is_none() {
                                                ordered.nulls_first = Some(true);
                                            }
                                            order_by.push(ordered);
                                        }
                                    }
                                }
                                Ok(Expression::AggregateFunction(Box::new(
                                    crate::expressions::AggregateFunction {
                                        name: "JSON_AGG".to_string(),
                                        args: vec![*ja.this],
                                        distinct: false,
                                        filter: None,
                                        order_by,
                                        limit: None,
                                        ignore_nulls: None,
                                    },
                                )))
                            }
                            _ => Ok(Expression::JSONArrayAgg(ja)),
                        }
                    } else if let Expression::ToNumber(tn) = e {
                        // TO_NUMBER(x) with no format/precision/scale -> CAST(x AS DOUBLE)
                        let arg = *tn.this;
                        Ok(Expression::Cast(Box::new(crate::expressions::Cast {
                            this: arg,
                            to: crate::expressions::DataType::Double {
                                precision: None,
                                scale: None,
                            },
                            double_colon_syntax: false,
                            trailing_comments: Vec::new(),
                            format: None,
                            default: None,
                        })))
                    } else {
                        Ok(e)
                    }
                }

                Action::RegexpLikeToDuckDB => {
                    if let Expression::RegexpLike(f) = e {
                        let mut args = vec![f.this, f.pattern];
                        if let Some(flags) = f.flags {
                            args.push(flags);
                        }
                        Ok(Expression::Function(Box::new(Function::new(
                            "REGEXP_MATCHES".to_string(),
                            args,
                        ))))
                    } else {
                        Ok(e)
                    }
                }
                Action::EpochConvert => {
                    if let Expression::Epoch(f) = e {
                        let arg = f.this;
                        let name = match target {
                            DialectType::Spark | DialectType::Databricks | DialectType::Hive => {
                                "UNIX_TIMESTAMP"
                            }
                            DialectType::Presto | DialectType::Trino => "TO_UNIXTIME",
                            DialectType::BigQuery => "TIME_TO_UNIX",
                            _ => "EPOCH",
                        };
                        Ok(Expression::Function(Box::new(Function::new(
                            name.to_string(),
                            vec![arg],
                        ))))
                    } else {
                        Ok(e)
                    }
                }
                Action::EpochMsConvert => {
                    use crate::expressions::{BinaryOp, Cast};
                    if let Expression::EpochMs(f) = e {
                        let arg = f.this;
                        match target {
                            DialectType::Spark | DialectType::Databricks => {
                                Ok(Expression::Function(Box::new(Function::new(
                                    "TIMESTAMP_MILLIS".to_string(),
                                    vec![arg],
                                ))))
                            }
                            DialectType::BigQuery => Ok(Expression::Function(Box::new(
                                Function::new("TIMESTAMP_MILLIS".to_string(), vec![arg]),
                            ))),
                            DialectType::Presto | DialectType::Trino => {
                                // FROM_UNIXTIME(CAST(x AS DOUBLE) / POW(10, 3))
                                let cast_arg = Expression::Cast(Box::new(Cast {
                                    this: arg,
                                    to: DataType::Double {
                                        precision: None,
                                        scale: None,
                                    },
                                    trailing_comments: Vec::new(),
                                    double_colon_syntax: false,
                                    format: None,
                                    default: None,
                                }));
                                let div = Expression::Div(Box::new(BinaryOp::new(
                                    cast_arg,
                                    Expression::Function(Box::new(Function::new(
                                        "POW".to_string(),
                                        vec![Expression::number(10), Expression::number(3)],
                                    ))),
                                )));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "FROM_UNIXTIME".to_string(),
                                    vec![div],
                                ))))
                            }
                            DialectType::MySQL => {
                                // FROM_UNIXTIME(x / POWER(10, 3))
                                let div = Expression::Div(Box::new(BinaryOp::new(
                                    arg,
                                    Expression::Function(Box::new(Function::new(
                                        "POWER".to_string(),
                                        vec![Expression::number(10), Expression::number(3)],
                                    ))),
                                )));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "FROM_UNIXTIME".to_string(),
                                    vec![div],
                                ))))
                            }
                            DialectType::PostgreSQL | DialectType::Redshift => {
                                // TO_TIMESTAMP(CAST(x AS DOUBLE PRECISION) / POWER(10, 3))
                                let cast_arg = Expression::Cast(Box::new(Cast {
                                    this: arg,
                                    to: DataType::Custom {
                                        name: "DOUBLE PRECISION".to_string(),
                                    },
                                    trailing_comments: Vec::new(),
                                    double_colon_syntax: false,
                                    format: None,
                                    default: None,
                                }));
                                let div = Expression::Div(Box::new(BinaryOp::new(
                                    cast_arg,
                                    Expression::Function(Box::new(Function::new(
                                        "POWER".to_string(),
                                        vec![Expression::number(10), Expression::number(3)],
                                    ))),
                                )));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "TO_TIMESTAMP".to_string(),
                                    vec![div],
                                ))))
                            }
                            DialectType::ClickHouse => {
                                // fromUnixTimestamp64Milli(CAST(x AS Nullable(Int64)))
                                let cast_arg = Expression::Cast(Box::new(Cast {
                                    this: arg,
                                    to: DataType::Nullable {
                                        inner: Box::new(DataType::BigInt { length: None }),
                                    },
                                    trailing_comments: Vec::new(),
                                    double_colon_syntax: false,
                                    format: None,
                                    default: None,
                                }));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "fromUnixTimestamp64Milli".to_string(),
                                    vec![cast_arg],
                                ))))
                            }
                            _ => Ok(Expression::Function(Box::new(Function::new(
                                "EPOCH_MS".to_string(),
                                vec![arg],
                            )))),
                        }
                    } else {
                        Ok(e)
                    }
                }
                Action::TSQLTypeNormalize => {
                    if let Expression::DataType(dt) = e {
                        let new_dt = match &dt {
                            DataType::Custom { name } if name.eq_ignore_ascii_case("MONEY") => {
                                DataType::Decimal {
                                    precision: Some(15),
                                    scale: Some(4),
                                }
                            }
                            DataType::Custom { name }
                                if name.eq_ignore_ascii_case("SMALLMONEY") =>
                            {
                                DataType::Decimal {
                                    precision: Some(6),
                                    scale: Some(4),
                                }
                            }
                            DataType::Custom { name } if name.eq_ignore_ascii_case("DATETIME2") => {
                                DataType::Timestamp {
                                    timezone: false,
                                    precision: None,
                                }
                            }
                            DataType::Custom { name } if name.eq_ignore_ascii_case("REAL") => {
                                DataType::Float {
                                    precision: None,
                                    scale: None,
                                    real_spelling: false,
                                }
                            }
                            DataType::Float {
                                real_spelling: true,
                                ..
                            } => DataType::Float {
                                precision: None,
                                scale: None,
                                real_spelling: false,
                            },
                            DataType::Custom { name } if name.eq_ignore_ascii_case("IMAGE") => {
                                DataType::Custom {
                                    name: "BLOB".to_string(),
                                }
                            }
                            DataType::Custom { name } if name.eq_ignore_ascii_case("BIT") => {
                                DataType::Boolean
                            }
                            DataType::Custom { name }
                                if name.eq_ignore_ascii_case("ROWVERSION") =>
                            {
                                DataType::Custom {
                                    name: "BINARY".to_string(),
                                }
                            }
                            DataType::Custom { name }
                                if name.eq_ignore_ascii_case("UNIQUEIDENTIFIER") =>
                            {
                                match target {
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => DataType::Custom {
                                        name: "STRING".to_string(),
                                    },
                                    _ => DataType::VarChar {
                                        length: Some(36),
                                        parenthesized_length: true,
                                    },
                                }
                            }
                            DataType::Custom { name }
                                if name.eq_ignore_ascii_case("DATETIMEOFFSET") =>
                            {
                                match target {
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => DataType::Timestamp {
                                        timezone: false,
                                        precision: None,
                                    },
                                    _ => DataType::Timestamp {
                                        timezone: true,
                                        precision: None,
                                    },
                                }
                            }
                            DataType::Custom { ref name }
                                if name.to_uppercase().starts_with("DATETIME2(") =>
                            {
                                // DATETIME2(n) -> TIMESTAMP
                                DataType::Timestamp {
                                    timezone: false,
                                    precision: None,
                                }
                            }
                            DataType::Custom { ref name }
                                if name.to_uppercase().starts_with("TIME(") =>
                            {
                                // TIME(n) -> TIMESTAMP for Spark, keep as TIME for others
                                match target {
                                    DialectType::Spark
                                    | DialectType::Databricks
                                    | DialectType::Hive => DataType::Timestamp {
                                        timezone: false,
                                        precision: None,
                                    },
                                    _ => return Ok(Expression::DataType(dt)),
                                }
                            }
                            DataType::Custom { ref name }
                                if name.to_uppercase().starts_with("NUMERIC") =>
                            {
                                // Parse NUMERIC(p,s) back to Decimal(p,s)
                                let upper = name.to_uppercase();
                                if let Some(inner) = upper
                                    .strip_prefix("NUMERIC(")
                                    .and_then(|s| s.strip_suffix(')'))
                                {
                                    let parts: Vec<&str> = inner.split(',').collect();
                                    let precision =
                                        parts.first().and_then(|s| s.trim().parse::<u32>().ok());
                                    let scale =
                                        parts.get(1).and_then(|s| s.trim().parse::<u32>().ok());
                                    DataType::Decimal { precision, scale }
                                } else if upper == "NUMERIC" {
                                    DataType::Decimal {
                                        precision: None,
                                        scale: None,
                                    }
                                } else {
                                    return Ok(Expression::DataType(dt));
                                }
                            }
                            DataType::Float {
                                precision: Some(p), ..
                            } => {
                                // For Hive/Spark: FLOAT(1-32) -> FLOAT, FLOAT(33+) -> DOUBLE (IEEE 754 boundary)
                                // For other targets: FLOAT(1-24) -> FLOAT, FLOAT(25+) -> DOUBLE (TSQL boundary)
                                let boundary = match target {
                                    DialectType::Hive
                                    | DialectType::Spark
                                    | DialectType::Databricks => 32,
                                    _ => 24,
                                };
                                if *p <= boundary {
                                    DataType::Float {
                                        precision: None,
                                        scale: None,
                                        real_spelling: false,
                                    }
                                } else {
                                    DataType::Double {
                                        precision: None,
                                        scale: None,
                                    }
                                }
                            }
                            DataType::TinyInt { .. } => match target {
                                DialectType::DuckDB => DataType::Custom {
                                    name: "UTINYINT".to_string(),
                                },
                                DialectType::Hive
                                | DialectType::Spark
                                | DialectType::Databricks => DataType::SmallInt { length: None },
                                _ => return Ok(Expression::DataType(dt)),
                            },
                            // INTEGER -> INT for Spark/Databricks
                            DataType::Int {
                                length,
                                integer_spelling: true,
                            } => DataType::Int {
                                length: *length,
                                integer_spelling: false,
                            },
                            _ => return Ok(Expression::DataType(dt)),
                        };
                        Ok(Expression::DataType(new_dt))
                    } else {
                        Ok(e)
                    }
                }
                Action::MySQLSafeDivide => {
                    use crate::expressions::{BinaryOp, Cast};
                    if let Expression::Div(op) = e {
                        let left = op.left;
                        let right = op.right;
                        // For SQLite: CAST left as REAL but NO NULLIF wrapping
                        if matches!(target, DialectType::SQLite) {
                            let new_left = Expression::Cast(Box::new(Cast {
                                this: left,
                                to: DataType::Float {
                                    precision: None,
                                    scale: None,
                                    real_spelling: true,
                                },
                                trailing_comments: Vec::new(),
                                double_colon_syntax: false,
                                format: None,
                                default: None,
                            }));
                            return Ok(Expression::Div(Box::new(BinaryOp::new(new_left, right))));
                        }
                        // Wrap right in NULLIF(right, 0)
                        let nullif_right = Expression::Function(Box::new(Function::new(
                            "NULLIF".to_string(),
                            vec![right, Expression::number(0)],
                        )));
                        // For some dialects, also CAST the left side
                        let new_left = match target {
                            DialectType::PostgreSQL
                            | DialectType::Redshift
                            | DialectType::Teradata
                            | DialectType::Materialize
                            | DialectType::RisingWave => Expression::Cast(Box::new(Cast {
                                this: left,
                                to: DataType::Custom {
                                    name: "DOUBLE PRECISION".to_string(),
                                },
                                trailing_comments: Vec::new(),
                                double_colon_syntax: false,
                                format: None,
                                default: None,
                            })),
                            DialectType::Drill
                            | DialectType::Trino
                            | DialectType::Presto
                            | DialectType::Athena => Expression::Cast(Box::new(Cast {
                                this: left,
                                to: DataType::Double {
                                    precision: None,
                                    scale: None,
                                },
                                trailing_comments: Vec::new(),
                                double_colon_syntax: false,
                                format: None,
                                default: None,
                            })),
                            DialectType::TSQL => Expression::Cast(Box::new(Cast {
                                this: left,
                                to: DataType::Float {
                                    precision: None,
                                    scale: None,
                                    real_spelling: false,
                                },
                                trailing_comments: Vec::new(),
                                double_colon_syntax: false,
                                format: None,
                                default: None,
                            })),
                            _ => left,
                        };
                        Ok(Expression::Div(Box::new(BinaryOp::new(
                            new_left,
                            nullif_right,
                        ))))
                    } else {
                        Ok(e)
                    }
                }
                Action::AlterTableRenameStripSchema => {
                    if let Expression::AlterTable(mut at) = e {
                        if let Some(crate::expressions::AlterTableAction::RenameTable(
                            ref mut new_tbl,
                        )) = at.actions.first_mut()
                        {
                            new_tbl.schema = None;
                            new_tbl.catalog = None;
                        }
                        Ok(Expression::AlterTable(at))
                    } else {
                        Ok(e)
                    }
                }
                Action::NullsOrdering => {
                    // Fill in the source dialect's implied null ordering default.
                    // This makes implicit null ordering explicit so the target generator
                    // can correctly strip or keep it.
                    //
                    // Dialect null ordering categories:
                    // nulls_are_large (Oracle, PostgreSQL, Redshift, Snowflake):
                    //   ASC -> NULLS LAST, DESC -> NULLS FIRST
                    // nulls_are_small (Spark, Hive, BigQuery, MySQL, Databricks, ClickHouse, etc.):
                    //   ASC -> NULLS FIRST, DESC -> NULLS LAST
                    // nulls_are_last (DuckDB, Presto, Trino, Dremio, Athena):
                    //   NULLS LAST always (both ASC and DESC)
                    if let Expression::Ordered(mut o) = e {
                        let is_asc = !o.desc;

                        let is_source_nulls_large = matches!(
                            source,
                            DialectType::Oracle
                                | DialectType::PostgreSQL
                                | DialectType::Redshift
                                | DialectType::Snowflake
                        );
                        let is_source_nulls_last = matches!(
                            source,
                            DialectType::DuckDB
                                | DialectType::Presto
                                | DialectType::Trino
                                | DialectType::Dremio
                                | DialectType::Athena
                                | DialectType::ClickHouse
                                | DialectType::Drill
                                | DialectType::Exasol
                                | DialectType::DataFusion
                        );

                        // Determine target category to check if default matches
                        let is_target_nulls_large = matches!(
                            target,
                            DialectType::Oracle
                                | DialectType::PostgreSQL
                                | DialectType::Redshift
                                | DialectType::Snowflake
                        );
                        let is_target_nulls_last = matches!(
                            target,
                            DialectType::DuckDB
                                | DialectType::Presto
                                | DialectType::Trino
                                | DialectType::Dremio
                                | DialectType::Athena
                                | DialectType::ClickHouse
                                | DialectType::Drill
                                | DialectType::Exasol
                                | DialectType::DataFusion
                        );

                        // Compute the implied nulls_first for source
                        let source_nulls_first = if is_source_nulls_large {
                            !is_asc // ASC -> NULLS LAST (false), DESC -> NULLS FIRST (true)
                        } else if is_source_nulls_last {
                            false // NULLS LAST always
                        } else {
                            is_asc // nulls_are_small: ASC -> NULLS FIRST (true), DESC -> NULLS LAST (false)
                        };

                        // Compute the target's default
                        let target_nulls_first = if is_target_nulls_large {
                            !is_asc
                        } else if is_target_nulls_last {
                            false
                        } else {
                            is_asc
                        };

                        // Only add explicit nulls ordering if source and target defaults differ
                        if source_nulls_first != target_nulls_first {
                            o.nulls_first = Some(source_nulls_first);
                        }
                        // If they match, leave nulls_first as None so the generator won't output it

                        Ok(Expression::Ordered(o))
                    } else {
                        Ok(e)
                    }
                }
                Action::StringAggConvert => {
                    match e {
                        Expression::WithinGroup(wg) => {
                            // STRING_AGG(x, sep) WITHIN GROUP (ORDER BY z) -> target-specific
                            // Extract args and distinct flag from either Function, AggregateFunction, or StringAgg
                            let (x_opt, sep_opt, distinct) = match wg.this {
                                Expression::AggregateFunction(ref af)
                                    if af.name.eq_ignore_ascii_case("STRING_AGG")
                                        && af.args.len() >= 2 =>
                                {
                                    (
                                        Some(af.args[0].clone()),
                                        Some(af.args[1].clone()),
                                        af.distinct,
                                    )
                                }
                                Expression::Function(ref f)
                                    if f.name.eq_ignore_ascii_case("STRING_AGG")
                                        && f.args.len() >= 2 =>
                                {
                                    (Some(f.args[0].clone()), Some(f.args[1].clone()), false)
                                }
                                Expression::StringAgg(ref sa) => {
                                    (Some(sa.this.clone()), sa.separator.clone(), sa.distinct)
                                }
                                _ => (None, None, false),
                            };
                            if let (Some(x), Some(sep)) = (x_opt, sep_opt) {
                                let order_by = wg.order_by;

                                match target {
                                    DialectType::TSQL | DialectType::Fabric => {
                                        // Keep as WithinGroup(StringAgg) for TSQL
                                        Ok(Expression::WithinGroup(Box::new(
                                            crate::expressions::WithinGroup {
                                                this: Expression::StringAgg(Box::new(
                                                    crate::expressions::StringAggFunc {
                                                        this: x,
                                                        separator: Some(sep),
                                                        order_by: None, // order_by goes in WithinGroup, not StringAgg
                                                        distinct,
                                                        filter: None,
                                                        limit: None,
                                                    },
                                                )),
                                                order_by,
                                            },
                                        )))
                                    }
                                    DialectType::MySQL
                                    | DialectType::SingleStore
                                    | DialectType::Doris
                                    | DialectType::StarRocks => {
                                        // GROUP_CONCAT(x ORDER BY z SEPARATOR sep)
                                        Ok(Expression::GroupConcat(Box::new(
                                            crate::expressions::GroupConcatFunc {
                                                this: x,
                                                separator: Some(sep),
                                                order_by: Some(order_by),
                                                distinct,
                                                filter: None,
                                            },
                                        )))
                                    }
                                    DialectType::SQLite => {
                                        // GROUP_CONCAT(x, sep) - no ORDER BY support
                                        Ok(Expression::GroupConcat(Box::new(
                                            crate::expressions::GroupConcatFunc {
                                                this: x,
                                                separator: Some(sep),
                                                order_by: None,
                                                distinct,
                                                filter: None,
                                            },
                                        )))
                                    }
                                    DialectType::PostgreSQL | DialectType::Redshift => {
                                        // STRING_AGG(x, sep ORDER BY z)
                                        Ok(Expression::StringAgg(Box::new(
                                            crate::expressions::StringAggFunc {
                                                this: x,
                                                separator: Some(sep),
                                                order_by: Some(order_by),
                                                distinct,
                                                filter: None,
                                                limit: None,
                                            },
                                        )))
                                    }
                                    _ => {
                                        // Default: keep as STRING_AGG(x, sep) with ORDER BY inside
                                        Ok(Expression::StringAgg(Box::new(
                                            crate::expressions::StringAggFunc {
                                                this: x,
                                                separator: Some(sep),
                                                order_by: Some(order_by),
                                                distinct,
                                                filter: None,
                                                limit: None,
                                            },
                                        )))
                                    }
                                }
                            } else {
                                Ok(Expression::WithinGroup(wg))
                            }
                        }
                        Expression::StringAgg(sa) => {
                            match target {
                                DialectType::MySQL
                                | DialectType::SingleStore
                                | DialectType::Doris
                                | DialectType::StarRocks => {
                                    // STRING_AGG(x, sep) -> GROUP_CONCAT(x SEPARATOR sep)
                                    Ok(Expression::GroupConcat(Box::new(
                                        crate::expressions::GroupConcatFunc {
                                            this: sa.this,
                                            separator: sa.separator,
                                            order_by: sa.order_by,
                                            distinct: sa.distinct,
                                            filter: sa.filter,
                                        },
                                    )))
                                }
                                DialectType::SQLite => {
                                    // STRING_AGG(x, sep) -> GROUP_CONCAT(x, sep)
                                    Ok(Expression::GroupConcat(Box::new(
                                        crate::expressions::GroupConcatFunc {
                                            this: sa.this,
                                            separator: sa.separator,
                                            order_by: None, // SQLite doesn't support ORDER BY in GROUP_CONCAT
                                            distinct: sa.distinct,
                                            filter: sa.filter,
                                        },
                                    )))
                                }
                                DialectType::Spark | DialectType::Databricks => {
                                    // STRING_AGG(x, sep) -> LISTAGG(x, sep)
                                    Ok(Expression::ListAgg(Box::new(
                                        crate::expressions::ListAggFunc {
                                            this: sa.this,
                                            separator: sa.separator,
                                            on_overflow: None,
                                            order_by: sa.order_by,
                                            distinct: sa.distinct,
                                            filter: None,
                                        },
                                    )))
                                }
                                _ => Ok(Expression::StringAgg(sa)),
                            }
                        }
                        _ => Ok(e),
                    }
                }
                Action::GroupConcatConvert => {
                    // Helper to expand CONCAT(a, b, c) -> a || b || c (for PostgreSQL/SQLite)
                    // or CONCAT(a, b, c) -> a + b + c (for TSQL)
                    fn expand_concat_to_dpipe(expr: Expression) -> Expression {
                        if let Expression::Function(ref f) = expr {
                            if f.name.to_uppercase() == "CONCAT" && f.args.len() > 1 {
                                let mut result = f.args[0].clone();
                                for arg in &f.args[1..] {
                                    result = Expression::Concat(Box::new(BinaryOp {
                                        left: result,
                                        right: arg.clone(),
                                        left_comments: vec![],
                                        operator_comments: vec![],
                                        trailing_comments: vec![],
                                    }));
                                }
                                return result;
                            }
                        }
                        expr
                    }
                    fn expand_concat_to_plus(expr: Expression) -> Expression {
                        if let Expression::Function(ref f) = expr {
                            if f.name.to_uppercase() == "CONCAT" && f.args.len() > 1 {
                                let mut result = f.args[0].clone();
                                for arg in &f.args[1..] {
                                    result = Expression::Add(Box::new(BinaryOp {
                                        left: result,
                                        right: arg.clone(),
                                        left_comments: vec![],
                                        operator_comments: vec![],
                                        trailing_comments: vec![],
                                    }));
                                }
                                return result;
                            }
                        }
                        expr
                    }
                    // Helper to wrap each arg in CAST(arg AS VARCHAR) for Presto/Trino CONCAT
                    fn wrap_concat_args_in_varchar_cast(expr: Expression) -> Expression {
                        if let Expression::Function(ref f) = expr {
                            if f.name.to_uppercase() == "CONCAT" && f.args.len() > 1 {
                                let new_args: Vec<Expression> = f
                                    .args
                                    .iter()
                                    .map(|arg| {
                                        Expression::Cast(Box::new(crate::expressions::Cast {
                                            this: arg.clone(),
                                            to: crate::expressions::DataType::VarChar {
                                                length: None,
                                                parenthesized_length: false,
                                            },
                                            trailing_comments: Vec::new(),
                                            double_colon_syntax: false,
                                            format: None,
                                            default: None,
                                        }))
                                    })
                                    .collect();
                                return Expression::Function(Box::new(
                                    crate::expressions::Function::new(
                                        "CONCAT".to_string(),
                                        new_args,
                                    ),
                                ));
                            }
                        }
                        expr
                    }
                    if let Expression::GroupConcat(gc) = e {
                        match target {
                            DialectType::Presto => {
                                // GROUP_CONCAT(x [, sep]) -> ARRAY_JOIN(ARRAY_AGG(x), sep)
                                let sep = gc.separator.unwrap_or(Expression::string(","));
                                // For multi-arg CONCAT, wrap each arg in CAST(... AS VARCHAR)
                                let this = wrap_concat_args_in_varchar_cast(gc.this);
                                let array_agg =
                                    Expression::ArrayAgg(Box::new(crate::expressions::AggFunc {
                                        this,
                                        distinct: gc.distinct,
                                        filter: gc.filter,
                                        order_by: gc.order_by.unwrap_or_default(),
                                        name: None,
                                        ignore_nulls: None,
                                        having_max: None,
                                        limit: None,
                                    }));
                                Ok(Expression::ArrayJoin(Box::new(
                                    crate::expressions::ArrayJoinFunc {
                                        this: array_agg,
                                        separator: sep,
                                        null_replacement: None,
                                    },
                                )))
                            }
                            DialectType::Trino => {
                                // GROUP_CONCAT(x [, sep]) -> LISTAGG(x, sep)
                                let sep = gc.separator.unwrap_or(Expression::string(","));
                                // For multi-arg CONCAT, wrap each arg in CAST(... AS VARCHAR)
                                let this = wrap_concat_args_in_varchar_cast(gc.this);
                                Ok(Expression::ListAgg(Box::new(
                                    crate::expressions::ListAggFunc {
                                        this,
                                        separator: Some(sep),
                                        on_overflow: None,
                                        order_by: gc.order_by,
                                        distinct: gc.distinct,
                                        filter: gc.filter,
                                    },
                                )))
                            }
                            DialectType::PostgreSQL
                            | DialectType::Redshift
                            | DialectType::Snowflake
                            | DialectType::DuckDB
                            | DialectType::Hive
                            | DialectType::ClickHouse => {
                                // GROUP_CONCAT(x [, sep]) -> STRING_AGG(x, sep)
                                let sep = gc.separator.unwrap_or(Expression::string(","));
                                // Expand CONCAT(a,b,c) -> a || b || c for || dialects
                                let this = expand_concat_to_dpipe(gc.this);
                                // For PostgreSQL, add NULLS LAST for DESC / NULLS FIRST for ASC
                                let order_by = if target == DialectType::PostgreSQL {
                                    gc.order_by.map(|ords| {
                                        ords.into_iter()
                                            .map(|mut o| {
                                                if o.nulls_first.is_none() {
                                                    if o.desc {
                                                        o.nulls_first = Some(false);
                                                    // NULLS LAST
                                                    } else {
                                                        o.nulls_first = Some(true);
                                                        // NULLS FIRST
                                                    }
                                                }
                                                o
                                            })
                                            .collect()
                                    })
                                } else {
                                    gc.order_by
                                };
                                Ok(Expression::StringAgg(Box::new(
                                    crate::expressions::StringAggFunc {
                                        this,
                                        separator: Some(sep),
                                        order_by,
                                        distinct: gc.distinct,
                                        filter: gc.filter,
                                        limit: None,
                                    },
                                )))
                            }
                            DialectType::TSQL => {
                                // GROUP_CONCAT(x [, sep]) -> STRING_AGG(x, sep) WITHIN GROUP (ORDER BY ...)
                                // TSQL doesn't support DISTINCT in STRING_AGG
                                let sep = gc.separator.unwrap_or(Expression::string(","));
                                // Expand CONCAT(a,b,c) -> a + b + c for TSQL
                                let this = expand_concat_to_plus(gc.this);
                                Ok(Expression::StringAgg(Box::new(
                                    crate::expressions::StringAggFunc {
                                        this,
                                        separator: Some(sep),
                                        order_by: gc.order_by,
                                        distinct: false, // TSQL doesn't support DISTINCT in STRING_AGG
                                        filter: gc.filter,
                                        limit: None,
                                    },
                                )))
                            }
                            DialectType::SQLite => {
                                // GROUP_CONCAT stays as GROUP_CONCAT but ORDER BY is removed
                                // SQLite GROUP_CONCAT doesn't support ORDER BY
                                // Expand CONCAT(a,b,c) -> a || b || c
                                let this = expand_concat_to_dpipe(gc.this);
                                Ok(Expression::GroupConcat(Box::new(
                                    crate::expressions::GroupConcatFunc {
                                        this,
                                        separator: gc.separator,
                                        order_by: None, // SQLite doesn't support ORDER BY in GROUP_CONCAT
                                        distinct: gc.distinct,
                                        filter: gc.filter,
                                    },
                                )))
                            }
                            DialectType::Spark | DialectType::Databricks => {
                                // GROUP_CONCAT(x [, sep]) -> LISTAGG(x, sep)
                                let sep = gc.separator.unwrap_or(Expression::string(","));
                                Ok(Expression::ListAgg(Box::new(
                                    crate::expressions::ListAggFunc {
                                        this: gc.this,
                                        separator: Some(sep),
                                        on_overflow: None,
                                        order_by: gc.order_by,
                                        distinct: gc.distinct,
                                        filter: None,
                                    },
                                )))
                            }
                            DialectType::MySQL
                            | DialectType::SingleStore
                            | DialectType::StarRocks => {
                                // MySQL GROUP_CONCAT should have explicit SEPARATOR (default ',')
                                if gc.separator.is_none() {
                                    let mut gc = gc;
                                    gc.separator = Some(Expression::string(","));
                                    Ok(Expression::GroupConcat(gc))
                                } else {
                                    Ok(Expression::GroupConcat(gc))
                                }
                            }
                            _ => Ok(Expression::GroupConcat(gc)),
                        }
                    } else {
                        Ok(e)
                    }
                }
                Action::TempTableHash => {
                    match e {
                        Expression::CreateTable(mut ct) => {
                            // TSQL #table -> TEMPORARY TABLE with # stripped from name
                            let name = &ct.name.name.name;
                            if name.starts_with('#') {
                                ct.name.name.name = name.trim_start_matches('#').to_string();
                            }
                            // Set temporary flag
                            ct.temporary = true;
                            Ok(Expression::CreateTable(ct))
                        }
                        Expression::Table(mut tr) => {
                            // Strip # from table references
                            let name = &tr.name.name;
                            if name.starts_with('#') {
                                tr.name.name = name.trim_start_matches('#').to_string();
                            }
                            Ok(Expression::Table(tr))
                        }
                        Expression::DropTable(mut dt) => {
                            // Strip # from DROP TABLE names
                            for table_ref in &mut dt.names {
                                if table_ref.name.name.starts_with('#') {
                                    table_ref.name.name =
                                        table_ref.name.name.trim_start_matches('#').to_string();
                                }
                            }
                            Ok(Expression::DropTable(dt))
                        }
                        _ => Ok(e),
                    }
                }
                Action::NvlClearOriginal => {
                    if let Expression::Nvl(mut f) = e {
                        f.original_name = None;
                        Ok(Expression::Nvl(f))
                    } else {
                        Ok(e)
                    }
                }
                Action::HiveCastToTryCast => {
                    // Convert Hive/Spark CAST to TRY_CAST for targets that support it
                    if let Expression::Cast(mut c) = e {
                        // For Spark/Hive -> DuckDB: TIMESTAMP -> TIMESTAMPTZ
                        // (Spark's TIMESTAMP is always timezone-aware)
                        if matches!(target, DialectType::DuckDB)
                            && matches!(source, DialectType::Spark | DialectType::Databricks)
                            && matches!(
                                c.to,
                                DataType::Timestamp {
                                    timezone: false,
                                    ..
                                }
                            )
                        {
                            c.to = DataType::Custom {
                                name: "TIMESTAMPTZ".to_string(),
                            };
                        }
                        // For Spark source -> Databricks: VARCHAR/CHAR -> STRING
                        // Spark parses VARCHAR(n)/CHAR(n) as TEXT, normalize to STRING
                        if matches!(target, DialectType::Databricks | DialectType::Spark)
                            && matches!(
                                source,
                                DialectType::Spark | DialectType::Databricks | DialectType::Hive
                            )
                            && Self::has_varchar_char_type(&c.to)
                        {
                            c.to = Self::normalize_varchar_to_string(c.to);
                        }
                        Ok(Expression::TryCast(c))
                    } else {
                        Ok(e)
                    }
                }
                Action::XorExpand => {
                    // Expand XOR to (a AND NOT b) OR (NOT a AND b) for dialects without XOR keyword
                    // Snowflake: use BOOLXOR(a, b) instead
                    if let Expression::Xor(xor) = e {
                        // Collect all XOR operands
                        let mut operands = Vec::new();
                        if let Some(this) = xor.this {
                            operands.push(*this);
                        }
                        if let Some(expr) = xor.expression {
                            operands.push(*expr);
                        }
                        operands.extend(xor.expressions);

                        // Snowflake: use BOOLXOR(a, b)
                        if matches!(target, DialectType::Snowflake) && operands.len() == 2 {
                            let a = operands.remove(0);
                            let b = operands.remove(0);
                            return Ok(Expression::Function(Box::new(Function::new(
                                "BOOLXOR".to_string(),
                                vec![a, b],
                            ))));
                        }

                        // Helper to build (a AND NOT b) OR (NOT a AND b)
                        let make_xor = |a: Expression, b: Expression| -> Expression {
                            let not_b = Expression::Not(Box::new(
                                crate::expressions::UnaryOp::new(b.clone()),
                            ));
                            let not_a = Expression::Not(Box::new(
                                crate::expressions::UnaryOp::new(a.clone()),
                            ));
                            let left_and = Expression::And(Box::new(BinaryOp {
                                left: a,
                                right: Expression::Paren(Box::new(Paren {
                                    this: not_b,
                                    trailing_comments: Vec::new(),
                                })),
                                left_comments: Vec::new(),
                                operator_comments: Vec::new(),
                                trailing_comments: Vec::new(),
                            }));
                            let right_and = Expression::And(Box::new(BinaryOp {
                                left: Expression::Paren(Box::new(Paren {
                                    this: not_a,
                                    trailing_comments: Vec::new(),
                                })),
                                right: b,
                                left_comments: Vec::new(),
                                operator_comments: Vec::new(),
                                trailing_comments: Vec::new(),
                            }));
                            Expression::Or(Box::new(BinaryOp {
                                left: Expression::Paren(Box::new(Paren {
                                    this: left_and,
                                    trailing_comments: Vec::new(),
                                })),
                                right: Expression::Paren(Box::new(Paren {
                                    this: right_and,
                                    trailing_comments: Vec::new(),
                                })),
                                left_comments: Vec::new(),
                                operator_comments: Vec::new(),
                                trailing_comments: Vec::new(),
                            }))
                        };

                        if operands.len() >= 2 {
                            let mut result = make_xor(operands.remove(0), operands.remove(0));
                            for operand in operands {
                                result = make_xor(result, operand);
                            }
                            Ok(result)
                        } else if operands.len() == 1 {
                            Ok(operands.remove(0))
                        } else {
                            // No operands - return FALSE (shouldn't happen)
                            Ok(Expression::Boolean(crate::expressions::BooleanLiteral {
                                value: false,
                            }))
                        }
                    } else {
                        Ok(e)
                    }
                }
                Action::DatePartUnquote => {
                    // DATE_PART('month', x) -> DATE_PART(month, x) for Snowflake target
                    // Convert the quoted string first arg to a bare Column/Identifier
                    if let Expression::Function(mut f) = e {
                        if let Some(Expression::Literal(crate::expressions::Literal::String(s))) =
                            f.args.first()
                        {
                            let bare_name = s.to_lowercase();
                            f.args[0] = Expression::Column(crate::expressions::Column {
                                name: Identifier::new(bare_name),
                                table: None,
                                join_mark: false,
                                trailing_comments: Vec::new(),
                            });
                        }
                        Ok(Expression::Function(f))
                    } else {
                        Ok(e)
                    }
                }
                Action::ArrayLengthConvert => {
                    // Extract the argument from the expression
                    let arg = match e {
                        Expression::Cardinality(ref f) => f.this.clone(),
                        Expression::ArrayLength(ref f) => f.this.clone(),
                        Expression::ArraySize(ref f) => f.this.clone(),
                        _ => return Ok(e),
                    };
                    match target {
                        DialectType::Spark | DialectType::Databricks | DialectType::Hive => {
                            Ok(Expression::Function(Box::new(Function::new(
                                "SIZE".to_string(),
                                vec![arg],
                            ))))
                        }
                        DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                            Ok(Expression::Cardinality(Box::new(
                                crate::expressions::UnaryFunc::new(arg),
                            )))
                        }
                        DialectType::BigQuery => Ok(Expression::ArrayLength(Box::new(
                            crate::expressions::UnaryFunc::new(arg),
                        ))),
                        DialectType::DuckDB => Ok(Expression::ArrayLength(Box::new(
                            crate::expressions::UnaryFunc::new(arg),
                        ))),
                        DialectType::PostgreSQL | DialectType::Redshift => {
                            // PostgreSQL ARRAY_LENGTH requires dimension arg
                            Ok(Expression::Function(Box::new(Function::new(
                                "ARRAY_LENGTH".to_string(),
                                vec![arg, Expression::number(1)],
                            ))))
                        }
                        DialectType::Snowflake => Ok(Expression::ArraySize(Box::new(
                            crate::expressions::UnaryFunc::new(arg),
                        ))),
                        _ => Ok(e), // Keep original
                    }
                }

                Action::JsonExtractToArrow => {
                    // JSON_EXTRACT(x, path) -> x -> path for SQLite/DuckDB (set arrow_syntax = true)
                    if let Expression::JsonExtract(mut f) = e {
                        f.arrow_syntax = true;
                        // Transform path: convert bracket notation to dot notation
                        // SQLite strips wildcards, DuckDB preserves them
                        if let Expression::Literal(Literal::String(ref s)) = f.path {
                            let mut transformed = s.clone();
                            if matches!(target, DialectType::SQLite) {
                                transformed = Self::strip_json_wildcards(&transformed);
                            }
                            transformed = Self::bracket_to_dot_notation(&transformed);
                            if transformed != *s {
                                f.path = Expression::string(&transformed);
                            }
                        }
                        Ok(Expression::JsonExtract(f))
                    } else {
                        Ok(e)
                    }
                }

                Action::JsonExtractToGetJsonObject => {
                    if let Expression::JsonExtract(f) = e {
                        if matches!(target, DialectType::PostgreSQL | DialectType::Redshift) {
                            // JSON_EXTRACT(x, '$.key') -> JSON_EXTRACT_PATH(x, 'key') for PostgreSQL
                            // Use proper decomposition that handles brackets
                            let keys: Vec<Expression> =
                                if let Expression::Literal(Literal::String(ref s)) = f.path {
                                    let parts = Self::decompose_json_path(s);
                                    parts.into_iter().map(|k| Expression::string(&k)).collect()
                                } else {
                                    vec![f.path]
                                };
                            let func_name = if matches!(target, DialectType::Redshift) {
                                "JSON_EXTRACT_PATH_TEXT"
                            } else {
                                "JSON_EXTRACT_PATH"
                            };
                            let mut args = vec![f.this];
                            args.extend(keys);
                            Ok(Expression::Function(Box::new(Function::new(
                                func_name.to_string(),
                                args,
                            ))))
                        } else {
                            // GET_JSON_OBJECT(x, '$.path') for Hive/Spark
                            // Convert bracket double quotes to single quotes
                            let path = if let Expression::Literal(Literal::String(ref s)) = f.path {
                                let normalized = Self::bracket_to_single_quotes(s);
                                if normalized != *s {
                                    Expression::string(&normalized)
                                } else {
                                    f.path
                                }
                            } else {
                                f.path
                            };
                            Ok(Expression::Function(Box::new(Function::new(
                                "GET_JSON_OBJECT".to_string(),
                                vec![f.this, path],
                            ))))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::JsonExtractScalarToGetJsonObject => {
                    // JSON_EXTRACT_SCALAR(x, '$.path') -> GET_JSON_OBJECT(x, '$.path') for Hive/Spark
                    if let Expression::JsonExtractScalar(f) = e {
                        Ok(Expression::Function(Box::new(Function::new(
                            "GET_JSON_OBJECT".to_string(),
                            vec![f.this, f.path],
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::JsonExtractToTsql => {
                    // JSON_EXTRACT/JSON_EXTRACT_SCALAR -> ISNULL(JSON_QUERY(x, path), JSON_VALUE(x, path)) for TSQL
                    let (this, path) = match e {
                        Expression::JsonExtract(f) => (f.this, f.path),
                        Expression::JsonExtractScalar(f) => (f.this, f.path),
                        _ => return Ok(e),
                    };
                    // Transform path: strip wildcards, convert bracket notation to dot notation
                    let transformed_path = if let Expression::Literal(Literal::String(ref s)) = path
                    {
                        let stripped = Self::strip_json_wildcards(s);
                        let dotted = Self::bracket_to_dot_notation(&stripped);
                        Expression::string(&dotted)
                    } else {
                        path
                    };
                    let json_query = Expression::Function(Box::new(Function::new(
                        "JSON_QUERY".to_string(),
                        vec![this.clone(), transformed_path.clone()],
                    )));
                    let json_value = Expression::Function(Box::new(Function::new(
                        "JSON_VALUE".to_string(),
                        vec![this, transformed_path],
                    )));
                    Ok(Expression::Function(Box::new(Function::new(
                        "ISNULL".to_string(),
                        vec![json_query, json_value],
                    ))))
                }

                Action::JsonExtractToClickHouse => {
                    // JSON_EXTRACT/JSON_EXTRACT_SCALAR -> JSONExtractString(x, 'key1', idx, 'key2') for ClickHouse
                    let (this, path) = match e {
                        Expression::JsonExtract(f) => (f.this, f.path),
                        Expression::JsonExtractScalar(f) => (f.this, f.path),
                        _ => return Ok(e),
                    };
                    let args: Vec<Expression> =
                        if let Expression::Literal(Literal::String(ref s)) = path {
                            let parts = Self::decompose_json_path(s);
                            let mut result = vec![this];
                            for part in parts {
                                // ClickHouse uses 1-based integer indices for array access
                                if let Ok(idx) = part.parse::<i64>() {
                                    result.push(Expression::number(idx + 1));
                                } else {
                                    result.push(Expression::string(&part));
                                }
                            }
                            result
                        } else {
                            vec![this, path]
                        };
                    Ok(Expression::Function(Box::new(Function::new(
                        "JSONExtractString".to_string(),
                        args,
                    ))))
                }

                Action::JsonExtractScalarConvert => {
                    // JSON_EXTRACT_SCALAR -> target-specific
                    if let Expression::JsonExtractScalar(f) = e {
                        match target {
                            DialectType::PostgreSQL | DialectType::Redshift => {
                                // JSON_EXTRACT_SCALAR(x, '$.path') -> JSON_EXTRACT_PATH_TEXT(x, 'key1', 'key2')
                                let keys: Vec<Expression> =
                                    if let Expression::Literal(Literal::String(ref s)) = f.path {
                                        let parts = Self::decompose_json_path(s);
                                        parts.into_iter().map(|k| Expression::string(&k)).collect()
                                    } else {
                                        vec![f.path]
                                    };
                                let mut args = vec![f.this];
                                args.extend(keys);
                                Ok(Expression::Function(Box::new(Function::new(
                                    "JSON_EXTRACT_PATH_TEXT".to_string(),
                                    args,
                                ))))
                            }
                            DialectType::Snowflake => {
                                // JSON_EXTRACT_SCALAR(x, '$.path') -> JSON_EXTRACT_PATH_TEXT(x, 'stripped_path')
                                let stripped_path =
                                    if let Expression::Literal(Literal::String(ref s)) = f.path {
                                        let stripped = Self::strip_json_dollar_prefix(s);
                                        Expression::string(&stripped)
                                    } else {
                                        f.path
                                    };
                                Ok(Expression::Function(Box::new(Function::new(
                                    "JSON_EXTRACT_PATH_TEXT".to_string(),
                                    vec![f.this, stripped_path],
                                ))))
                            }
                            DialectType::SQLite | DialectType::DuckDB => {
                                // JSON_EXTRACT_SCALAR(x, '$.path') -> x ->> '$.path'
                                Ok(Expression::JsonExtractScalar(Box::new(
                                    crate::expressions::JsonExtractFunc {
                                        this: f.this,
                                        path: f.path,
                                        returning: f.returning,
                                        arrow_syntax: true,
                                        hash_arrow_syntax: false,
                                        wrapper_option: None,
                                        quotes_option: None,
                                        on_scalar_string: false,
                                        on_error: None,
                                    },
                                )))
                            }
                            _ => Ok(Expression::JsonExtractScalar(f)),
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::JsonPathNormalize => {
                    // Normalize JSON path format for BigQuery, MySQL, etc.
                    if let Expression::JsonExtract(mut f) = e {
                        if let Expression::Literal(Literal::String(ref s)) = f.path {
                            let mut normalized = s.clone();
                            // Convert bracket notation and handle wildcards per dialect
                            match target {
                                DialectType::BigQuery => {
                                    // BigQuery strips wildcards and uses single quotes in brackets
                                    normalized = Self::strip_json_wildcards(&normalized);
                                    normalized = Self::bracket_to_single_quotes(&normalized);
                                }
                                DialectType::MySQL => {
                                    // MySQL preserves wildcards, converts brackets to dot notation
                                    normalized = Self::bracket_to_dot_notation(&normalized);
                                }
                                _ => {}
                            }
                            if normalized != *s {
                                f.path = Expression::string(&normalized);
                            }
                        }
                        Ok(Expression::JsonExtract(f))
                    } else {
                        Ok(e)
                    }
                }

                Action::JsonQueryValueConvert => {
                    // JsonQuery/JsonValue -> target-specific
                    let (f, is_query) = match e {
                        Expression::JsonQuery(f) => (f, true),
                        Expression::JsonValue(f) => (f, false),
                        _ => return Ok(e),
                    };
                    match target {
                        DialectType::TSQL | DialectType::Fabric => {
                            // ISNULL(JSON_QUERY(...), JSON_VALUE(...))
                            let json_query = Expression::Function(Box::new(Function::new(
                                "JSON_QUERY".to_string(),
                                vec![f.this.clone(), f.path.clone()],
                            )));
                            let json_value = Expression::Function(Box::new(Function::new(
                                "JSON_VALUE".to_string(),
                                vec![f.this, f.path],
                            )));
                            Ok(Expression::Function(Box::new(Function::new(
                                "ISNULL".to_string(),
                                vec![json_query, json_value],
                            ))))
                        }
                        DialectType::Spark | DialectType::Databricks | DialectType::Hive => {
                            Ok(Expression::Function(Box::new(Function::new(
                                "GET_JSON_OBJECT".to_string(),
                                vec![f.this, f.path],
                            ))))
                        }
                        DialectType::PostgreSQL | DialectType::Redshift => {
                            Ok(Expression::Function(Box::new(Function::new(
                                "JSON_EXTRACT_PATH_TEXT".to_string(),
                                vec![f.this, f.path],
                            ))))
                        }
                        DialectType::DuckDB | DialectType::SQLite => {
                            // json -> path arrow syntax
                            Ok(Expression::JsonExtract(Box::new(
                                crate::expressions::JsonExtractFunc {
                                    this: f.this,
                                    path: f.path,
                                    returning: f.returning,
                                    arrow_syntax: true,
                                    hash_arrow_syntax: false,
                                    wrapper_option: f.wrapper_option,
                                    quotes_option: f.quotes_option,
                                    on_scalar_string: f.on_scalar_string,
                                    on_error: f.on_error,
                                },
                            )))
                        }
                        DialectType::Snowflake => {
                            // GET_PATH(PARSE_JSON(json), 'path')
                            // Strip $. prefix from path
                            // Only wrap in PARSE_JSON if not already a PARSE_JSON call or ParseJson expression
                            let json_expr = match &f.this {
                                Expression::Function(ref inner_f)
                                    if inner_f.name.eq_ignore_ascii_case("PARSE_JSON") =>
                                {
                                    f.this
                                }
                                Expression::ParseJson(_) => {
                                    // Already a ParseJson expression, which generates as PARSE_JSON(...)
                                    f.this
                                }
                                _ => Expression::Function(Box::new(Function::new(
                                    "PARSE_JSON".to_string(),
                                    vec![f.this],
                                ))),
                            };
                            let path_str = match &f.path {
                                Expression::Literal(Literal::String(s)) => {
                                    let stripped = s.strip_prefix("$.").unwrap_or(s);
                                    Expression::Literal(Literal::String(stripped.to_string()))
                                }
                                other => other.clone(),
                            };
                            Ok(Expression::Function(Box::new(Function::new(
                                "GET_PATH".to_string(),
                                vec![json_expr, path_str],
                            ))))
                        }
                        _ => {
                            // Default: keep as JSON_QUERY/JSON_VALUE function
                            let func_name = if is_query { "JSON_QUERY" } else { "JSON_VALUE" };
                            Ok(Expression::Function(Box::new(Function::new(
                                func_name.to_string(),
                                vec![f.this, f.path],
                            ))))
                        }
                    }
                }

                Action::JsonLiteralToJsonParse => {
                    // CAST('x' AS JSON) -> JSON_PARSE('x') for Presto, PARSE_JSON for Snowflake
                    if let Expression::Cast(c) = e {
                        let func_name = if matches!(target, DialectType::Snowflake) {
                            "PARSE_JSON"
                        } else {
                            "JSON_PARSE"
                        };
                        Ok(Expression::Function(Box::new(Function::new(
                            func_name.to_string(),
                            vec![c.this],
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::AtTimeZoneConvert => {
                    // AT TIME ZONE -> target-specific conversion
                    if let Expression::AtTimeZone(atz) = e {
                        match target {
                            DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                Ok(Expression::Function(Box::new(Function::new(
                                    "AT_TIMEZONE".to_string(),
                                    vec![atz.this, atz.zone],
                                ))))
                            }
                            DialectType::Spark | DialectType::Databricks => {
                                Ok(Expression::Function(Box::new(Function::new(
                                    "FROM_UTC_TIMESTAMP".to_string(),
                                    vec![atz.this, atz.zone],
                                ))))
                            }
                            DialectType::Snowflake => {
                                // CONVERT_TIMEZONE('zone', expr)
                                Ok(Expression::Function(Box::new(Function::new(
                                    "CONVERT_TIMEZONE".to_string(),
                                    vec![atz.zone, atz.this],
                                ))))
                            }
                            DialectType::BigQuery => {
                                // TIMESTAMP(DATETIME(expr, 'zone'))
                                let datetime_call = Expression::Function(Box::new(Function::new(
                                    "DATETIME".to_string(),
                                    vec![atz.this, atz.zone],
                                )));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "TIMESTAMP".to_string(),
                                    vec![datetime_call],
                                ))))
                            }
                            _ => Ok(Expression::Function(Box::new(Function::new(
                                "AT_TIMEZONE".to_string(),
                                vec![atz.this, atz.zone],
                            )))),
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::DayOfWeekConvert => {
                    // DAY_OF_WEEK -> ISODOW for DuckDB, ((DAYOFWEEK(x) % 7) + 1) for Spark
                    if let Expression::DayOfWeek(f) = e {
                        match target {
                            DialectType::DuckDB => Ok(Expression::Function(Box::new(
                                Function::new("ISODOW".to_string(), vec![f.this]),
                            ))),
                            DialectType::Spark | DialectType::Databricks => {
                                // ((DAYOFWEEK(x) % 7) + 1)
                                let dayofweek = Expression::Function(Box::new(Function::new(
                                    "DAYOFWEEK".to_string(),
                                    vec![f.this],
                                )));
                                let modulo = Expression::Mod(Box::new(BinaryOp {
                                    left: dayofweek,
                                    right: Expression::number(7),
                                    left_comments: Vec::new(),
                                    operator_comments: Vec::new(),
                                    trailing_comments: Vec::new(),
                                }));
                                let paren_mod = Expression::Paren(Box::new(Paren {
                                    this: modulo,
                                    trailing_comments: Vec::new(),
                                }));
                                let add_one = Expression::Add(Box::new(BinaryOp {
                                    left: paren_mod,
                                    right: Expression::number(1),
                                    left_comments: Vec::new(),
                                    operator_comments: Vec::new(),
                                    trailing_comments: Vec::new(),
                                }));
                                Ok(Expression::Paren(Box::new(Paren {
                                    this: add_one,
                                    trailing_comments: Vec::new(),
                                })))
                            }
                            _ => Ok(Expression::DayOfWeek(f)),
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::MaxByMinByConvert => {
                    // MAX_BY -> argMax for ClickHouse, drop 3rd arg for Spark
                    // MIN_BY -> argMin for ClickHouse, ARG_MIN for DuckDB, drop 3rd arg for Spark/ClickHouse
                    // Handle both Expression::Function and Expression::AggregateFunction
                    let (is_max, args) = match &e {
                        Expression::Function(f) => {
                            (f.name.eq_ignore_ascii_case("MAX_BY"), f.args.clone())
                        }
                        Expression::AggregateFunction(af) => {
                            (af.name.eq_ignore_ascii_case("MAX_BY"), af.args.clone())
                        }
                        _ => return Ok(e),
                    };
                    match target {
                        DialectType::ClickHouse => {
                            let name = if is_max { "argMax" } else { "argMin" };
                            let mut args = args;
                            args.truncate(2);
                            Ok(Expression::Function(Box::new(Function::new(
                                name.to_string(),
                                args,
                            ))))
                        }
                        DialectType::DuckDB => {
                            let name = if is_max { "ARG_MAX" } else { "ARG_MIN" };
                            Ok(Expression::Function(Box::new(Function::new(
                                name.to_string(),
                                args,
                            ))))
                        }
                        DialectType::Spark | DialectType::Databricks => {
                            let mut args = args;
                            args.truncate(2);
                            let name = if is_max { "MAX_BY" } else { "MIN_BY" };
                            Ok(Expression::Function(Box::new(Function::new(
                                name.to_string(),
                                args,
                            ))))
                        }
                        _ => Ok(e),
                    }
                }

                Action::ElementAtConvert => {
                    // ELEMENT_AT(arr, idx) -> arr[idx] for PostgreSQL, arr[SAFE_ORDINAL(idx)] for BigQuery
                    let (arr, idx) = if let Expression::ElementAt(bf) = e {
                        (bf.this, bf.expression)
                    } else if let Expression::Function(ref f) = e {
                        if f.args.len() >= 2 {
                            if let Expression::Function(f) = e {
                                let mut args = f.args;
                                let arr = args.remove(0);
                                let idx = args.remove(0);
                                (arr, idx)
                            } else {
                                unreachable!("outer condition already matched Expression::Function")
                            }
                        } else {
                            return Ok(e);
                        }
                    } else {
                        return Ok(e);
                    };
                    match target {
                        DialectType::PostgreSQL => {
                            // Wrap array in parens for PostgreSQL: (ARRAY[1,2,3])[4]
                            let arr_expr = Expression::Paren(Box::new(Paren {
                                this: arr,
                                trailing_comments: vec![],
                            }));
                            Ok(Expression::Subscript(Box::new(
                                crate::expressions::Subscript {
                                    this: arr_expr,
                                    index: idx,
                                },
                            )))
                        }
                        DialectType::BigQuery => {
                            // BigQuery: convert ARRAY[...] to bare [...] for subscript
                            let arr_expr = match arr {
                                Expression::ArrayFunc(af) => Expression::ArrayFunc(Box::new(
                                    crate::expressions::ArrayConstructor {
                                        expressions: af.expressions,
                                        bracket_notation: true,
                                        use_list_keyword: false,
                                    },
                                )),
                                other => other,
                            };
                            let safe_ordinal = Expression::Function(Box::new(Function::new(
                                "SAFE_ORDINAL".to_string(),
                                vec![idx],
                            )));
                            Ok(Expression::Subscript(Box::new(
                                crate::expressions::Subscript {
                                    this: arr_expr,
                                    index: safe_ordinal,
                                },
                            )))
                        }
                        _ => Ok(Expression::Function(Box::new(Function::new(
                            "ELEMENT_AT".to_string(),
                            vec![arr, idx],
                        )))),
                    }
                }

                Action::CurrentUserParens => {
                    // CURRENT_USER -> CURRENT_USER() for Snowflake
                    Ok(Expression::Function(Box::new(Function::new(
                        "CURRENT_USER".to_string(),
                        vec![],
                    ))))
                }

                Action::ArrayAggToCollectList => {
                    // ARRAY_AGG(x ORDER BY ...) -> COLLECT_LIST(x) for Hive/Spark
                    // Python sqlglot Hive.arrayagg_sql strips ORDER BY for simple cases
                    // but preserves it when DISTINCT/IGNORE NULLS/LIMIT are present
                    match e {
                        Expression::AggregateFunction(mut af) => {
                            let is_simple =
                                !af.distinct && af.ignore_nulls.is_none() && af.limit.is_none();
                            let args = if af.args.is_empty() {
                                vec![]
                            } else {
                                vec![af.args[0].clone()]
                            };
                            af.name = "COLLECT_LIST".to_string();
                            af.args = args;
                            if is_simple {
                                af.order_by = Vec::new();
                            }
                            Ok(Expression::AggregateFunction(af))
                        }
                        Expression::ArrayAgg(agg) => {
                            let is_simple =
                                !agg.distinct && agg.ignore_nulls.is_none() && agg.limit.is_none();
                            Ok(Expression::AggregateFunction(Box::new(
                                crate::expressions::AggregateFunction {
                                    name: "COLLECT_LIST".to_string(),
                                    args: vec![agg.this.clone()],
                                    distinct: agg.distinct,
                                    filter: agg.filter.clone(),
                                    order_by: if is_simple {
                                        Vec::new()
                                    } else {
                                        agg.order_by.clone()
                                    },
                                    limit: agg.limit.clone(),
                                    ignore_nulls: agg.ignore_nulls,
                                },
                            )))
                        }
                        _ => Ok(e),
                    }
                }

                Action::ArraySyntaxConvert => {
                    match e {
                        // ARRAY[1, 2] (ArrayFunc bracket_notation=false) -> set bracket_notation=true
                        // so the generator uses dialect-specific output (ARRAY() for Spark, [] for BigQuery)
                        Expression::ArrayFunc(arr) if !arr.bracket_notation => Ok(
                            Expression::ArrayFunc(Box::new(crate::expressions::ArrayConstructor {
                                expressions: arr.expressions,
                                bracket_notation: true,
                                use_list_keyword: false,
                            })),
                        ),
                        // ARRAY(y) function style -> ArrayFunc for target dialect
                        // bracket_notation=true for BigQuery/DuckDB/ClickHouse/StarRocks (output []), false for Presto (output ARRAY[])
                        Expression::Function(f) if f.name.eq_ignore_ascii_case("ARRAY") => {
                            let bracket = matches!(
                                target,
                                DialectType::BigQuery
                                    | DialectType::DuckDB
                                    | DialectType::ClickHouse
                                    | DialectType::StarRocks
                            );
                            Ok(Expression::ArrayFunc(Box::new(
                                crate::expressions::ArrayConstructor {
                                    expressions: f.args,
                                    bracket_notation: bracket,
                                    use_list_keyword: false,
                                },
                            )))
                        }
                        _ => Ok(e),
                    }
                }

                Action::CastToJsonForSpark => {
                    // CAST(x AS JSON) -> TO_JSON(x) for Spark
                    if let Expression::Cast(c) = e {
                        Ok(Expression::Function(Box::new(Function::new(
                            "TO_JSON".to_string(),
                            vec![c.this],
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::CastJsonToFromJson => {
                    // CAST(ParseJson(literal) AS ARRAY/MAP/STRUCT) -> FROM_JSON(literal, type_string) for Spark
                    if let Expression::Cast(c) = e {
                        // Extract the string literal from ParseJson
                        let literal_expr = if let Expression::ParseJson(pj) = c.this {
                            pj.this
                        } else {
                            c.this
                        };
                        // Convert the target DataType to Spark's type string format
                        let type_str = Self::data_type_to_spark_string(&c.to);
                        Ok(Expression::Function(Box::new(Function::new(
                            "FROM_JSON".to_string(),
                            vec![literal_expr, Expression::Literal(Literal::String(type_str))],
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::ToJsonConvert => {
                    // TO_JSON(x) -> target-specific conversion
                    if let Expression::ToJson(f) = e {
                        let arg = f.this;
                        match target {
                            DialectType::Presto | DialectType::Trino => {
                                // JSON_FORMAT(CAST(x AS JSON))
                                let cast_json = Expression::Cast(Box::new(Cast {
                                    this: arg,
                                    to: DataType::Custom {
                                        name: "JSON".to_string(),
                                    },
                                    trailing_comments: vec![],
                                    double_colon_syntax: false,
                                    format: None,
                                    default: None,
                                }));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "JSON_FORMAT".to_string(),
                                    vec![cast_json],
                                ))))
                            }
                            DialectType::BigQuery => Ok(Expression::Function(Box::new(
                                Function::new("TO_JSON_STRING".to_string(), vec![arg]),
                            ))),
                            DialectType::DuckDB => {
                                // CAST(TO_JSON(x) AS TEXT)
                                let to_json =
                                    Expression::ToJson(Box::new(crate::expressions::UnaryFunc {
                                        this: arg,
                                        original_name: None,
                                    }));
                                Ok(Expression::Cast(Box::new(Cast {
                                    this: to_json,
                                    to: DataType::Text,
                                    trailing_comments: vec![],
                                    double_colon_syntax: false,
                                    format: None,
                                    default: None,
                                })))
                            }
                            _ => Ok(Expression::ToJson(Box::new(
                                crate::expressions::UnaryFunc {
                                    this: arg,
                                    original_name: None,
                                },
                            ))),
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::VarianceToClickHouse => {
                    if let Expression::Variance(f) = e {
                        Ok(Expression::Function(Box::new(Function::new(
                            "varSamp".to_string(),
                            vec![f.this],
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::StddevToClickHouse => {
                    if let Expression::Stddev(f) = e {
                        Ok(Expression::Function(Box::new(Function::new(
                            "stddevSamp".to_string(),
                            vec![f.this],
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::ApproxQuantileConvert => {
                    if let Expression::ApproxQuantile(aq) = e {
                        let mut args = vec![*aq.this];
                        if let Some(q) = aq.quantile {
                            args.push(*q);
                        }
                        Ok(Expression::Function(Box::new(Function::new(
                            "APPROX_PERCENTILE".to_string(),
                            args,
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::DollarParamConvert => {
                    if let Expression::Parameter(p) = e {
                        Ok(Expression::Parameter(Box::new(
                            crate::expressions::Parameter {
                                name: p.name,
                                index: p.index,
                                style: crate::expressions::ParameterStyle::At,
                                quoted: p.quoted,
                                string_quoted: p.string_quoted,
                                expression: p.expression,
                            },
                        )))
                    } else {
                        Ok(e)
                    }
                }

                Action::EscapeStringNormalize => {
                    if let Expression::Literal(Literal::EscapeString(s)) = e {
                        // Strip prefix (e.g., "e:" or "E:") if present from tokenizer
                        let stripped = if s.starts_with("e:") || s.starts_with("E:") {
                            s[2..].to_string()
                        } else {
                            s
                        };
                        let normalized = stripped
                            .replace('\n', "\\n")
                            .replace('\r', "\\r")
                            .replace('\t', "\\t");
                        match target {
                            DialectType::BigQuery => {
                                // BigQuery: e'...' -> CAST(b'...' AS STRING)
                                // Use Raw for the b'...' part to avoid double-escaping
                                let raw_sql = format!("CAST(b'{}' AS STRING)", normalized);
                                Ok(Expression::Raw(crate::expressions::Raw { sql: raw_sql }))
                            }
                            _ => Ok(Expression::Literal(Literal::EscapeString(normalized))),
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::StraightJoinCase => {
                    // straight_join: keep lowercase for DuckDB, quote for MySQL
                    if let Expression::Column(col) = e {
                        if col.name.name == "STRAIGHT_JOIN" {
                            let mut new_col = col;
                            new_col.name.name = "straight_join".to_string();
                            if matches!(target, DialectType::MySQL) {
                                // MySQL: needs quoting since it's a reserved keyword
                                new_col.name.quoted = true;
                            }
                            Ok(Expression::Column(new_col))
                        } else {
                            Ok(Expression::Column(col))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::TablesampleReservoir => {
                    // TABLESAMPLE -> TABLESAMPLE RESERVOIR for DuckDB
                    if let Expression::TableSample(mut ts) = e {
                        if let Some(ref mut sample) = ts.sample {
                            sample.method = crate::expressions::SampleMethod::Reservoir;
                            sample.explicit_method = true;
                        }
                        Ok(Expression::TableSample(ts))
                    } else {
                        Ok(e)
                    }
                }

                Action::TablesampleSnowflakeStrip => {
                    // Strip method and PERCENT for Snowflake target from non-Snowflake source
                    match e {
                        Expression::TableSample(mut ts) => {
                            if let Some(ref mut sample) = ts.sample {
                                sample.suppress_method_output = true;
                                sample.unit_after_size = false;
                                sample.is_percent = false;
                            }
                            Ok(Expression::TableSample(ts))
                        }
                        Expression::Table(mut t) => {
                            if let Some(ref mut sample) = t.table_sample {
                                sample.suppress_method_output = true;
                                sample.unit_after_size = false;
                                sample.is_percent = false;
                            }
                            Ok(Expression::Table(t))
                        }
                        _ => Ok(e),
                    }
                }

                Action::FirstToAnyValue => {
                    // FIRST(col) IGNORE NULLS -> ANY_VALUE(col) for DuckDB
                    if let Expression::First(mut agg) = e {
                        agg.ignore_nulls = None;
                        agg.name = Some("ANY_VALUE".to_string());
                        Ok(Expression::AnyValue(agg))
                    } else {
                        Ok(e)
                    }
                }

                Action::ArrayIndexConvert => {
                    // Subscript index: 1-based to 0-based for BigQuery
                    if let Expression::Subscript(mut sub) = e {
                        if let Expression::Literal(Literal::Number(ref n)) = sub.index {
                            if let Ok(val) = n.parse::<i64>() {
                                sub.index =
                                    Expression::Literal(Literal::Number((val - 1).to_string()));
                            }
                        }
                        Ok(Expression::Subscript(sub))
                    } else {
                        Ok(e)
                    }
                }

                Action::AnyValueIgnoreNulls => {
                    // ANY_VALUE(x) -> ANY_VALUE(x) IGNORE NULLS for Spark
                    if let Expression::AnyValue(mut av) = e {
                        if av.ignore_nulls.is_none() {
                            av.ignore_nulls = Some(true);
                        }
                        Ok(Expression::AnyValue(av))
                    } else {
                        Ok(e)
                    }
                }

                Action::BigQueryNullsOrdering => {
                    // BigQuery doesn't support NULLS FIRST/LAST in window function ORDER BY
                    if let Expression::WindowFunction(mut wf) = e {
                        for o in &mut wf.over.order_by {
                            o.nulls_first = None;
                        }
                        Ok(Expression::WindowFunction(wf))
                    } else if let Expression::Ordered(mut o) = e {
                        o.nulls_first = None;
                        Ok(Expression::Ordered(o))
                    } else {
                        Ok(e)
                    }
                }

                Action::SnowflakeFloatProtect => {
                    // Convert DataType::Float to DataType::Custom("FLOAT") to prevent
                    // Snowflake's target transform from converting it to DOUBLE.
                    // Non-Snowflake sources should keep their FLOAT spelling.
                    if let Expression::DataType(DataType::Float { .. }) = e {
                        Ok(Expression::DataType(DataType::Custom {
                            name: "FLOAT".to_string(),
                        }))
                    } else {
                        Ok(e)
                    }
                }

                Action::MysqlNullsOrdering => {
                    // MySQL doesn't support NULLS FIRST/LAST - strip or rewrite
                    if let Expression::Ordered(mut o) = e {
                        let nulls_last = o.nulls_first == Some(false);
                        let desc = o.desc;
                        // MySQL default: ASC -> NULLS LAST, DESC -> NULLS FIRST
                        // If requested ordering matches default, just strip NULLS clause
                        let matches_default = if desc {
                            // DESC default is NULLS FIRST, so nulls_first=true matches
                            o.nulls_first == Some(true)
                        } else {
                            // ASC default is NULLS LAST, so nulls_first=false matches
                            nulls_last
                        };
                        if matches_default {
                            o.nulls_first = None;
                            Ok(Expression::Ordered(o))
                        } else {
                            // Need CASE WHEN x IS NULL THEN 0/1 ELSE 0/1 END, x
                            // For ASC NULLS FIRST: ORDER BY CASE WHEN x IS NULL THEN 0 ELSE 1 END, x ASC
                            // For DESC NULLS LAST: ORDER BY CASE WHEN x IS NULL THEN 1 ELSE 0 END, x DESC
                            let null_val = if desc { 1 } else { 0 };
                            let non_null_val = if desc { 0 } else { 1 };
                            let _case_expr = Expression::Case(Box::new(Case {
                                operand: None,
                                whens: vec![(
                                    Expression::IsNull(Box::new(crate::expressions::IsNull {
                                        this: o.this.clone(),
                                        not: false,
                                        postfix_form: false,
                                    })),
                                    Expression::number(null_val),
                                )],
                                else_: Some(Expression::number(non_null_val)),
                                comments: Vec::new(),
                            }));
                            o.nulls_first = None;
                            // Return a tuple of [case_expr, ordered_expr]
                            // We need to return both as part of the ORDER BY
                            // But since transform_recursive processes individual expressions,
                            // we can't easily add extra ORDER BY items here.
                            // Instead, strip the nulls_first
                            o.nulls_first = None;
                            Ok(Expression::Ordered(o))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::MysqlNullsLastRewrite => {
                    // DuckDB -> MySQL: Add CASE WHEN IS NULL THEN 1 ELSE 0 END to ORDER BY
                    // to simulate NULLS LAST for ASC ordering
                    if let Expression::WindowFunction(mut wf) = e {
                        let mut new_order_by = Vec::new();
                        for o in wf.over.order_by {
                            if !o.desc {
                                // ASC: DuckDB has NULLS LAST, MySQL has NULLS FIRST
                                // Add CASE WHEN expr IS NULL THEN 1 ELSE 0 END before expr
                                let case_expr = Expression::Case(Box::new(Case {
                                    operand: None,
                                    whens: vec![(
                                        Expression::IsNull(Box::new(crate::expressions::IsNull {
                                            this: o.this.clone(),
                                            not: false,
                                            postfix_form: false,
                                        })),
                                        Expression::Literal(Literal::Number("1".to_string())),
                                    )],
                                    else_: Some(Expression::Literal(Literal::Number(
                                        "0".to_string(),
                                    ))),
                                    comments: Vec::new(),
                                }));
                                new_order_by.push(crate::expressions::Ordered {
                                    this: case_expr,
                                    desc: false,
                                    nulls_first: None,
                                    explicit_asc: false,
                                    with_fill: None,
                                });
                                let mut ordered = o;
                                ordered.nulls_first = None;
                                new_order_by.push(ordered);
                            } else {
                                // DESC: DuckDB has NULLS LAST, MySQL also has NULLS LAST (NULLs smallest in DESC)
                                // No change needed
                                let mut ordered = o;
                                ordered.nulls_first = None;
                                new_order_by.push(ordered);
                            }
                        }
                        wf.over.order_by = new_order_by;
                        Ok(Expression::WindowFunction(wf))
                    } else {
                        Ok(e)
                    }
                }

                Action::RespectNullsConvert => {
                    // RESPECT NULLS -> strip for SQLite (FIRST_VALUE(c) OVER (...))
                    if let Expression::WindowFunction(mut wf) = e {
                        match &mut wf.this {
                            Expression::FirstValue(ref mut vf) => {
                                if vf.ignore_nulls == Some(false) {
                                    vf.ignore_nulls = None;
                                    // For SQLite, we'd need to add NULLS LAST to ORDER BY in the OVER clause
                                    // but that's handled by the generator's NULLS ordering
                                }
                            }
                            Expression::LastValue(ref mut vf) => {
                                if vf.ignore_nulls == Some(false) {
                                    vf.ignore_nulls = None;
                                }
                            }
                            _ => {}
                        }
                        Ok(Expression::WindowFunction(wf))
                    } else {
                        Ok(e)
                    }
                }

                Action::CreateTableStripComment => {
                    // Strip COMMENT column constraint, USING, PARTITIONED BY for DuckDB
                    if let Expression::CreateTable(mut ct) = e {
                        for col in &mut ct.columns {
                            col.comment = None;
                            col.constraints.retain(|c| {
                                !matches!(c, crate::expressions::ColumnConstraint::Comment(_))
                            });
                            // Also remove Comment from constraint_order
                            col.constraint_order.retain(|c| {
                                !matches!(c, crate::expressions::ConstraintType::Comment)
                            });
                        }
                        // Strip properties (USING, PARTITIONED BY, etc.)
                        ct.properties.clear();
                        Ok(Expression::CreateTable(ct))
                    } else {
                        Ok(e)
                    }
                }

                Action::AlterTableToSpRename => {
                    // ALTER TABLE db.t1 RENAME TO db.t2 -> EXEC sp_rename 'db.t1', 't2'
                    if let Expression::AlterTable(ref at) = e {
                        if let Some(crate::expressions::AlterTableAction::RenameTable(
                            ref new_tbl,
                        )) = at.actions.first()
                        {
                            // Build the old table name using TSQL bracket quoting
                            let old_name = if let Some(ref schema) = at.name.schema {
                                if at.name.name.quoted || schema.quoted {
                                    format!("[{}].[{}]", schema.name, at.name.name.name)
                                } else {
                                    format!("{}.{}", schema.name, at.name.name.name)
                                }
                            } else {
                                if at.name.name.quoted {
                                    format!("[{}]", at.name.name.name)
                                } else {
                                    at.name.name.name.clone()
                                }
                            };
                            let new_name = new_tbl.name.name.clone();
                            // EXEC sp_rename 'old_name', 'new_name'
                            let sql = format!("EXEC sp_rename '{}', '{}'", old_name, new_name);
                            Ok(Expression::Raw(crate::expressions::Raw { sql }))
                        } else {
                            Ok(e)
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::SnowflakeIntervalFormat => {
                    // INTERVAL '2' HOUR -> INTERVAL '2 HOUR' for Snowflake
                    if let Expression::Interval(mut iv) = e {
                        if let (
                            Some(Expression::Literal(Literal::String(ref val))),
                            Some(ref unit_spec),
                        ) = (&iv.this, &iv.unit)
                        {
                            let unit_str = match unit_spec {
                                crate::expressions::IntervalUnitSpec::Simple { unit, .. } => {
                                    match unit {
                                        crate::expressions::IntervalUnit::Year => "YEAR",
                                        crate::expressions::IntervalUnit::Quarter => "QUARTER",
                                        crate::expressions::IntervalUnit::Month => "MONTH",
                                        crate::expressions::IntervalUnit::Week => "WEEK",
                                        crate::expressions::IntervalUnit::Day => "DAY",
                                        crate::expressions::IntervalUnit::Hour => "HOUR",
                                        crate::expressions::IntervalUnit::Minute => "MINUTE",
                                        crate::expressions::IntervalUnit::Second => "SECOND",
                                        crate::expressions::IntervalUnit::Millisecond => {
                                            "MILLISECOND"
                                        }
                                        crate::expressions::IntervalUnit::Microsecond => {
                                            "MICROSECOND"
                                        }
                                        crate::expressions::IntervalUnit::Nanosecond => {
                                            "NANOSECOND"
                                        }
                                    }
                                }
                                _ => "",
                            };
                            if !unit_str.is_empty() {
                                let combined = format!("{} {}", val, unit_str);
                                iv.this = Some(Expression::Literal(Literal::String(combined)));
                                iv.unit = None;
                            }
                        }
                        Ok(Expression::Interval(iv))
                    } else {
                        Ok(e)
                    }
                }

                Action::ArrayConcatBracketConvert => {
                    // Expression::Array/ArrayFunc -> target-specific
                    // For PostgreSQL: Array -> ArrayFunc (bracket_notation: false)
                    // For Redshift: Array/ArrayFunc -> Function("ARRAY", args) to produce ARRAY(1, 2) with parens
                    match e {
                        Expression::Array(arr) => {
                            if matches!(target, DialectType::Redshift) {
                                Ok(Expression::Function(Box::new(Function::new(
                                    "ARRAY".to_string(),
                                    arr.expressions,
                                ))))
                            } else {
                                Ok(Expression::ArrayFunc(Box::new(
                                    crate::expressions::ArrayConstructor {
                                        expressions: arr.expressions,
                                        bracket_notation: false,
                                        use_list_keyword: false,
                                    },
                                )))
                            }
                        }
                        Expression::ArrayFunc(arr) => {
                            // Only for Redshift: convert bracket-notation ArrayFunc to Function("ARRAY")
                            if matches!(target, DialectType::Redshift) {
                                Ok(Expression::Function(Box::new(Function::new(
                                    "ARRAY".to_string(),
                                    arr.expressions,
                                ))))
                            } else {
                                Ok(Expression::ArrayFunc(arr))
                            }
                        }
                        _ => Ok(e),
                    }
                }

                Action::BitAggFloatCast => {
                    // BIT_OR/BIT_AND/BIT_XOR with float/decimal cast arg -> wrap with ROUND+INT cast for DuckDB
                    // For FLOAT/DOUBLE/REAL: CAST(ROUND(CAST(val AS type)) AS INT)
                    // For DECIMAL: CAST(CAST(val AS DECIMAL(p,s)) AS INT)
                    let int_type = DataType::Int {
                        length: None,
                        integer_spelling: false,
                    };
                    let wrap_agg = |agg_this: Expression, int_dt: DataType| -> Expression {
                        if let Expression::Cast(c) = agg_this {
                            match &c.to {
                                DataType::Float { .. }
                                | DataType::Double { .. }
                                | DataType::Custom { .. } => {
                                    // FLOAT/DOUBLE/REAL: CAST(ROUND(CAST(val AS type)) AS INT)
                                    // Change FLOAT to REAL (Float with real_spelling=true) for DuckDB generator
                                    let inner_type = match &c.to {
                                        DataType::Float {
                                            precision, scale, ..
                                        } => DataType::Float {
                                            precision: *precision,
                                            scale: *scale,
                                            real_spelling: true,
                                        },
                                        other => other.clone(),
                                    };
                                    let inner_cast =
                                        Expression::Cast(Box::new(crate::expressions::Cast {
                                            this: c.this.clone(),
                                            to: inner_type,
                                            trailing_comments: Vec::new(),
                                            double_colon_syntax: false,
                                            format: None,
                                            default: None,
                                        }));
                                    let rounded = Expression::Function(Box::new(Function::new(
                                        "ROUND".to_string(),
                                        vec![inner_cast],
                                    )));
                                    Expression::Cast(Box::new(crate::expressions::Cast {
                                        this: rounded,
                                        to: int_dt,
                                        trailing_comments: Vec::new(),
                                        double_colon_syntax: false,
                                        format: None,
                                        default: None,
                                    }))
                                }
                                DataType::Decimal { .. } => {
                                    // DECIMAL: CAST(CAST(val AS DECIMAL(p,s)) AS INT)
                                    Expression::Cast(Box::new(crate::expressions::Cast {
                                        this: Expression::Cast(c),
                                        to: int_dt,
                                        trailing_comments: Vec::new(),
                                        double_colon_syntax: false,
                                        format: None,
                                        default: None,
                                    }))
                                }
                                _ => Expression::Cast(c),
                            }
                        } else {
                            agg_this
                        }
                    };
                    match e {
                        Expression::BitwiseOrAgg(mut f) => {
                            f.this = wrap_agg(f.this, int_type);
                            Ok(Expression::BitwiseOrAgg(f))
                        }
                        Expression::BitwiseAndAgg(mut f) => {
                            let int_type = DataType::Int {
                                length: None,
                                integer_spelling: false,
                            };
                            f.this = wrap_agg(f.this, int_type);
                            Ok(Expression::BitwiseAndAgg(f))
                        }
                        Expression::BitwiseXorAgg(mut f) => {
                            let int_type = DataType::Int {
                                length: None,
                                integer_spelling: false,
                            };
                            f.this = wrap_agg(f.this, int_type);
                            Ok(Expression::BitwiseXorAgg(f))
                        }
                        _ => Ok(e),
                    }
                }

                Action::BitAggSnowflakeRename => {
                    // BIT_OR -> BITORAGG, BIT_AND -> BITANDAGG, BIT_XOR -> BITXORAGG for Snowflake
                    match e {
                        Expression::BitwiseOrAgg(f) => Ok(Expression::Function(Box::new(
                            Function::new("BITORAGG".to_string(), vec![f.this]),
                        ))),
                        Expression::BitwiseAndAgg(f) => Ok(Expression::Function(Box::new(
                            Function::new("BITANDAGG".to_string(), vec![f.this]),
                        ))),
                        Expression::BitwiseXorAgg(f) => Ok(Expression::Function(Box::new(
                            Function::new("BITXORAGG".to_string(), vec![f.this]),
                        ))),
                        _ => Ok(e),
                    }
                }

                Action::StrftimeCastTimestamp => {
                    // CAST(x AS TIMESTAMP) -> CAST(x AS TIMESTAMP_NTZ) for Spark
                    if let Expression::Cast(mut c) = e {
                        if matches!(
                            c.to,
                            DataType::Timestamp {
                                timezone: false,
                                ..
                            }
                        ) {
                            c.to = DataType::Custom {
                                name: "TIMESTAMP_NTZ".to_string(),
                            };
                        }
                        Ok(Expression::Cast(c))
                    } else {
                        Ok(e)
                    }
                }

                Action::DecimalDefaultPrecision => {
                    // DECIMAL without precision -> DECIMAL(18, 3) for Snowflake
                    if let Expression::Cast(mut c) = e {
                        if matches!(
                            c.to,
                            DataType::Decimal {
                                precision: None,
                                ..
                            }
                        ) {
                            c.to = DataType::Decimal {
                                precision: Some(18),
                                scale: Some(3),
                            };
                        }
                        Ok(Expression::Cast(c))
                    } else {
                        Ok(e)
                    }
                }

                Action::FilterToIff => {
                    // FILTER(WHERE cond) -> rewrite aggregate: AGG(IFF(cond, val, NULL))
                    if let Expression::Filter(f) = e {
                        let condition = *f.expression;
                        let agg = *f.this;
                        // Strip WHERE from condition
                        let cond = match condition {
                            Expression::Where(w) => w.this,
                            other => other,
                        };
                        // Extract the aggregate function and its argument
                        // We want AVG(IFF(condition, x, NULL))
                        match agg {
                            Expression::Function(mut func) => {
                                if !func.args.is_empty() {
                                    let orig_arg = func.args[0].clone();
                                    let iff_call = Expression::Function(Box::new(Function::new(
                                        "IFF".to_string(),
                                        vec![cond, orig_arg, Expression::Null(Null)],
                                    )));
                                    func.args[0] = iff_call;
                                    Ok(Expression::Function(func))
                                } else {
                                    Ok(Expression::Filter(Box::new(crate::expressions::Filter {
                                        this: Box::new(Expression::Function(func)),
                                        expression: Box::new(cond),
                                    })))
                                }
                            }
                            Expression::Avg(mut avg) => {
                                let iff_call = Expression::Function(Box::new(Function::new(
                                    "IFF".to_string(),
                                    vec![cond, avg.this.clone(), Expression::Null(Null)],
                                )));
                                avg.this = iff_call;
                                Ok(Expression::Avg(avg))
                            }
                            Expression::Sum(mut s) => {
                                let iff_call = Expression::Function(Box::new(Function::new(
                                    "IFF".to_string(),
                                    vec![cond, s.this.clone(), Expression::Null(Null)],
                                )));
                                s.this = iff_call;
                                Ok(Expression::Sum(s))
                            }
                            Expression::Count(mut c) => {
                                if let Some(ref this_expr) = c.this {
                                    let iff_call = Expression::Function(Box::new(Function::new(
                                        "IFF".to_string(),
                                        vec![cond, this_expr.clone(), Expression::Null(Null)],
                                    )));
                                    c.this = Some(iff_call);
                                }
                                Ok(Expression::Count(c))
                            }
                            other => {
                                // Fallback: keep as Filter
                                Ok(Expression::Filter(Box::new(crate::expressions::Filter {
                                    this: Box::new(other),
                                    expression: Box::new(cond),
                                })))
                            }
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::AggFilterToIff => {
                    // AggFunc.filter -> IFF wrapping: AVG(x) FILTER(WHERE cond) -> AVG(IFF(cond, x, NULL))
                    // Helper macro to handle the common AggFunc case
                    macro_rules! handle_agg_filter_to_iff {
                        ($variant:ident, $agg:expr) => {{
                            let mut agg = $agg;
                            if let Some(filter_cond) = agg.filter.take() {
                                let iff_call = Expression::Function(Box::new(Function::new(
                                    "IFF".to_string(),
                                    vec![filter_cond, agg.this.clone(), Expression::Null(Null)],
                                )));
                                agg.this = iff_call;
                            }
                            Ok(Expression::$variant(agg))
                        }};
                    }

                    match e {
                        Expression::Avg(agg) => handle_agg_filter_to_iff!(Avg, agg),
                        Expression::Sum(agg) => handle_agg_filter_to_iff!(Sum, agg),
                        Expression::Min(agg) => handle_agg_filter_to_iff!(Min, agg),
                        Expression::Max(agg) => handle_agg_filter_to_iff!(Max, agg),
                        Expression::ArrayAgg(agg) => handle_agg_filter_to_iff!(ArrayAgg, agg),
                        Expression::CountIf(agg) => handle_agg_filter_to_iff!(CountIf, agg),
                        Expression::Stddev(agg) => handle_agg_filter_to_iff!(Stddev, agg),
                        Expression::StddevPop(agg) => handle_agg_filter_to_iff!(StddevPop, agg),
                        Expression::StddevSamp(agg) => handle_agg_filter_to_iff!(StddevSamp, agg),
                        Expression::Variance(agg) => handle_agg_filter_to_iff!(Variance, agg),
                        Expression::VarPop(agg) => handle_agg_filter_to_iff!(VarPop, agg),
                        Expression::VarSamp(agg) => handle_agg_filter_to_iff!(VarSamp, agg),
                        Expression::Median(agg) => handle_agg_filter_to_iff!(Median, agg),
                        Expression::Mode(agg) => handle_agg_filter_to_iff!(Mode, agg),
                        Expression::First(agg) => handle_agg_filter_to_iff!(First, agg),
                        Expression::Last(agg) => handle_agg_filter_to_iff!(Last, agg),
                        Expression::AnyValue(agg) => handle_agg_filter_to_iff!(AnyValue, agg),
                        Expression::ApproxDistinct(agg) => {
                            handle_agg_filter_to_iff!(ApproxDistinct, agg)
                        }
                        Expression::Count(mut c) => {
                            if let Some(filter_cond) = c.filter.take() {
                                if let Some(ref this_expr) = c.this {
                                    let iff_call = Expression::Function(Box::new(Function::new(
                                        "IFF".to_string(),
                                        vec![
                                            filter_cond,
                                            this_expr.clone(),
                                            Expression::Null(Null),
                                        ],
                                    )));
                                    c.this = Some(iff_call);
                                }
                            }
                            Ok(Expression::Count(c))
                        }
                        other => Ok(other),
                    }
                }

                Action::JsonToGetPath => {
                    // JSON_EXTRACT(x, '$.key') -> GET_PATH(PARSE_JSON(x), 'key')
                    if let Expression::JsonExtract(je) = e {
                        // Convert to PARSE_JSON() wrapper:
                        // - JSON(x) -> PARSE_JSON(x)
                        // - PARSE_JSON(x) -> keep as-is
                        // - anything else -> wrap in PARSE_JSON()
                        let this = match &je.this {
                            Expression::Function(f)
                                if f.name.eq_ignore_ascii_case("JSON") && f.args.len() == 1 =>
                            {
                                Expression::Function(Box::new(Function::new(
                                    "PARSE_JSON".to_string(),
                                    f.args.clone(),
                                )))
                            }
                            Expression::Function(f)
                                if f.name.eq_ignore_ascii_case("PARSE_JSON") =>
                            {
                                je.this.clone()
                            }
                            // GET_PATH result is already JSON, don't wrap
                            Expression::Function(f) if f.name.eq_ignore_ascii_case("GET_PATH") => {
                                je.this.clone()
                            }
                            other => {
                                // Wrap non-JSON expressions in PARSE_JSON()
                                Expression::Function(Box::new(Function::new(
                                    "PARSE_JSON".to_string(),
                                    vec![other.clone()],
                                )))
                            }
                        };
                        // Convert path: extract key from JSONPath or strip $. prefix from string
                        let path = match &je.path {
                            Expression::JSONPath(jp) => {
                                // Extract the key from JSONPath: $root.key -> 'key'
                                let mut key_parts = Vec::new();
                                for expr in &jp.expressions {
                                    match expr {
                                        Expression::JSONPathRoot(_) => {} // skip root
                                        Expression::JSONPathKey(k) => {
                                            if let Expression::Literal(Literal::String(s)) =
                                                &*k.this
                                            {
                                                key_parts.push(s.clone());
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                if !key_parts.is_empty() {
                                    Expression::Literal(Literal::String(key_parts.join(".")))
                                } else {
                                    je.path.clone()
                                }
                            }
                            Expression::Literal(Literal::String(s)) if s.starts_with("$.") => {
                                let stripped = Self::strip_json_wildcards(&s[2..].to_string());
                                Expression::Literal(Literal::String(stripped))
                            }
                            Expression::Literal(Literal::String(s)) if s.starts_with('$') => {
                                let stripped = Self::strip_json_wildcards(&s[1..].to_string());
                                Expression::Literal(Literal::String(stripped))
                            }
                            _ => je.path.clone(),
                        };
                        Ok(Expression::Function(Box::new(Function::new(
                            "GET_PATH".to_string(),
                            vec![this, path],
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::StructToRow => {
                    // DuckDB struct/dict -> BigQuery STRUCT(value AS key, ...) / Presto ROW
                    // Handles both Expression::Struct and Expression::MapFunc(curly_brace_syntax=true)

                    // Extract key-value pairs from either Struct or MapFunc
                    let kv_pairs: Option<Vec<(String, Expression)>> = match &e {
                        Expression::Struct(s) => Some(
                            s.fields
                                .iter()
                                .map(|(opt_name, field_expr)| {
                                    if let Some(name) = opt_name {
                                        (name.clone(), field_expr.clone())
                                    } else if let Expression::NamedArgument(na) = field_expr {
                                        (na.name.name.clone(), na.value.clone())
                                    } else {
                                        (String::new(), field_expr.clone())
                                    }
                                })
                                .collect(),
                        ),
                        Expression::MapFunc(m) if m.curly_brace_syntax => Some(
                            m.keys
                                .iter()
                                .zip(m.values.iter())
                                .map(|(key, value)| {
                                    let key_name = match key {
                                        Expression::Literal(Literal::String(s)) => s.clone(),
                                        Expression::Identifier(id) => id.name.clone(),
                                        _ => String::new(),
                                    };
                                    (key_name, value.clone())
                                })
                                .collect(),
                        ),
                        _ => None,
                    };

                    if let Some(pairs) = kv_pairs {
                        let mut named_args = Vec::new();
                        for (key_name, value) in pairs {
                            if matches!(target, DialectType::BigQuery) && !key_name.is_empty() {
                                named_args.push(Expression::Alias(Box::new(
                                    crate::expressions::Alias::new(
                                        value,
                                        Identifier::new(key_name),
                                    ),
                                )));
                            } else if matches!(target, DialectType::Presto | DialectType::Trino) {
                                named_args.push(value);
                            } else {
                                named_args.push(value);
                            }
                        }

                        if matches!(target, DialectType::BigQuery) {
                            Ok(Expression::Function(Box::new(Function::new(
                                "STRUCT".to_string(),
                                named_args,
                            ))))
                        } else if matches!(target, DialectType::Presto | DialectType::Trino) {
                            // For Presto/Trino, infer types and wrap in CAST(ROW(...) AS ROW(name TYPE, ...))
                            let row_func = Expression::Function(Box::new(Function::new(
                                "ROW".to_string(),
                                named_args,
                            )));

                            // Try to infer types for each pair
                            let kv_pairs_again: Option<Vec<(String, Expression)>> = match &e {
                                Expression::Struct(s) => Some(
                                    s.fields
                                        .iter()
                                        .map(|(opt_name, field_expr)| {
                                            if let Some(name) = opt_name {
                                                (name.clone(), field_expr.clone())
                                            } else if let Expression::NamedArgument(na) = field_expr
                                            {
                                                (na.name.name.clone(), na.value.clone())
                                            } else {
                                                (String::new(), field_expr.clone())
                                            }
                                        })
                                        .collect(),
                                ),
                                Expression::MapFunc(m) if m.curly_brace_syntax => Some(
                                    m.keys
                                        .iter()
                                        .zip(m.values.iter())
                                        .map(|(key, value)| {
                                            let key_name = match key {
                                                Expression::Literal(Literal::String(s)) => {
                                                    s.clone()
                                                }
                                                Expression::Identifier(id) => id.name.clone(),
                                                _ => String::new(),
                                            };
                                            (key_name, value.clone())
                                        })
                                        .collect(),
                                ),
                                _ => None,
                            };

                            if let Some(pairs) = kv_pairs_again {
                                // Infer types for all values
                                let mut all_inferred = true;
                                let mut fields = Vec::new();
                                for (name, value) in &pairs {
                                    let inferred_type = match value {
                                        Expression::Literal(Literal::Number(n)) => {
                                            if n.contains('.') {
                                                Some(DataType::Double {
                                                    precision: None,
                                                    scale: None,
                                                })
                                            } else {
                                                Some(DataType::Int {
                                                    length: None,
                                                    integer_spelling: true,
                                                })
                                            }
                                        }
                                        Expression::Literal(Literal::String(_)) => {
                                            Some(DataType::VarChar {
                                                length: None,
                                                parenthesized_length: false,
                                            })
                                        }
                                        Expression::Boolean(_) => Some(DataType::Boolean),
                                        _ => None,
                                    };
                                    if let Some(dt) = inferred_type {
                                        fields.push(crate::expressions::StructField::new(
                                            name.clone(),
                                            dt,
                                        ));
                                    } else {
                                        all_inferred = false;
                                        break;
                                    }
                                }

                                if all_inferred && !fields.is_empty() {
                                    let row_type = DataType::Struct {
                                        fields,
                                        nested: true,
                                    };
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this: row_func,
                                        to: row_type,
                                        trailing_comments: Vec::new(),
                                        double_colon_syntax: false,
                                        format: None,
                                        default: None,
                                    })))
                                } else {
                                    Ok(row_func)
                                }
                            } else {
                                Ok(row_func)
                            }
                        } else {
                            Ok(Expression::Function(Box::new(Function::new(
                                "ROW".to_string(),
                                named_args,
                            ))))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::SparkStructConvert => {
                    // Spark STRUCT(val AS name, ...) -> Presto CAST(ROW(...) AS ROW(name TYPE, ...))
                    // or DuckDB {'name': val, ...}
                    if let Expression::Function(f) = e {
                        // Extract name-value pairs from aliased args
                        let mut pairs: Vec<(String, Expression)> = Vec::new();
                        for arg in &f.args {
                            match arg {
                                Expression::Alias(a) => {
                                    pairs.push((a.alias.name.clone(), a.this.clone()));
                                }
                                _ => {
                                    pairs.push((String::new(), arg.clone()));
                                }
                            }
                        }

                        match target {
                            DialectType::DuckDB => {
                                // Convert to DuckDB struct literal {'name': value, ...}
                                let mut keys = Vec::new();
                                let mut values = Vec::new();
                                for (name, value) in &pairs {
                                    keys.push(Expression::Literal(Literal::String(name.clone())));
                                    values.push(value.clone());
                                }
                                Ok(Expression::MapFunc(Box::new(
                                    crate::expressions::MapConstructor {
                                        keys,
                                        values,
                                        curly_brace_syntax: true,
                                        with_map_keyword: false,
                                    },
                                )))
                            }
                            DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                // Convert to CAST(ROW(val1, val2) AS ROW(name1 TYPE1, name2 TYPE2))
                                let row_args: Vec<Expression> =
                                    pairs.iter().map(|(_, v)| v.clone()).collect();
                                let row_func = Expression::Function(Box::new(Function::new(
                                    "ROW".to_string(),
                                    row_args,
                                )));

                                // Infer types
                                let mut all_inferred = true;
                                let mut fields = Vec::new();
                                for (name, value) in &pairs {
                                    let inferred_type = match value {
                                        Expression::Literal(Literal::Number(n)) => {
                                            if n.contains('.') {
                                                Some(DataType::Double {
                                                    precision: None,
                                                    scale: None,
                                                })
                                            } else {
                                                Some(DataType::Int {
                                                    length: None,
                                                    integer_spelling: true,
                                                })
                                            }
                                        }
                                        Expression::Literal(Literal::String(_)) => {
                                            Some(DataType::VarChar {
                                                length: None,
                                                parenthesized_length: false,
                                            })
                                        }
                                        Expression::Boolean(_) => Some(DataType::Boolean),
                                        _ => None,
                                    };
                                    if let Some(dt) = inferred_type {
                                        fields.push(crate::expressions::StructField::new(
                                            name.clone(),
                                            dt,
                                        ));
                                    } else {
                                        all_inferred = false;
                                        break;
                                    }
                                }

                                if all_inferred && !fields.is_empty() {
                                    let row_type = DataType::Struct {
                                        fields,
                                        nested: true,
                                    };
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this: row_func,
                                        to: row_type,
                                        trailing_comments: Vec::new(),
                                        double_colon_syntax: false,
                                        format: None,
                                        default: None,
                                    })))
                                } else {
                                    Ok(row_func)
                                }
                            }
                            _ => Ok(Expression::Function(f)),
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::ApproxCountDistinctToApproxDistinct => {
                    // APPROX_COUNT_DISTINCT(x) -> APPROX_DISTINCT(x)
                    if let Expression::ApproxCountDistinct(f) = e {
                        Ok(Expression::ApproxDistinct(f))
                    } else {
                        Ok(e)
                    }
                }

                Action::CollectListToArrayAgg => {
                    // COLLECT_LIST(x) -> ARRAY_AGG(x) FILTER(WHERE x IS NOT NULL)
                    if let Expression::AggregateFunction(f) = e {
                        let filter_expr = if !f.args.is_empty() {
                            let arg = f.args[0].clone();
                            Some(Expression::IsNull(Box::new(crate::expressions::IsNull {
                                this: arg,
                                not: true,
                                postfix_form: false,
                            })))
                        } else {
                            None
                        };
                        let agg = crate::expressions::AggFunc {
                            this: if f.args.is_empty() {
                                Expression::Null(crate::expressions::Null)
                            } else {
                                f.args[0].clone()
                            },
                            distinct: f.distinct,
                            order_by: f.order_by.clone(),
                            filter: filter_expr,
                            ignore_nulls: None,
                            name: None,
                            having_max: None,
                            limit: None,
                        };
                        Ok(Expression::ArrayAgg(Box::new(agg)))
                    } else {
                        Ok(e)
                    }
                }

                Action::CollectSetConvert => {
                    // COLLECT_SET(x) -> target-specific
                    if let Expression::AggregateFunction(f) = e {
                        match target {
                            DialectType::Presto => Ok(Expression::AggregateFunction(Box::new(
                                crate::expressions::AggregateFunction {
                                    name: "SET_AGG".to_string(),
                                    args: f.args,
                                    distinct: false,
                                    order_by: f.order_by,
                                    filter: f.filter,
                                    limit: f.limit,
                                    ignore_nulls: f.ignore_nulls,
                                },
                            ))),
                            DialectType::Snowflake => Ok(Expression::AggregateFunction(Box::new(
                                crate::expressions::AggregateFunction {
                                    name: "ARRAY_UNIQUE_AGG".to_string(),
                                    args: f.args,
                                    distinct: false,
                                    order_by: f.order_by,
                                    filter: f.filter,
                                    limit: f.limit,
                                    ignore_nulls: f.ignore_nulls,
                                },
                            ))),
                            DialectType::Trino | DialectType::DuckDB => {
                                let agg = crate::expressions::AggFunc {
                                    this: if f.args.is_empty() {
                                        Expression::Null(crate::expressions::Null)
                                    } else {
                                        f.args[0].clone()
                                    },
                                    distinct: true,
                                    order_by: Vec::new(),
                                    filter: None,
                                    ignore_nulls: None,
                                    name: None,
                                    having_max: None,
                                    limit: None,
                                };
                                Ok(Expression::ArrayAgg(Box::new(agg)))
                            }
                            _ => Ok(Expression::AggregateFunction(f)),
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::PercentileConvert => {
                    // PERCENTILE(x, 0.5) -> QUANTILE(x, 0.5) / APPROX_PERCENTILE(x, 0.5)
                    if let Expression::AggregateFunction(f) = e {
                        let name = match target {
                            DialectType::DuckDB => "QUANTILE",
                            DialectType::Presto | DialectType::Trino => "APPROX_PERCENTILE",
                            _ => "PERCENTILE",
                        };
                        Ok(Expression::AggregateFunction(Box::new(
                            crate::expressions::AggregateFunction {
                                name: name.to_string(),
                                args: f.args,
                                distinct: f.distinct,
                                order_by: f.order_by,
                                filter: f.filter,
                                limit: f.limit,
                                ignore_nulls: f.ignore_nulls,
                            },
                        )))
                    } else {
                        Ok(e)
                    }
                }

                Action::CorrIsnanWrap => {
                    // CORR(a, b) -> CASE WHEN ISNAN(CORR(a, b)) THEN NULL ELSE CORR(a, b) END
                    // The CORR expression could be AggregateFunction, WindowFunction, or Filter-wrapped
                    let corr_clone = e.clone();
                    let isnan = Expression::Function(Box::new(Function::new(
                        "ISNAN".to_string(),
                        vec![corr_clone.clone()],
                    )));
                    let case_expr = Expression::Case(Box::new(Case {
                        operand: None,
                        whens: vec![(isnan, Expression::Null(crate::expressions::Null))],
                        else_: Some(corr_clone),
                        comments: Vec::new(),
                    }));
                    Ok(case_expr)
                }

                Action::TruncToDateTrunc => {
                    // TRUNC(timestamp, 'MONTH') -> DATE_TRUNC('MONTH', timestamp)
                    if let Expression::Function(f) = e {
                        if f.args.len() == 2 {
                            let timestamp = f.args[0].clone();
                            let unit_expr = f.args[1].clone();

                            if matches!(target, DialectType::ClickHouse) {
                                // For ClickHouse, produce Expression::DateTrunc which the generator
                                // outputs as DATE_TRUNC(...) without going through the ClickHouse
                                // target transform that would convert it to dateTrunc
                                let unit_str = Self::get_unit_str_static(&unit_expr);
                                let dt_field = match unit_str.as_str() {
                                    "YEAR" => DateTimeField::Year,
                                    "MONTH" => DateTimeField::Month,
                                    "DAY" => DateTimeField::Day,
                                    "HOUR" => DateTimeField::Hour,
                                    "MINUTE" => DateTimeField::Minute,
                                    "SECOND" => DateTimeField::Second,
                                    "WEEK" => DateTimeField::Week,
                                    "QUARTER" => DateTimeField::Quarter,
                                    _ => DateTimeField::Custom(unit_str),
                                };
                                Ok(Expression::DateTrunc(Box::new(
                                    crate::expressions::DateTruncFunc {
                                        this: timestamp,
                                        unit: dt_field,
                                    },
                                )))
                            } else {
                                let new_args = vec![unit_expr, timestamp];
                                Ok(Expression::Function(Box::new(Function::new(
                                    "DATE_TRUNC".to_string(),
                                    new_args,
                                ))))
                            }
                        } else {
                            Ok(Expression::Function(f))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::ArrayContainsConvert => {
                    if let Expression::ArrayContains(f) = e {
                        match target {
                            DialectType::Presto | DialectType::Trino => {
                                // ARRAY_CONTAINS(arr, val) -> CONTAINS(arr, val)
                                Ok(Expression::Function(Box::new(Function::new(
                                    "CONTAINS".to_string(),
                                    vec![f.this, f.expression],
                                ))))
                            }
                            DialectType::Snowflake => {
                                // ARRAY_CONTAINS(arr, val) -> ARRAY_CONTAINS(CAST(val AS VARIANT), arr)
                                let cast_val =
                                    Expression::Cast(Box::new(crate::expressions::Cast {
                                        this: f.expression,
                                        to: crate::expressions::DataType::Custom {
                                            name: "VARIANT".to_string(),
                                        },
                                        trailing_comments: Vec::new(),
                                        double_colon_syntax: false,
                                        format: None,
                                        default: None,
                                    }));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "ARRAY_CONTAINS".to_string(),
                                    vec![cast_val, f.this],
                                ))))
                            }
                            _ => Ok(Expression::ArrayContains(f)),
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::StrPositionExpand => {
                    // StrPosition with position arg -> complex STRPOS expansion for Presto/DuckDB
                    // LOCATE(substr, str, pos) / STRPOS(str, substr, pos) ->
                    // For Presto: IF(STRPOS(SUBSTRING(str, pos), substr) = 0, 0, STRPOS(SUBSTRING(str, pos), substr) + pos - 1)
                    // For DuckDB: CASE WHEN STRPOS(SUBSTRING(str, pos), substr) = 0 THEN 0 ELSE STRPOS(SUBSTRING(str, pos), substr) + pos - 1 END
                    if let Expression::StrPosition(sp) = e {
                        let crate::expressions::StrPosition {
                            this,
                            substr,
                            position,
                            occurrence,
                        } = *sp;
                        let string = *this;
                        let substr_expr = match substr {
                            Some(s) => *s,
                            None => Expression::Null(Null),
                        };
                        let pos = match position {
                            Some(p) => *p,
                            None => Expression::number(1),
                        };

                        // SUBSTRING(string, pos)
                        let substring_call = Expression::Function(Box::new(Function::new(
                            "SUBSTRING".to_string(),
                            vec![string.clone(), pos.clone()],
                        )));
                        // STRPOS(SUBSTRING(string, pos), substr)
                        let strpos_call = Expression::Function(Box::new(Function::new(
                            "STRPOS".to_string(),
                            vec![substring_call, substr_expr.clone()],
                        )));
                        // STRPOS(...) + pos - 1
                        let pos_adjusted =
                            Expression::Sub(Box::new(crate::expressions::BinaryOp::new(
                                Expression::Add(Box::new(crate::expressions::BinaryOp::new(
                                    strpos_call.clone(),
                                    pos.clone(),
                                ))),
                                Expression::number(1),
                            )));
                        // STRPOS(...) = 0
                        let is_zero = Expression::Eq(Box::new(crate::expressions::BinaryOp::new(
                            strpos_call.clone(),
                            Expression::number(0),
                        )));

                        match target {
                            DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                // IF(STRPOS(SUBSTRING(str, pos), substr) = 0, 0, STRPOS(SUBSTRING(str, pos), substr) + pos - 1)
                                Ok(Expression::Function(Box::new(Function::new(
                                    "IF".to_string(),
                                    vec![is_zero, Expression::number(0), pos_adjusted],
                                ))))
                            }
                            DialectType::DuckDB => {
                                // CASE WHEN STRPOS(SUBSTRING(str, pos), substr) = 0 THEN 0 ELSE STRPOS(SUBSTRING(str, pos), substr) + pos - 1 END
                                Ok(Expression::Case(Box::new(Case {
                                    operand: None,
                                    whens: vec![(is_zero, Expression::number(0))],
                                    else_: Some(pos_adjusted),
                                    comments: Vec::new(),
                                })))
                            }
                            _ => {
                                // Reconstruct StrPosition
                                Ok(Expression::StrPosition(Box::new(
                                    crate::expressions::StrPosition {
                                        this: Box::new(string),
                                        substr: Some(Box::new(substr_expr)),
                                        position: Some(Box::new(pos)),
                                        occurrence,
                                    },
                                )))
                            }
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::MonthsBetweenConvert => {
                    if let Expression::MonthsBetween(mb) = e {
                        let crate::expressions::BinaryFunc {
                            this: end_date,
                            expression: start_date,
                            ..
                        } = *mb;
                        match target {
                            DialectType::DuckDB => {
                                let cast_end = Self::ensure_cast_date(end_date);
                                let cast_start = Self::ensure_cast_date(start_date);
                                let dd = Expression::Function(Box::new(Function::new(
                                    "DATE_DIFF".to_string(),
                                    vec![
                                        Expression::string("MONTH"),
                                        cast_start.clone(),
                                        cast_end.clone(),
                                    ],
                                )));
                                let day_end = Expression::Function(Box::new(Function::new(
                                    "DAY".to_string(),
                                    vec![cast_end.clone()],
                                )));
                                let day_start = Expression::Function(Box::new(Function::new(
                                    "DAY".to_string(),
                                    vec![cast_start.clone()],
                                )));
                                let last_day_end = Expression::Function(Box::new(Function::new(
                                    "LAST_DAY".to_string(),
                                    vec![cast_end.clone()],
                                )));
                                let last_day_start = Expression::Function(Box::new(Function::new(
                                    "LAST_DAY".to_string(),
                                    vec![cast_start.clone()],
                                )));
                                let day_last_end = Expression::Function(Box::new(Function::new(
                                    "DAY".to_string(),
                                    vec![last_day_end],
                                )));
                                let day_last_start = Expression::Function(Box::new(Function::new(
                                    "DAY".to_string(),
                                    vec![last_day_start],
                                )));
                                let cond1 = Expression::Eq(Box::new(BinaryOp::new(
                                    day_end.clone(),
                                    day_last_end,
                                )));
                                let cond2 = Expression::Eq(Box::new(BinaryOp::new(
                                    day_start.clone(),
                                    day_last_start,
                                )));
                                let both_cond =
                                    Expression::And(Box::new(BinaryOp::new(cond1, cond2)));
                                let day_diff =
                                    Expression::Sub(Box::new(BinaryOp::new(day_end, day_start)));
                                let day_diff_paren =
                                    Expression::Paren(Box::new(crate::expressions::Paren {
                                        this: day_diff,
                                        trailing_comments: Vec::new(),
                                    }));
                                let frac = Expression::Div(Box::new(BinaryOp::new(
                                    day_diff_paren,
                                    Expression::Literal(Literal::Number("31.0".to_string())),
                                )));
                                let case_expr = Expression::Case(Box::new(Case {
                                    operand: None,
                                    whens: vec![(both_cond, Expression::number(0))],
                                    else_: Some(frac),
                                    comments: Vec::new(),
                                }));
                                Ok(Expression::Add(Box::new(BinaryOp::new(dd, case_expr))))
                            }
                            DialectType::Snowflake | DialectType::Redshift => {
                                let unit = Expression::Identifier(Identifier::new("MONTH"));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "DATEDIFF".to_string(),
                                    vec![unit, start_date, end_date],
                                ))))
                            }
                            DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                Ok(Expression::Function(Box::new(Function::new(
                                    "DATE_DIFF".to_string(),
                                    vec![Expression::string("MONTH"), start_date, end_date],
                                ))))
                            }
                            _ => Ok(Expression::MonthsBetween(Box::new(
                                crate::expressions::BinaryFunc {
                                    this: end_date,
                                    expression: start_date,
                                    original_name: None,
                                },
                            ))),
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::AddMonthsConvert => {
                    if let Expression::AddMonths(am) = e {
                        let date = am.this;
                        let val = am.expression;
                        match target {
                            DialectType::TSQL | DialectType::Fabric => {
                                let cast_date = Self::ensure_cast_datetime2(date);
                                Ok(Expression::Function(Box::new(Function::new(
                                    "DATEADD".to_string(),
                                    vec![
                                        Expression::Identifier(Identifier::new("MONTH")),
                                        val,
                                        cast_date,
                                    ],
                                ))))
                            }
                            DialectType::DuckDB if matches!(source, DialectType::Snowflake) => {
                                // DuckDB ADD_MONTHS from Snowflake: CASE WHEN LAST_DAY(date) = date THEN LAST_DAY(date + interval) ELSE date + interval END
                                // Optionally wrapped in CAST(... AS type) if the input had a specific type

                                // Determine the cast type from the date expression
                                let (cast_date, return_type) = match &date {
                                    Expression::Literal(Literal::String(_)) => {
                                        // String literal: CAST(str AS TIMESTAMP), no outer CAST
                                        (
                                            Expression::Cast(Box::new(Cast {
                                                this: date.clone(),
                                                to: DataType::Timestamp {
                                                    precision: None,
                                                    timezone: false,
                                                },
                                                trailing_comments: Vec::new(),
                                                double_colon_syntax: false,
                                                format: None,
                                                default: None,
                                            })),
                                            None,
                                        )
                                    }
                                    Expression::Cast(c) => {
                                        // Already cast (e.g., '2023-01-31'::DATE) - keep the cast, wrap result in CAST(... AS type)
                                        (date.clone(), Some(c.to.clone()))
                                    }
                                    _ => {
                                        // Expression or NULL::TYPE - keep as-is, check for cast type
                                        if let Expression::Cast(c) = &date {
                                            (date.clone(), Some(c.to.clone()))
                                        } else {
                                            (date.clone(), None)
                                        }
                                    }
                                };

                                // Build the interval expression
                                // For non-integer values (float, decimal, cast), use TO_MONTHS(CAST(ROUND(val) AS INT))
                                // For integer values, use INTERVAL val MONTH
                                let is_non_integer_val = match &val {
                                    Expression::Literal(Literal::Number(n)) => n.contains('.'),
                                    Expression::Cast(_) => true, // e.g., 3.2::DECIMAL(10,2)
                                    Expression::Neg(n) => {
                                        if let Expression::Literal(Literal::Number(s)) = &n.this {
                                            s.contains('.')
                                        } else {
                                            false
                                        }
                                    }
                                    _ => false,
                                };

                                let add_interval = if is_non_integer_val {
                                    // TO_MONTHS(CAST(ROUND(val) AS INT))
                                    let round_val = Expression::Function(Box::new(Function::new(
                                        "ROUND".to_string(),
                                        vec![val.clone()],
                                    )));
                                    let cast_int = Expression::Cast(Box::new(Cast {
                                        this: round_val,
                                        to: DataType::Int {
                                            length: None,
                                            integer_spelling: false,
                                        },
                                        trailing_comments: Vec::new(),
                                        double_colon_syntax: false,
                                        format: None,
                                        default: None,
                                    }));
                                    Expression::Function(Box::new(Function::new(
                                        "TO_MONTHS".to_string(),
                                        vec![cast_int],
                                    )))
                                } else {
                                    // INTERVAL val MONTH
                                    // For negative numbers, wrap in parens
                                    let interval_val = match &val {
                                        Expression::Literal(Literal::Number(n))
                                            if n.starts_with('-') =>
                                        {
                                            Expression::Paren(Box::new(Paren {
                                                this: val.clone(),
                                                trailing_comments: Vec::new(),
                                            }))
                                        }
                                        Expression::Neg(_) => Expression::Paren(Box::new(Paren {
                                            this: val.clone(),
                                            trailing_comments: Vec::new(),
                                        })),
                                        Expression::Null(_) => Expression::Paren(Box::new(Paren {
                                            this: val.clone(),
                                            trailing_comments: Vec::new(),
                                        })),
                                        _ => val.clone(),
                                    };
                                    Expression::Interval(Box::new(crate::expressions::Interval {
                                        this: Some(interval_val),
                                        unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                            unit: crate::expressions::IntervalUnit::Month,
                                            use_plural: false,
                                        }),
                                    }))
                                };

                                // Build: date + interval
                                let date_plus_interval = Expression::Add(Box::new(BinaryOp::new(
                                    cast_date.clone(),
                                    add_interval.clone(),
                                )));

                                // Build LAST_DAY(date)
                                let last_day_date = Expression::Function(Box::new(Function::new(
                                    "LAST_DAY".to_string(),
                                    vec![cast_date.clone()],
                                )));

                                // Build LAST_DAY(date + interval)
                                let last_day_date_plus =
                                    Expression::Function(Box::new(Function::new(
                                        "LAST_DAY".to_string(),
                                        vec![date_plus_interval.clone()],
                                    )));

                                // Build: CASE WHEN LAST_DAY(date) = date THEN LAST_DAY(date + interval) ELSE date + interval END
                                let case_expr = Expression::Case(Box::new(Case {
                                    operand: None,
                                    whens: vec![(
                                        Expression::Eq(Box::new(BinaryOp::new(
                                            last_day_date,
                                            cast_date.clone(),
                                        ))),
                                        last_day_date_plus,
                                    )],
                                    else_: Some(date_plus_interval),
                                    comments: Vec::new(),
                                }));

                                // Wrap in CAST(... AS type) if needed
                                if let Some(dt) = return_type {
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this: case_expr,
                                        to: dt,
                                        trailing_comments: Vec::new(),
                                        double_colon_syntax: false,
                                        format: None,
                                        default: None,
                                    })))
                                } else {
                                    Ok(case_expr)
                                }
                            }
                            DialectType::DuckDB => {
                                // Non-Snowflake source: simple date + INTERVAL
                                let cast_date =
                                    if matches!(&date, Expression::Literal(Literal::String(_))) {
                                        Expression::Cast(Box::new(Cast {
                                            this: date,
                                            to: DataType::Timestamp {
                                                precision: None,
                                                timezone: false,
                                            },
                                            trailing_comments: Vec::new(),
                                            double_colon_syntax: false,
                                            format: None,
                                            default: None,
                                        }))
                                    } else {
                                        date
                                    };
                                let interval =
                                    Expression::Interval(Box::new(crate::expressions::Interval {
                                        this: Some(val),
                                        unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                            unit: crate::expressions::IntervalUnit::Month,
                                            use_plural: false,
                                        }),
                                    }));
                                Ok(Expression::Add(Box::new(BinaryOp::new(
                                    cast_date, interval,
                                ))))
                            }
                            DialectType::Snowflake => {
                                // Keep ADD_MONTHS when source is also Snowflake
                                if matches!(source, DialectType::Snowflake) {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "ADD_MONTHS".to_string(),
                                        vec![date, val],
                                    ))))
                                } else {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "DATEADD".to_string(),
                                        vec![
                                            Expression::Identifier(Identifier::new("MONTH")),
                                            val,
                                            date,
                                        ],
                                    ))))
                                }
                            }
                            DialectType::Redshift => {
                                Ok(Expression::Function(Box::new(Function::new(
                                    "DATEADD".to_string(),
                                    vec![
                                        Expression::Identifier(Identifier::new("MONTH")),
                                        val,
                                        date,
                                    ],
                                ))))
                            }
                            DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                let cast_date =
                                    if matches!(&date, Expression::Literal(Literal::String(_))) {
                                        Expression::Cast(Box::new(Cast {
                                            this: date,
                                            to: DataType::Timestamp {
                                                precision: None,
                                                timezone: false,
                                            },
                                            trailing_comments: Vec::new(),
                                            double_colon_syntax: false,
                                            format: None,
                                            default: None,
                                        }))
                                    } else {
                                        date
                                    };
                                Ok(Expression::Function(Box::new(Function::new(
                                    "DATE_ADD".to_string(),
                                    vec![Expression::string("MONTH"), val, cast_date],
                                ))))
                            }
                            DialectType::BigQuery => {
                                let interval =
                                    Expression::Interval(Box::new(crate::expressions::Interval {
                                        this: Some(val),
                                        unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                            unit: crate::expressions::IntervalUnit::Month,
                                            use_plural: false,
                                        }),
                                    }));
                                let cast_date =
                                    if matches!(&date, Expression::Literal(Literal::String(_))) {
                                        Expression::Cast(Box::new(Cast {
                                            this: date,
                                            to: DataType::Custom {
                                                name: "DATETIME".to_string(),
                                            },
                                            trailing_comments: Vec::new(),
                                            double_colon_syntax: false,
                                            format: None,
                                            default: None,
                                        }))
                                    } else {
                                        date
                                    };
                                Ok(Expression::Function(Box::new(Function::new(
                                    "DATE_ADD".to_string(),
                                    vec![cast_date, interval],
                                ))))
                            }
                            DialectType::Spark | DialectType::Databricks | DialectType::Hive => {
                                Ok(Expression::Function(Box::new(Function::new(
                                    "ADD_MONTHS".to_string(),
                                    vec![date, val],
                                ))))
                            }
                            _ => {
                                // Default: keep as AddMonths expression
                                Ok(Expression::AddMonths(Box::new(
                                    crate::expressions::BinaryFunc {
                                        this: date,
                                        expression: val,
                                        original_name: None,
                                    },
                                )))
                            }
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::PercentileContConvert => {
                    // PERCENTILE_CONT(p) WITHIN GROUP (ORDER BY col) ->
                    // Presto/Trino: APPROX_PERCENTILE(col, p)
                    // Spark/Databricks: PERCENTILE_APPROX(col, p)
                    if let Expression::WithinGroup(wg) = e {
                        // Extract percentile value and order by column
                        let (percentile, _is_disc) = match &wg.this {
                            Expression::Function(f) => {
                                let is_disc = f.name.eq_ignore_ascii_case("PERCENTILE_DISC");
                                let pct = f.args.first().cloned().unwrap_or(Expression::Literal(
                                    Literal::Number("0.5".to_string()),
                                ));
                                (pct, is_disc)
                            }
                            Expression::AggregateFunction(af) => {
                                let is_disc = af.name.eq_ignore_ascii_case("PERCENTILE_DISC");
                                let pct = af.args.first().cloned().unwrap_or(Expression::Literal(
                                    Literal::Number("0.5".to_string()),
                                ));
                                (pct, is_disc)
                            }
                            Expression::PercentileCont(pc) => (pc.percentile.clone(), false),
                            _ => return Ok(Expression::WithinGroup(wg)),
                        };
                        let col = wg
                            .order_by
                            .first()
                            .map(|o| o.this.clone())
                            .unwrap_or(Expression::Literal(Literal::Number("1".to_string())));

                        let func_name = match target {
                            DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                "APPROX_PERCENTILE"
                            }
                            _ => "PERCENTILE_APPROX", // Spark, Databricks
                        };
                        Ok(Expression::Function(Box::new(Function::new(
                            func_name.to_string(),
                            vec![col, percentile],
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::CurrentUserSparkParens => {
                    // CURRENT_USER -> CURRENT_USER() for Spark
                    if let Expression::CurrentUser(_) = e {
                        Ok(Expression::Function(Box::new(Function::new(
                            "CURRENT_USER".to_string(),
                            vec![],
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::SparkDateFuncCast => {
                    // MONTH/YEAR/DAY('string') from Spark -> wrap arg in CAST to DATE
                    let cast_arg = |arg: Expression| -> Expression {
                        match target {
                            DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                Self::double_cast_timestamp_date(arg)
                            }
                            _ => {
                                // DuckDB, PostgreSQL, etc: CAST(arg AS DATE)
                                Self::ensure_cast_date(arg)
                            }
                        }
                    };
                    match e {
                        Expression::Month(f) => Ok(Expression::Month(Box::new(
                            crate::expressions::UnaryFunc::new(cast_arg(f.this)),
                        ))),
                        Expression::Year(f) => Ok(Expression::Year(Box::new(
                            crate::expressions::UnaryFunc::new(cast_arg(f.this)),
                        ))),
                        Expression::Day(f) => Ok(Expression::Day(Box::new(
                            crate::expressions::UnaryFunc::new(cast_arg(f.this)),
                        ))),
                        other => Ok(other),
                    }
                }

                Action::MapFromArraysConvert => {
                    // Expression::MapFromArrays -> target-specific
                    if let Expression::MapFromArrays(mfa) = e {
                        let keys = mfa.this;
                        let values = mfa.expression;
                        match target {
                            DialectType::Snowflake => Ok(Expression::Function(Box::new(
                                Function::new("OBJECT_CONSTRUCT".to_string(), vec![keys, values]),
                            ))),
                            _ => {
                                // Hive, Presto, DuckDB, etc.: MAP(keys, values)
                                Ok(Expression::Function(Box::new(Function::new(
                                    "MAP".to_string(),
                                    vec![keys, values],
                                ))))
                            }
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::AnyToExists => {
                    if let Expression::Any(q) = e {
                        if let Some(op) = q.op.clone() {
                            let lambda_param = crate::expressions::Identifier::new("x");
                            let rhs = Expression::Identifier(lambda_param.clone());
                            let body = match op {
                                crate::expressions::QuantifiedOp::Eq => {
                                    Expression::Eq(Box::new(BinaryOp::new(q.this, rhs)))
                                }
                                crate::expressions::QuantifiedOp::Neq => {
                                    Expression::Neq(Box::new(BinaryOp::new(q.this, rhs)))
                                }
                                crate::expressions::QuantifiedOp::Lt => {
                                    Expression::Lt(Box::new(BinaryOp::new(q.this, rhs)))
                                }
                                crate::expressions::QuantifiedOp::Lte => {
                                    Expression::Lte(Box::new(BinaryOp::new(q.this, rhs)))
                                }
                                crate::expressions::QuantifiedOp::Gt => {
                                    Expression::Gt(Box::new(BinaryOp::new(q.this, rhs)))
                                }
                                crate::expressions::QuantifiedOp::Gte => {
                                    Expression::Gte(Box::new(BinaryOp::new(q.this, rhs)))
                                }
                            };
                            let lambda =
                                Expression::Lambda(Box::new(crate::expressions::LambdaExpr {
                                    parameters: vec![lambda_param],
                                    body,
                                    colon: false,
                                    parameter_types: Vec::new(),
                                }));
                            Ok(Expression::Function(Box::new(Function::new(
                                "EXISTS".to_string(),
                                vec![q.subquery, lambda],
                            ))))
                        } else {
                            Ok(Expression::Any(q))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::GenerateSeriesConvert => {
                    // GENERATE_SERIES(start, end[, step]) -> SEQUENCE for Spark/Databricks/Hive, wrapped in UNNEST/EXPLODE
                    // For DuckDB target: wrap in UNNEST(GENERATE_SERIES(...))
                    // For PG/Redshift target: keep as GENERATE_SERIES but normalize interval string step
                    if let Expression::Function(f) = e {
                        if f.name.eq_ignore_ascii_case("GENERATE_SERIES") && f.args.len() >= 2 {
                            let start = f.args[0].clone();
                            let end = f.args[1].clone();
                            let step = f.args.get(2).cloned();

                            // Normalize step: convert string interval like '1day' or '  2   days  ' to INTERVAL expression
                            let step = step.map(|s| Self::normalize_interval_string(s, target));

                            // Helper: wrap CURRENT_TIMESTAMP in CAST(... AS TIMESTAMP) for Presto/Trino/Spark
                            let maybe_cast_timestamp = |arg: Expression| -> Expression {
                                if matches!(
                                    target,
                                    DialectType::Presto
                                        | DialectType::Trino
                                        | DialectType::Athena
                                        | DialectType::Spark
                                        | DialectType::Databricks
                                        | DialectType::Hive
                                ) {
                                    match &arg {
                                        Expression::CurrentTimestamp(_) => {
                                            Expression::Cast(Box::new(Cast {
                                                this: arg,
                                                to: DataType::Timestamp {
                                                    precision: None,
                                                    timezone: false,
                                                },
                                                trailing_comments: Vec::new(),
                                                double_colon_syntax: false,
                                                format: None,
                                                default: None,
                                            }))
                                        }
                                        _ => arg,
                                    }
                                } else {
                                    arg
                                }
                            };

                            let start = maybe_cast_timestamp(start);
                            let end = maybe_cast_timestamp(end);

                            // For PostgreSQL/Redshift target, keep as GENERATE_SERIES
                            if matches!(target, DialectType::PostgreSQL | DialectType::Redshift) {
                                let mut gs_args = vec![start, end];
                                if let Some(step) = step {
                                    gs_args.push(step);
                                }
                                return Ok(Expression::Function(Box::new(Function::new(
                                    "GENERATE_SERIES".to_string(),
                                    gs_args,
                                ))));
                            }

                            // For DuckDB target: wrap in UNNEST(GENERATE_SERIES(...))
                            if matches!(target, DialectType::DuckDB) {
                                let mut gs_args = vec![start, end];
                                if let Some(step) = step {
                                    gs_args.push(step);
                                }
                                let gs = Expression::Function(Box::new(Function::new(
                                    "GENERATE_SERIES".to_string(),
                                    gs_args,
                                )));
                                return Ok(Expression::Function(Box::new(Function::new(
                                    "UNNEST".to_string(),
                                    vec![gs],
                                ))));
                            }

                            let mut seq_args = vec![start, end];
                            if let Some(step) = step {
                                seq_args.push(step);
                            }

                            let seq = Expression::Function(Box::new(Function::new(
                                "SEQUENCE".to_string(),
                                seq_args,
                            )));

                            match target {
                                DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                    // Wrap in UNNEST
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "UNNEST".to_string(),
                                        vec![seq],
                                    ))))
                                }
                                DialectType::Spark
                                | DialectType::Databricks
                                | DialectType::Hive => {
                                    // Wrap in EXPLODE
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "EXPLODE".to_string(),
                                        vec![seq],
                                    ))))
                                }
                                _ => {
                                    // Just SEQUENCE for others
                                    Ok(seq)
                                }
                            }
                        } else {
                            Ok(Expression::Function(f))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::ConcatCoalesceWrap => {
                    // CONCAT(a, b) function -> CONCAT(COALESCE(CAST(a AS VARCHAR), ''), ...) for Presto
                    // CONCAT(a, b) function -> CONCAT(COALESCE(a, ''), ...) for ClickHouse
                    if let Expression::Function(f) = e {
                        if f.name.eq_ignore_ascii_case("CONCAT") {
                            let new_args: Vec<Expression> = f
                                .args
                                .into_iter()
                                .map(|arg| {
                                    let cast_arg = if matches!(
                                        target,
                                        DialectType::Presto
                                            | DialectType::Trino
                                            | DialectType::Athena
                                    ) {
                                        Expression::Cast(Box::new(Cast {
                                            this: arg,
                                            to: DataType::VarChar {
                                                length: None,
                                                parenthesized_length: false,
                                            },
                                            trailing_comments: Vec::new(),
                                            double_colon_syntax: false,
                                            format: None,
                                            default: None,
                                        }))
                                    } else {
                                        arg
                                    };
                                    Expression::Function(Box::new(Function::new(
                                        "COALESCE".to_string(),
                                        vec![cast_arg, Expression::string("")],
                                    )))
                                })
                                .collect();
                            Ok(Expression::Function(Box::new(Function::new(
                                "CONCAT".to_string(),
                                new_args,
                            ))))
                        } else {
                            Ok(Expression::Function(f))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::PipeConcatToConcat => {
                    // a || b (Concat operator) -> CONCAT(CAST(a AS VARCHAR), CAST(b AS VARCHAR)) for Presto/Trino
                    if let Expression::Concat(op) = e {
                        let cast_left = Expression::Cast(Box::new(Cast {
                            this: op.left,
                            to: DataType::VarChar {
                                length: None,
                                parenthesized_length: false,
                            },
                            trailing_comments: Vec::new(),
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        }));
                        let cast_right = Expression::Cast(Box::new(Cast {
                            this: op.right,
                            to: DataType::VarChar {
                                length: None,
                                parenthesized_length: false,
                            },
                            trailing_comments: Vec::new(),
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        }));
                        Ok(Expression::Function(Box::new(Function::new(
                            "CONCAT".to_string(),
                            vec![cast_left, cast_right],
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::DivFuncConvert => {
                    // DIV(a, b) -> target-specific integer division
                    if let Expression::Function(f) = e {
                        if f.name.eq_ignore_ascii_case("DIV") && f.args.len() == 2 {
                            let a = f.args[0].clone();
                            let b = f.args[1].clone();
                            match target {
                                DialectType::DuckDB => {
                                    // DIV(a, b) -> CAST(a // b AS DECIMAL)
                                    let int_div = Expression::IntDiv(Box::new(
                                        crate::expressions::BinaryFunc {
                                            this: a,
                                            expression: b,
                                            original_name: None,
                                        },
                                    ));
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this: int_div,
                                        to: DataType::Decimal {
                                            precision: None,
                                            scale: None,
                                        },
                                        trailing_comments: Vec::new(),
                                        double_colon_syntax: false,
                                        format: None,
                                        default: None,
                                    })))
                                }
                                DialectType::BigQuery => {
                                    // DIV(a, b) -> CAST(DIV(a, b) AS NUMERIC)
                                    let div_func = Expression::Function(Box::new(Function::new(
                                        "DIV".to_string(),
                                        vec![a, b],
                                    )));
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this: div_func,
                                        to: DataType::Custom {
                                            name: "NUMERIC".to_string(),
                                        },
                                        trailing_comments: Vec::new(),
                                        double_colon_syntax: false,
                                        format: None,
                                        default: None,
                                    })))
                                }
                                DialectType::SQLite => {
                                    // DIV(a, b) -> CAST(CAST(CAST(a AS REAL) / b AS INTEGER) AS REAL)
                                    let cast_a = Expression::Cast(Box::new(Cast {
                                        this: a,
                                        to: DataType::Custom {
                                            name: "REAL".to_string(),
                                        },
                                        trailing_comments: Vec::new(),
                                        double_colon_syntax: false,
                                        format: None,
                                        default: None,
                                    }));
                                    let div = Expression::Div(Box::new(BinaryOp::new(cast_a, b)));
                                    let cast_int = Expression::Cast(Box::new(Cast {
                                        this: div,
                                        to: DataType::Int {
                                            length: None,
                                            integer_spelling: true,
                                        },
                                        trailing_comments: Vec::new(),
                                        double_colon_syntax: false,
                                        format: None,
                                        default: None,
                                    }));
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this: cast_int,
                                        to: DataType::Custom {
                                            name: "REAL".to_string(),
                                        },
                                        trailing_comments: Vec::new(),
                                        double_colon_syntax: false,
                                        format: None,
                                        default: None,
                                    })))
                                }
                                _ => Ok(Expression::Function(f)),
                            }
                        } else {
                            Ok(Expression::Function(f))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::JsonObjectAggConvert => {
                    // JSON_OBJECT_AGG/JSONB_OBJECT_AGG -> JSON_GROUP_OBJECT for DuckDB
                    match e {
                        Expression::Function(f) => Ok(Expression::Function(Box::new(
                            Function::new("JSON_GROUP_OBJECT".to_string(), f.args),
                        ))),
                        Expression::AggregateFunction(af) => {
                            // AggregateFunction stores all args in the `args` vec
                            Ok(Expression::Function(Box::new(Function::new(
                                "JSON_GROUP_OBJECT".to_string(),
                                af.args,
                            ))))
                        }
                        other => Ok(other),
                    }
                }

                Action::JsonbExistsConvert => {
                    // JSONB_EXISTS('json', 'key') -> JSON_EXISTS('json', '$.key') for DuckDB
                    if let Expression::Function(f) = e {
                        if f.args.len() == 2 {
                            let json_expr = f.args[0].clone();
                            let key = match &f.args[1] {
                                Expression::Literal(crate::expressions::Literal::String(s)) => {
                                    format!("$.{}", s)
                                }
                                _ => return Ok(Expression::Function(f)),
                            };
                            Ok(Expression::Function(Box::new(Function::new(
                                "JSON_EXISTS".to_string(),
                                vec![json_expr, Expression::string(&key)],
                            ))))
                        } else {
                            Ok(Expression::Function(f))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::DateBinConvert => {
                    // DATE_BIN('interval', ts, origin) -> TIME_BUCKET('interval', ts, origin) for DuckDB
                    if let Expression::Function(f) = e {
                        Ok(Expression::Function(Box::new(Function::new(
                            "TIME_BUCKET".to_string(),
                            f.args,
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::MysqlCastCharToText => {
                    // MySQL CAST(x AS CHAR) was originally TEXT -> convert to target text type
                    if let Expression::Cast(mut c) = e {
                        c.to = DataType::Text;
                        Ok(Expression::Cast(c))
                    } else {
                        Ok(e)
                    }
                }

                Action::SparkCastVarcharToString => {
                    // Spark parses VARCHAR(n)/CHAR(n) as TEXT -> normalize to STRING
                    match e {
                        Expression::Cast(mut c) => {
                            c.to = Self::normalize_varchar_to_string(c.to);
                            Ok(Expression::Cast(c))
                        }
                        Expression::TryCast(mut c) => {
                            c.to = Self::normalize_varchar_to_string(c.to);
                            Ok(Expression::TryCast(c))
                        }
                        _ => Ok(e),
                    }
                }

                Action::MinMaxToLeastGreatest => {
                    // Multi-arg MIN(a,b,c) -> LEAST(a,b,c), MAX(a,b,c) -> GREATEST(a,b,c)
                    if let Expression::Function(f) = e {
                        let name = f.name.to_uppercase();
                        let new_name = match name.as_str() {
                            "MIN" => "LEAST",
                            "MAX" => "GREATEST",
                            _ => return Ok(Expression::Function(f)),
                        };
                        Ok(Expression::Function(Box::new(Function::new(
                            new_name.to_string(),
                            f.args,
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::ClickHouseUniqToApproxCountDistinct => {
                    // ClickHouse uniq(x) -> APPROX_COUNT_DISTINCT(x) for non-ClickHouse targets
                    if let Expression::Function(f) = e {
                        Ok(Expression::Function(Box::new(Function::new(
                            "APPROX_COUNT_DISTINCT".to_string(),
                            f.args,
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::ClickHouseAnyToAnyValue => {
                    // ClickHouse any(x) -> ANY_VALUE(x) for non-ClickHouse targets
                    if let Expression::Function(f) = e {
                        Ok(Expression::Function(Box::new(Function::new(
                            "ANY_VALUE".to_string(),
                            f.args,
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::OracleVarchar2ToVarchar => {
                    // Oracle VARCHAR2(N CHAR/BYTE) / NVARCHAR2(N) -> VarChar(N) for non-Oracle targets
                    if let Expression::DataType(DataType::Custom { ref name }) = e {
                        let upper = name.to_uppercase();
                        // Extract length from VARCHAR2(N ...) or NVARCHAR2(N ...)
                        let inner =
                            if upper.starts_with("VARCHAR2(") || upper.starts_with("NVARCHAR2(") {
                                let start = if upper.starts_with("N") { 10 } else { 9 }; // skip "NVARCHAR2(" or "VARCHAR2("
                                let end = name.len() - 1; // skip trailing ")"
                                Some(&name[start..end])
                            } else {
                                Option::None
                            };
                        if let Some(inner_str) = inner {
                            // Parse the number part, ignoring BYTE/CHAR qualifier
                            let num_str = inner_str.split_whitespace().next().unwrap_or("");
                            if let Ok(n) = num_str.parse::<u32>() {
                                Ok(Expression::DataType(DataType::VarChar {
                                    length: Some(n),
                                    parenthesized_length: false,
                                }))
                            } else {
                                Ok(e)
                            }
                        } else {
                            // Plain VARCHAR2 / NVARCHAR2 without parens
                            Ok(Expression::DataType(DataType::VarChar {
                                length: Option::None,
                                parenthesized_length: false,
                            }))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::Nvl2Expand => {
                    // NVL2(a, b[, c]) -> CASE WHEN NOT a IS NULL THEN b [ELSE c] END
                    // But keep as NVL2 for dialects that support it natively
                    let nvl2_native = matches!(
                        target,
                        DialectType::Oracle
                            | DialectType::Snowflake
                            | DialectType::Redshift
                            | DialectType::Teradata
                            | DialectType::Spark
                            | DialectType::Databricks
                    );
                    let (a, b, c) = if let Expression::Nvl2(nvl2) = e {
                        if nvl2_native {
                            return Ok(Expression::Nvl2(nvl2));
                        }
                        (nvl2.this, nvl2.true_value, Some(nvl2.false_value))
                    } else if let Expression::Function(f) = e {
                        if nvl2_native {
                            return Ok(Expression::Function(Box::new(Function::new(
                                "NVL2".to_string(),
                                f.args,
                            ))));
                        }
                        if f.args.len() < 2 {
                            return Ok(Expression::Function(f));
                        }
                        let mut args = f.args;
                        let a = args.remove(0);
                        let b = args.remove(0);
                        let c = if !args.is_empty() {
                            Some(args.remove(0))
                        } else {
                            Option::None
                        };
                        (a, b, c)
                    } else {
                        return Ok(e);
                    };
                    // Build: NOT (a IS NULL)
                    let is_null = Expression::IsNull(Box::new(IsNull {
                        this: a,
                        not: false,
                        postfix_form: false,
                    }));
                    let not_null =
                        Expression::Not(Box::new(crate::expressions::UnaryOp { this: is_null }));
                    Ok(Expression::Case(Box::new(Case {
                        operand: Option::None,
                        whens: vec![(not_null, b)],
                        else_: c,
                        comments: Vec::new(),
                    })))
                }

                Action::IfnullToCoalesce => {
                    // IFNULL(a, b) -> COALESCE(a, b): clear original_name to output COALESCE
                    if let Expression::Coalesce(mut cf) = e {
                        cf.original_name = Option::None;
                        Ok(Expression::Coalesce(cf))
                    } else if let Expression::Function(f) = e {
                        Ok(Expression::Function(Box::new(Function::new(
                            "COALESCE".to_string(),
                            f.args,
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::IsAsciiConvert => {
                    // IS_ASCII(x) -> dialect-specific ASCII check
                    if let Expression::Function(f) = e {
                        let arg = f.args.into_iter().next().unwrap();
                        match target {
                            DialectType::MySQL | DialectType::SingleStore | DialectType::TiDB => {
                                // REGEXP_LIKE(x, '^[[:ascii:]]*$')
                                Ok(Expression::Function(Box::new(Function::new(
                                    "REGEXP_LIKE".to_string(),
                                    vec![
                                        arg,
                                        Expression::Literal(Literal::String(
                                            "^[[:ascii:]]*$".to_string(),
                                        )),
                                    ],
                                ))))
                            }
                            DialectType::PostgreSQL
                            | DialectType::Redshift
                            | DialectType::Materialize
                            | DialectType::RisingWave => {
                                // (x ~ '^[[:ascii:]]*$')
                                Ok(Expression::Paren(Box::new(Paren {
                                    this: Expression::RegexpLike(Box::new(
                                        crate::expressions::RegexpFunc {
                                            this: arg,
                                            pattern: Expression::Literal(Literal::String(
                                                "^[[:ascii:]]*$".to_string(),
                                            )),
                                            flags: Option::None,
                                        },
                                    )),
                                    trailing_comments: Vec::new(),
                                })))
                            }
                            DialectType::SQLite => {
                                // (NOT x GLOB CAST(x'2a5b5e012d7f5d2a' AS TEXT))
                                let hex_lit = Expression::Literal(Literal::HexString(
                                    "2a5b5e012d7f5d2a".to_string(),
                                ));
                                let cast_expr = Expression::Cast(Box::new(Cast {
                                    this: hex_lit,
                                    to: DataType::Text,
                                    trailing_comments: Vec::new(),
                                    double_colon_syntax: false,
                                    format: Option::None,
                                    default: Option::None,
                                }));
                                let glob = Expression::Glob(Box::new(BinaryOp {
                                    left: arg,
                                    right: cast_expr,
                                    left_comments: Vec::new(),
                                    operator_comments: Vec::new(),
                                    trailing_comments: Vec::new(),
                                }));
                                Ok(Expression::Paren(Box::new(Paren {
                                    this: Expression::Not(Box::new(crate::expressions::UnaryOp {
                                        this: glob,
                                    })),
                                    trailing_comments: Vec::new(),
                                })))
                            }
                            DialectType::TSQL | DialectType::Fabric => {
                                // (PATINDEX(CONVERT(VARCHAR(MAX), 0x255b5e002d7f5d25) COLLATE Latin1_General_BIN, x) = 0)
                                let hex_lit = Expression::Literal(Literal::HexNumber(
                                    "255b5e002d7f5d25".to_string(),
                                ));
                                let convert_expr = Expression::Convert(Box::new(
                                    crate::expressions::ConvertFunc {
                                        this: hex_lit,
                                        to: DataType::Text, // Text generates as VARCHAR(MAX) for TSQL
                                        style: None,
                                    },
                                ));
                                let collated = Expression::Collation(Box::new(
                                    crate::expressions::CollationExpr {
                                        this: convert_expr,
                                        collation: "Latin1_General_BIN".to_string(),
                                        quoted: false,
                                        double_quoted: false,
                                    },
                                ));
                                let patindex = Expression::Function(Box::new(Function::new(
                                    "PATINDEX".to_string(),
                                    vec![collated, arg],
                                )));
                                let zero = Expression::Literal(Literal::Number("0".to_string()));
                                let eq_zero = Expression::Eq(Box::new(BinaryOp {
                                    left: patindex,
                                    right: zero,
                                    left_comments: Vec::new(),
                                    operator_comments: Vec::new(),
                                    trailing_comments: Vec::new(),
                                }));
                                Ok(Expression::Paren(Box::new(Paren {
                                    this: eq_zero,
                                    trailing_comments: Vec::new(),
                                })))
                            }
                            DialectType::Oracle => {
                                // NVL(REGEXP_LIKE(x, '^[' || CHR(1) || '-' || CHR(127) || ']*$'), TRUE)
                                // Build the pattern: '^[' || CHR(1) || '-' || CHR(127) || ']*$'
                                let s1 = Expression::Literal(Literal::String("^[".to_string()));
                                let chr1 = Expression::Function(Box::new(Function::new(
                                    "CHR".to_string(),
                                    vec![Expression::Literal(Literal::Number("1".to_string()))],
                                )));
                                let dash = Expression::Literal(Literal::String("-".to_string()));
                                let chr127 = Expression::Function(Box::new(Function::new(
                                    "CHR".to_string(),
                                    vec![Expression::Literal(Literal::Number("127".to_string()))],
                                )));
                                let s2 = Expression::Literal(Literal::String("]*$".to_string()));
                                // Build: '^[' || CHR(1) || '-' || CHR(127) || ']*$'
                                let concat1 =
                                    Expression::DPipe(Box::new(crate::expressions::DPipe {
                                        this: Box::new(s1),
                                        expression: Box::new(chr1),
                                        safe: None,
                                    }));
                                let concat2 =
                                    Expression::DPipe(Box::new(crate::expressions::DPipe {
                                        this: Box::new(concat1),
                                        expression: Box::new(dash),
                                        safe: None,
                                    }));
                                let concat3 =
                                    Expression::DPipe(Box::new(crate::expressions::DPipe {
                                        this: Box::new(concat2),
                                        expression: Box::new(chr127),
                                        safe: None,
                                    }));
                                let concat4 =
                                    Expression::DPipe(Box::new(crate::expressions::DPipe {
                                        this: Box::new(concat3),
                                        expression: Box::new(s2),
                                        safe: None,
                                    }));
                                let regexp_like = Expression::Function(Box::new(Function::new(
                                    "REGEXP_LIKE".to_string(),
                                    vec![arg, concat4],
                                )));
                                // Use Column("TRUE") to output literal TRUE keyword (not boolean 1/0)
                                let true_expr = Expression::Column(crate::expressions::Column {
                                    name: Identifier {
                                        name: "TRUE".to_string(),
                                        quoted: false,
                                        trailing_comments: Vec::new(),
                                    },
                                    table: None,
                                    join_mark: false,
                                    trailing_comments: Vec::new(),
                                });
                                let nvl = Expression::Function(Box::new(Function::new(
                                    "NVL".to_string(),
                                    vec![regexp_like, true_expr],
                                )));
                                Ok(nvl)
                            }
                            _ => Ok(Expression::Function(Box::new(Function::new(
                                "IS_ASCII".to_string(),
                                vec![arg],
                            )))),
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::StrPositionConvert => {
                    // STR_POSITION(haystack, needle[, position[, occurrence]]) -> dialect-specific
                    if let Expression::Function(f) = e {
                        if f.args.len() < 2 {
                            return Ok(Expression::Function(f));
                        }
                        let mut args = f.args;

                        let haystack = args.remove(0);
                        let needle = args.remove(0);
                        let position = if !args.is_empty() {
                            Some(args.remove(0))
                        } else {
                            Option::None
                        };
                        let occurrence = if !args.is_empty() {
                            Some(args.remove(0))
                        } else {
                            Option::None
                        };

                        // Helper to build: STRPOS/INSTR(SUBSTRING(haystack, pos), needle) expansion
                        // Returns: CASE/IF WHEN func(SUBSTRING(haystack, pos), needle[, occ]) = 0 THEN 0 ELSE ... + pos - 1 END
                        fn build_position_expansion(
                            haystack: Expression,
                            needle: Expression,
                            pos: Expression,
                            occurrence: Option<Expression>,
                            inner_func: &str,
                            wrapper: &str, // "CASE", "IF", "IIF"
                        ) -> Expression {
                            let substr = Expression::Function(Box::new(Function::new(
                                "SUBSTRING".to_string(),
                                vec![haystack, pos.clone()],
                            )));
                            let mut inner_args = vec![substr, needle];
                            if let Some(occ) = occurrence {
                                inner_args.push(occ);
                            }
                            let inner_call = Expression::Function(Box::new(Function::new(
                                inner_func.to_string(),
                                inner_args,
                            )));
                            let zero = Expression::Literal(Literal::Number("0".to_string()));
                            let one = Expression::Literal(Literal::Number("1".to_string()));
                            let eq_zero = Expression::Eq(Box::new(BinaryOp {
                                left: inner_call.clone(),
                                right: zero.clone(),
                                left_comments: Vec::new(),
                                operator_comments: Vec::new(),
                                trailing_comments: Vec::new(),
                            }));
                            let add_pos = Expression::Add(Box::new(BinaryOp {
                                left: inner_call,
                                right: pos,
                                left_comments: Vec::new(),
                                operator_comments: Vec::new(),
                                trailing_comments: Vec::new(),
                            }));
                            let sub_one = Expression::Sub(Box::new(BinaryOp {
                                left: add_pos,
                                right: one,
                                left_comments: Vec::new(),
                                operator_comments: Vec::new(),
                                trailing_comments: Vec::new(),
                            }));

                            match wrapper {
                                "CASE" => Expression::Case(Box::new(Case {
                                    operand: Option::None,
                                    whens: vec![(eq_zero, zero)],
                                    else_: Some(sub_one),
                                    comments: Vec::new(),
                                })),
                                "IIF" => Expression::Function(Box::new(Function::new(
                                    "IIF".to_string(),
                                    vec![eq_zero, zero, sub_one],
                                ))),
                                _ => Expression::Function(Box::new(Function::new(
                                    "IF".to_string(),
                                    vec![eq_zero, zero, sub_one],
                                ))),
                            }
                        }

                        match target {
                            // STRPOS group: Athena, DuckDB, Presto, Trino, Drill
                            DialectType::Athena
                            | DialectType::DuckDB
                            | DialectType::Presto
                            | DialectType::Trino
                            | DialectType::Drill => {
                                if let Some(pos) = position {
                                    let wrapper = if matches!(target, DialectType::DuckDB) {
                                        "CASE"
                                    } else {
                                        "IF"
                                    };
                                    let result = build_position_expansion(
                                        haystack, needle, pos, occurrence, "STRPOS", wrapper,
                                    );
                                    if matches!(target, DialectType::Drill) {
                                        // Drill uses backtick-quoted `IF`
                                        if let Expression::Function(mut f) = result {
                                            f.name = "`IF`".to_string();
                                            Ok(Expression::Function(f))
                                        } else {
                                            Ok(result)
                                        }
                                    } else {
                                        Ok(result)
                                    }
                                } else {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "STRPOS".to_string(),
                                        vec![haystack, needle],
                                    ))))
                                }
                            }
                            // SQLite: IIF wrapper
                            DialectType::SQLite => {
                                if let Some(pos) = position {
                                    Ok(build_position_expansion(
                                        haystack, needle, pos, occurrence, "INSTR", "IIF",
                                    ))
                                } else {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "INSTR".to_string(),
                                        vec![haystack, needle],
                                    ))))
                                }
                            }
                            // INSTR group: Teradata, BigQuery, Oracle
                            DialectType::Teradata | DialectType::BigQuery | DialectType::Oracle => {
                                let mut a = vec![haystack, needle];
                                if let Some(pos) = position {
                                    a.push(pos);
                                }
                                if let Some(occ) = occurrence {
                                    a.push(occ);
                                }
                                Ok(Expression::Function(Box::new(Function::new(
                                    "INSTR".to_string(),
                                    a,
                                ))))
                            }
                            // CHARINDEX group: Snowflake, TSQL
                            DialectType::Snowflake | DialectType::TSQL | DialectType::Fabric => {
                                let mut a = vec![needle, haystack];
                                if let Some(pos) = position {
                                    a.push(pos);
                                }
                                Ok(Expression::Function(Box::new(Function::new(
                                    "CHARINDEX".to_string(),
                                    a,
                                ))))
                            }
                            // POSITION(needle IN haystack): PostgreSQL, Materialize, RisingWave, Redshift
                            DialectType::PostgreSQL
                            | DialectType::Materialize
                            | DialectType::RisingWave
                            | DialectType::Redshift => {
                                if let Some(pos) = position {
                                    // Build: CASE WHEN POSITION(needle IN SUBSTRING(haystack FROM pos)) = 0 THEN 0
                                    //   ELSE POSITION(...) + pos - 1 END
                                    let substr = Expression::Substring(Box::new(
                                        crate::expressions::SubstringFunc {
                                            this: haystack,
                                            start: pos.clone(),
                                            length: Option::None,
                                            from_for_syntax: true,
                                        },
                                    ));
                                    let pos_in = Expression::StrPosition(Box::new(
                                        crate::expressions::StrPosition {
                                            this: Box::new(substr),
                                            substr: Some(Box::new(needle)),
                                            position: Option::None,
                                            occurrence: Option::None,
                                        },
                                    ));
                                    let zero =
                                        Expression::Literal(Literal::Number("0".to_string()));
                                    let one = Expression::Literal(Literal::Number("1".to_string()));
                                    let eq_zero = Expression::Eq(Box::new(BinaryOp {
                                        left: pos_in.clone(),
                                        right: zero.clone(),
                                        left_comments: Vec::new(),
                                        operator_comments: Vec::new(),
                                        trailing_comments: Vec::new(),
                                    }));
                                    let add_pos = Expression::Add(Box::new(BinaryOp {
                                        left: pos_in,
                                        right: pos,
                                        left_comments: Vec::new(),
                                        operator_comments: Vec::new(),
                                        trailing_comments: Vec::new(),
                                    }));
                                    let sub_one = Expression::Sub(Box::new(BinaryOp {
                                        left: add_pos,
                                        right: one,
                                        left_comments: Vec::new(),
                                        operator_comments: Vec::new(),
                                        trailing_comments: Vec::new(),
                                    }));
                                    Ok(Expression::Case(Box::new(Case {
                                        operand: Option::None,
                                        whens: vec![(eq_zero, zero)],
                                        else_: Some(sub_one),
                                        comments: Vec::new(),
                                    })))
                                } else {
                                    Ok(Expression::StrPosition(Box::new(
                                        crate::expressions::StrPosition {
                                            this: Box::new(haystack),
                                            substr: Some(Box::new(needle)),
                                            position: Option::None,
                                            occurrence: Option::None,
                                        },
                                    )))
                                }
                            }
                            // LOCATE group: MySQL, Hive, Spark, Databricks, Doris
                            DialectType::MySQL
                            | DialectType::SingleStore
                            | DialectType::TiDB
                            | DialectType::Hive
                            | DialectType::Spark
                            | DialectType::Databricks
                            | DialectType::Doris
                            | DialectType::StarRocks => {
                                let mut a = vec![needle, haystack];
                                if let Some(pos) = position {
                                    a.push(pos);
                                }
                                Ok(Expression::Function(Box::new(Function::new(
                                    "LOCATE".to_string(),
                                    a,
                                ))))
                            }
                            // ClickHouse: POSITION(haystack, needle[, position])
                            DialectType::ClickHouse => {
                                let mut a = vec![haystack, needle];
                                if let Some(pos) = position {
                                    a.push(pos);
                                }
                                Ok(Expression::Function(Box::new(Function::new(
                                    "POSITION".to_string(),
                                    a,
                                ))))
                            }
                            _ => {
                                let mut a = vec![haystack, needle];
                                if let Some(pos) = position {
                                    a.push(pos);
                                }
                                if let Some(occ) = occurrence {
                                    a.push(occ);
                                }
                                Ok(Expression::Function(Box::new(Function::new(
                                    "STR_POSITION".to_string(),
                                    a,
                                ))))
                            }
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::ArraySumConvert => {
                    // ARRAY_SUM(arr) -> dialect-specific
                    if let Expression::Function(f) = e {
                        let args = f.args;
                        match target {
                            DialectType::DuckDB => Ok(Expression::Function(Box::new(
                                Function::new("LIST_SUM".to_string(), args),
                            ))),
                            DialectType::Spark | DialectType::Databricks => {
                                // AGGREGATE(arr, 0, (acc, x) -> acc + x, acc -> acc)
                                let arr = args.into_iter().next().unwrap();
                                let zero = Expression::Literal(Literal::Number("0".to_string()));
                                let acc_id = Identifier::new("acc");
                                let x_id = Identifier::new("x");
                                let acc = Expression::Identifier(acc_id.clone());
                                let x = Expression::Identifier(x_id.clone());
                                let add = Expression::Add(Box::new(BinaryOp {
                                    left: acc.clone(),
                                    right: x,
                                    left_comments: Vec::new(),
                                    operator_comments: Vec::new(),
                                    trailing_comments: Vec::new(),
                                }));
                                let lambda1 =
                                    Expression::Lambda(Box::new(crate::expressions::LambdaExpr {
                                        parameters: vec![acc_id.clone(), x_id],
                                        body: add,
                                        colon: false,
                                        parameter_types: Vec::new(),
                                    }));
                                let lambda2 =
                                    Expression::Lambda(Box::new(crate::expressions::LambdaExpr {
                                        parameters: vec![acc_id],
                                        body: acc,
                                        colon: false,
                                        parameter_types: Vec::new(),
                                    }));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "AGGREGATE".to_string(),
                                    vec![arr, zero, lambda1, lambda2],
                                ))))
                            }
                            DialectType::Presto | DialectType::Athena => {
                                // Presto/Athena keep ARRAY_SUM natively
                                Ok(Expression::Function(Box::new(Function::new(
                                    "ARRAY_SUM".to_string(),
                                    args,
                                ))))
                            }
                            DialectType::Trino => {
                                // REDUCE(arr, 0, (acc, x) -> acc + x, acc -> acc)
                                if args.len() == 1 {
                                    let arr = args.into_iter().next().unwrap();
                                    let zero =
                                        Expression::Literal(Literal::Number("0".to_string()));
                                    let acc_id = Identifier::new("acc");
                                    let x_id = Identifier::new("x");
                                    let acc = Expression::Identifier(acc_id.clone());
                                    let x = Expression::Identifier(x_id.clone());
                                    let add = Expression::Add(Box::new(BinaryOp {
                                        left: acc.clone(),
                                        right: x,
                                        left_comments: Vec::new(),
                                        operator_comments: Vec::new(),
                                        trailing_comments: Vec::new(),
                                    }));
                                    let lambda1 = Expression::Lambda(Box::new(
                                        crate::expressions::LambdaExpr {
                                            parameters: vec![acc_id.clone(), x_id],
                                            body: add,
                                            colon: false,
                                            parameter_types: Vec::new(),
                                        },
                                    ));
                                    let lambda2 = Expression::Lambda(Box::new(
                                        crate::expressions::LambdaExpr {
                                            parameters: vec![acc_id],
                                            body: acc,
                                            colon: false,
                                            parameter_types: Vec::new(),
                                        },
                                    ));
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "REDUCE".to_string(),
                                        vec![arr, zero, lambda1, lambda2],
                                    ))))
                                } else {
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "ARRAY_SUM".to_string(),
                                        args,
                                    ))))
                                }
                            }
                            DialectType::ClickHouse => {
                                // arraySum(lambda, arr) or arraySum(arr)
                                Ok(Expression::Function(Box::new(Function::new(
                                    "arraySum".to_string(),
                                    args,
                                ))))
                            }
                            _ => Ok(Expression::Function(Box::new(Function::new(
                                "ARRAY_SUM".to_string(),
                                args,
                            )))),
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::ArraySizeConvert => {
                    if let Expression::Function(f) = e {
                        Ok(Expression::Function(Box::new(Function::new(
                            "REPEATED_COUNT".to_string(),
                            f.args,
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::ArrayAnyConvert => {
                    if let Expression::Function(f) = e {
                        let mut args = f.args;
                        if args.len() == 2 {
                            let arr = args.remove(0);
                            let lambda = args.remove(0);

                            // Extract lambda parameter name and body
                            let (param_name, pred_body) =
                                if let Expression::Lambda(ref lam) = lambda {
                                    let name = if let Some(p) = lam.parameters.first() {
                                        p.name.clone()
                                    } else {
                                        "x".to_string()
                                    };
                                    (name, lam.body.clone())
                                } else {
                                    ("x".to_string(), lambda.clone())
                                };

                            // Helper: build a function call Expression
                            let make_func = |name: &str, args: Vec<Expression>| -> Expression {
                                Expression::Function(Box::new(Function::new(
                                    name.to_string(),
                                    args,
                                )))
                            };

                            // Helper: build (len_func(arr) = 0 OR len_func(filter_expr) <> 0) wrapped in Paren
                            let build_filter_pattern = |len_func: &str,
                                                        len_args_extra: Vec<Expression>,
                                                        filter_expr: Expression|
                             -> Expression {
                                // len_func(arr, ...extra) = 0
                                let mut len_arr_args = vec![arr.clone()];
                                len_arr_args.extend(len_args_extra.clone());
                                let len_arr = make_func(len_func, len_arr_args);
                                let eq_zero = Expression::Eq(Box::new(BinaryOp::new(
                                    len_arr,
                                    Expression::number(0),
                                )));

                                // len_func(filter_expr, ...extra) <> 0
                                let mut len_filter_args = vec![filter_expr];
                                len_filter_args.extend(len_args_extra);
                                let len_filter = make_func(len_func, len_filter_args);
                                let neq_zero = Expression::Neq(Box::new(BinaryOp::new(
                                    len_filter,
                                    Expression::number(0),
                                )));

                                // (eq_zero OR neq_zero)
                                let or_expr =
                                    Expression::Or(Box::new(BinaryOp::new(eq_zero, neq_zero)));
                                Expression::Paren(Box::new(Paren {
                                    this: or_expr,
                                    trailing_comments: Vec::new(),
                                }))
                            };

                            match target {
                                DialectType::Trino | DialectType::Presto | DialectType::Athena => {
                                    Ok(make_func("ANY_MATCH", vec![arr, lambda]))
                                }
                                DialectType::ClickHouse => {
                                    // (LENGTH(arr) = 0 OR LENGTH(arrayFilter(x -> pred, arr)) <> 0)
                                    // ClickHouse arrayFilter takes lambda first, then array
                                    let filter_expr =
                                        make_func("arrayFilter", vec![lambda, arr.clone()]);
                                    Ok(build_filter_pattern("LENGTH", vec![], filter_expr))
                                }
                                DialectType::Databricks | DialectType::Spark => {
                                    // (SIZE(arr) = 0 OR SIZE(FILTER(arr, x -> pred)) <> 0)
                                    let filter_expr =
                                        make_func("FILTER", vec![arr.clone(), lambda]);
                                    Ok(build_filter_pattern("SIZE", vec![], filter_expr))
                                }
                                DialectType::DuckDB => {
                                    // (ARRAY_LENGTH(arr) = 0 OR ARRAY_LENGTH(LIST_FILTER(arr, x -> pred)) <> 0)
                                    let filter_expr =
                                        make_func("LIST_FILTER", vec![arr.clone(), lambda]);
                                    Ok(build_filter_pattern("ARRAY_LENGTH", vec![], filter_expr))
                                }
                                DialectType::Teradata => {
                                    // (CARDINALITY(arr) = 0 OR CARDINALITY(FILTER(arr, x -> pred)) <> 0)
                                    let filter_expr =
                                        make_func("FILTER", vec![arr.clone(), lambda]);
                                    Ok(build_filter_pattern("CARDINALITY", vec![], filter_expr))
                                }
                                DialectType::BigQuery => {
                                    // (ARRAY_LENGTH(arr) = 0 OR ARRAY_LENGTH(ARRAY(SELECT x FROM UNNEST(arr) AS x WHERE pred)) <> 0)
                                    // Build: SELECT x FROM UNNEST(arr) AS x WHERE pred
                                    let param_col = Expression::column(&param_name);
                                    let unnest_expr = Expression::Unnest(Box::new(
                                        crate::expressions::UnnestFunc {
                                            this: arr.clone(),
                                            expressions: vec![],
                                            with_ordinality: false,
                                            alias: Some(Identifier::new(&param_name)),
                                            offset_alias: None,
                                        },
                                    ));
                                    let mut sel = crate::expressions::Select::default();
                                    sel.expressions = vec![param_col];
                                    sel.from = Some(crate::expressions::From {
                                        expressions: vec![unnest_expr],
                                    });
                                    sel.where_clause =
                                        Some(crate::expressions::Where { this: pred_body });
                                    let array_subquery =
                                        make_func("ARRAY", vec![Expression::Select(Box::new(sel))]);
                                    Ok(build_filter_pattern("ARRAY_LENGTH", vec![], array_subquery))
                                }
                                DialectType::PostgreSQL => {
                                    // (ARRAY_LENGTH(arr, 1) = 0 OR ARRAY_LENGTH(ARRAY(SELECT x FROM UNNEST(arr) AS _t0(x) WHERE pred), 1) <> 0)
                                    // Build: SELECT x FROM UNNEST(arr) AS _t0(x) WHERE pred
                                    let param_col = Expression::column(&param_name);
                                    // For PostgreSQL, UNNEST uses AS _t0(x) syntax - use TableAlias
                                    let unnest_with_alias =
                                        Expression::Alias(Box::new(crate::expressions::Alias {
                                            this: Expression::Unnest(Box::new(
                                                crate::expressions::UnnestFunc {
                                                    this: arr.clone(),
                                                    expressions: vec![],
                                                    with_ordinality: false,
                                                    alias: None,
                                                    offset_alias: None,
                                                },
                                            )),
                                            alias: Identifier::new("_t0"),
                                            column_aliases: vec![Identifier::new(&param_name)],
                                            pre_alias_comments: Vec::new(),
                                            trailing_comments: Vec::new(),
                                        }));
                                    let mut sel = crate::expressions::Select::default();
                                    sel.expressions = vec![param_col];
                                    sel.from = Some(crate::expressions::From {
                                        expressions: vec![unnest_with_alias],
                                    });
                                    sel.where_clause =
                                        Some(crate::expressions::Where { this: pred_body });
                                    let array_subquery =
                                        make_func("ARRAY", vec![Expression::Select(Box::new(sel))]);
                                    Ok(build_filter_pattern(
                                        "ARRAY_LENGTH",
                                        vec![Expression::number(1)],
                                        array_subquery,
                                    ))
                                }
                                _ => Ok(Expression::Function(Box::new(Function::new(
                                    "ARRAY_ANY".to_string(),
                                    vec![arr, lambda],
                                )))),
                            }
                        } else {
                            Ok(Expression::Function(Box::new(Function::new(
                                "ARRAY_ANY".to_string(),
                                args,
                            ))))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::DecodeSimplify => {
                    // DECODE(x, search1, result1, ..., default) -> CASE WHEN ... THEN result1 ... [ELSE default] END
                    // For literal search values: CASE WHEN x = search THEN result
                    // For NULL search: CASE WHEN x IS NULL THEN result
                    // For non-literal (column, expr): CASE WHEN x = search OR (x IS NULL AND search IS NULL) THEN result
                    fn is_decode_literal(e: &Expression) -> bool {
                        matches!(
                            e,
                            Expression::Literal(_) | Expression::Boolean(_) | Expression::Neg(_)
                        )
                    }

                    let build_decode_case =
                        |this_expr: Expression,
                         pairs: Vec<(Expression, Expression)>,
                         default: Option<Expression>| {
                            let whens: Vec<(Expression, Expression)> = pairs
                                .into_iter()
                                .map(|(search, result)| {
                                    if matches!(&search, Expression::Null(_)) {
                                        // NULL search -> IS NULL
                                        let condition = Expression::Is(Box::new(BinaryOp {
                                            left: this_expr.clone(),
                                            right: Expression::Null(crate::expressions::Null),
                                            left_comments: Vec::new(),
                                            operator_comments: Vec::new(),
                                            trailing_comments: Vec::new(),
                                        }));
                                        (condition, result)
                                    } else if is_decode_literal(&search)
                                        || is_decode_literal(&this_expr)
                                    {
                                        // At least one side is a literal -> simple equality (no NULL check needed)
                                        let eq = Expression::Eq(Box::new(BinaryOp {
                                            left: this_expr.clone(),
                                            right: search,
                                            left_comments: Vec::new(),
                                            operator_comments: Vec::new(),
                                            trailing_comments: Vec::new(),
                                        }));
                                        (eq, result)
                                    } else {
                                        // Non-literal -> null-safe comparison
                                        let needs_paren = matches!(
                                            &search,
                                            Expression::Eq(_)
                                                | Expression::Neq(_)
                                                | Expression::Gt(_)
                                                | Expression::Gte(_)
                                                | Expression::Lt(_)
                                                | Expression::Lte(_)
                                        );
                                        let search_ref = if needs_paren {
                                            Expression::Paren(Box::new(crate::expressions::Paren {
                                                this: search.clone(),
                                                trailing_comments: Vec::new(),
                                            }))
                                        } else {
                                            search.clone()
                                        };
                                        // Build: x = search OR (x IS NULL AND search IS NULL)
                                        let eq = Expression::Eq(Box::new(BinaryOp {
                                            left: this_expr.clone(),
                                            right: search_ref,
                                            left_comments: Vec::new(),
                                            operator_comments: Vec::new(),
                                            trailing_comments: Vec::new(),
                                        }));
                                        let search_in_null = if needs_paren {
                                            Expression::Paren(Box::new(crate::expressions::Paren {
                                                this: search.clone(),
                                                trailing_comments: Vec::new(),
                                            }))
                                        } else {
                                            search.clone()
                                        };
                                        let x_is_null = Expression::Is(Box::new(BinaryOp {
                                            left: this_expr.clone(),
                                            right: Expression::Null(crate::expressions::Null),
                                            left_comments: Vec::new(),
                                            operator_comments: Vec::new(),
                                            trailing_comments: Vec::new(),
                                        }));
                                        let search_is_null = Expression::Is(Box::new(BinaryOp {
                                            left: search_in_null,
                                            right: Expression::Null(crate::expressions::Null),
                                            left_comments: Vec::new(),
                                            operator_comments: Vec::new(),
                                            trailing_comments: Vec::new(),
                                        }));
                                        let both_null = Expression::And(Box::new(BinaryOp {
                                            left: x_is_null,
                                            right: search_is_null,
                                            left_comments: Vec::new(),
                                            operator_comments: Vec::new(),
                                            trailing_comments: Vec::new(),
                                        }));
                                        let condition = Expression::Or(Box::new(BinaryOp {
                                            left: eq,
                                            right: Expression::Paren(Box::new(
                                                crate::expressions::Paren {
                                                    this: both_null,
                                                    trailing_comments: Vec::new(),
                                                },
                                            )),
                                            left_comments: Vec::new(),
                                            operator_comments: Vec::new(),
                                            trailing_comments: Vec::new(),
                                        }));
                                        (condition, result)
                                    }
                                })
                                .collect();
                            Expression::Case(Box::new(Case {
                                operand: None,
                                whens,
                                else_: default,
                                comments: Vec::new(),
                            }))
                        };

                    if let Expression::Decode(decode) = e {
                        Ok(build_decode_case(
                            decode.this,
                            decode.search_results,
                            decode.default,
                        ))
                    } else if let Expression::DecodeCase(dc) = e {
                        // DecodeCase has flat expressions: [x, s1, r1, s2, r2, ..., default?]
                        let mut exprs = dc.expressions;
                        if exprs.len() < 3 {
                            return Ok(Expression::DecodeCase(Box::new(
                                crate::expressions::DecodeCase { expressions: exprs },
                            )));
                        }
                        let this_expr = exprs.remove(0);
                        let mut pairs = Vec::new();
                        let mut default = None;
                        let mut i = 0;
                        while i + 1 < exprs.len() {
                            pairs.push((exprs[i].clone(), exprs[i + 1].clone()));
                            i += 2;
                        }
                        if i < exprs.len() {
                            // Odd remaining element is the default
                            default = Some(exprs[i].clone());
                        }
                        Ok(build_decode_case(this_expr, pairs, default))
                    } else {
                        Ok(e)
                    }
                }

                Action::CreateTableLikeToCtas => {
                    // CREATE TABLE a LIKE b -> CREATE TABLE a AS SELECT * FROM b LIMIT 0
                    if let Expression::CreateTable(ct) = e {
                        let like_source = ct.constraints.iter().find_map(|c| {
                            if let crate::expressions::TableConstraint::Like { source, .. } = c {
                                Some(source.clone())
                            } else {
                                None
                            }
                        });
                        if let Some(source_table) = like_source {
                            let mut new_ct = *ct;
                            new_ct.constraints.clear();
                            // Build: SELECT * FROM b LIMIT 0
                            let select = Expression::Select(Box::new(crate::expressions::Select {
                                expressions: vec![Expression::Star(crate::expressions::Star {
                                    table: None,
                                    except: None,
                                    replace: None,
                                    rename: None,
                                    trailing_comments: Vec::new(),
                                })],
                                from: Some(crate::expressions::From {
                                    expressions: vec![Expression::Table(source_table)],
                                }),
                                limit: Some(crate::expressions::Limit {
                                    this: Expression::Literal(Literal::Number("0".to_string())),
                                    percent: false,
                                    comments: Vec::new(),
                                }),
                                ..Default::default()
                            }));
                            new_ct.as_select = Some(select);
                            Ok(Expression::CreateTable(Box::new(new_ct)))
                        } else {
                            Ok(Expression::CreateTable(ct))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::CreateTableLikeToSelectInto => {
                    // CREATE TABLE a LIKE b -> SELECT TOP 0 * INTO a FROM b AS temp
                    if let Expression::CreateTable(ct) = e {
                        let like_source = ct.constraints.iter().find_map(|c| {
                            if let crate::expressions::TableConstraint::Like { source, .. } = c {
                                Some(source.clone())
                            } else {
                                None
                            }
                        });
                        if let Some(source_table) = like_source {
                            let mut aliased_source = source_table;
                            aliased_source.alias = Some(Identifier::new("temp"));
                            // Build: SELECT TOP 0 * INTO a FROM b AS temp
                            let select = Expression::Select(Box::new(crate::expressions::Select {
                                expressions: vec![Expression::Star(crate::expressions::Star {
                                    table: None,
                                    except: None,
                                    replace: None,
                                    rename: None,
                                    trailing_comments: Vec::new(),
                                })],
                                from: Some(crate::expressions::From {
                                    expressions: vec![Expression::Table(aliased_source)],
                                }),
                                into: Some(crate::expressions::SelectInto {
                                    this: Expression::Table(ct.name.clone()),
                                    temporary: false,
                                    unlogged: false,
                                    bulk_collect: false,
                                    expressions: Vec::new(),
                                }),
                                top: Some(crate::expressions::Top {
                                    this: Expression::Literal(Literal::Number("0".to_string())),
                                    percent: false,
                                    with_ties: false,
                                    parenthesized: false,
                                }),
                                ..Default::default()
                            }));
                            Ok(select)
                        } else {
                            Ok(Expression::CreateTable(ct))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::CreateTableLikeToAs => {
                    // CREATE TABLE a LIKE b -> CREATE TABLE a AS b (ClickHouse)
                    if let Expression::CreateTable(ct) = e {
                        let like_source = ct.constraints.iter().find_map(|c| {
                            if let crate::expressions::TableConstraint::Like { source, .. } = c {
                                Some(source.clone())
                            } else {
                                None
                            }
                        });
                        if let Some(source_table) = like_source {
                            let mut new_ct = *ct;
                            new_ct.constraints.clear();
                            // AS b (just a table reference, not a SELECT)
                            new_ct.as_select = Some(Expression::Table(source_table));
                            Ok(Expression::CreateTable(Box::new(new_ct)))
                        } else {
                            Ok(Expression::CreateTable(ct))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::TsOrDsToDateConvert => {
                    // TS_OR_DS_TO_DATE(x[, fmt]) -> dialect-specific date conversion
                    if let Expression::Function(f) = e {
                        let mut args = f.args;
                        let this = args.remove(0);
                        let fmt = if !args.is_empty() {
                            match &args[0] {
                                Expression::Literal(Literal::String(s)) => Some(s.clone()),
                                _ => None,
                            }
                        } else {
                            None
                        };
                        Ok(Expression::TsOrDsToDate(Box::new(
                            crate::expressions::TsOrDsToDate {
                                this: Box::new(this),
                                format: fmt,
                                safe: None,
                            },
                        )))
                    } else {
                        Ok(e)
                    }
                }

                Action::TsOrDsToDateStrConvert => {
                    // TS_OR_DS_TO_DATE_STR(x) -> SUBSTRING(CAST(x AS type), 1, 10)
                    if let Expression::Function(f) = e {
                        let arg = f.args.into_iter().next().unwrap();
                        let str_type = match target {
                            DialectType::DuckDB
                            | DialectType::PostgreSQL
                            | DialectType::Materialize => DataType::Text,
                            DialectType::Hive | DialectType::Spark | DialectType::Databricks => {
                                DataType::Custom {
                                    name: "STRING".to_string(),
                                }
                            }
                            DialectType::Presto
                            | DialectType::Trino
                            | DialectType::Athena
                            | DialectType::Drill => DataType::VarChar {
                                length: None,
                                parenthesized_length: false,
                            },
                            DialectType::MySQL | DialectType::Doris | DialectType::StarRocks => {
                                DataType::Custom {
                                    name: "STRING".to_string(),
                                }
                            }
                            _ => DataType::VarChar {
                                length: None,
                                parenthesized_length: false,
                            },
                        };
                        let cast_expr = Expression::Cast(Box::new(Cast {
                            this: arg,
                            to: str_type,
                            double_colon_syntax: false,
                            trailing_comments: Vec::new(),
                            format: None,
                            default: None,
                        }));
                        Ok(Expression::Substring(Box::new(
                            crate::expressions::SubstringFunc {
                                this: cast_expr,
                                start: Expression::number(1),
                                length: Some(Expression::number(10)),
                                from_for_syntax: false,
                            },
                        )))
                    } else {
                        Ok(e)
                    }
                }

                Action::DateStrToDateConvert => {
                    // DATE_STR_TO_DATE(x) -> dialect-specific
                    if let Expression::Function(f) = e {
                        let arg = f.args.into_iter().next().unwrap();
                        match target {
                            DialectType::SQLite => {
                                // SQLite: just the bare expression (dates are strings)
                                Ok(arg)
                            }
                            _ => Ok(Expression::Cast(Box::new(Cast {
                                this: arg,
                                to: DataType::Date,
                                double_colon_syntax: false,
                                trailing_comments: Vec::new(),
                                format: None,
                                default: None,
                            }))),
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::TimeStrToDateConvert => {
                    // TIME_STR_TO_DATE(x) -> dialect-specific
                    if let Expression::Function(f) = e {
                        let arg = f.args.into_iter().next().unwrap();
                        match target {
                            DialectType::Hive
                            | DialectType::Doris
                            | DialectType::StarRocks
                            | DialectType::Snowflake => Ok(Expression::Function(Box::new(
                                Function::new("TO_DATE".to_string(), vec![arg]),
                            ))),
                            DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                // Presto: CAST(x AS TIMESTAMP)
                                Ok(Expression::Cast(Box::new(Cast {
                                    this: arg,
                                    to: DataType::Timestamp {
                                        timezone: false,
                                        precision: None,
                                    },
                                    double_colon_syntax: false,
                                    trailing_comments: Vec::new(),
                                    format: None,
                                    default: None,
                                })))
                            }
                            _ => {
                                // Default: CAST(x AS DATE)
                                Ok(Expression::Cast(Box::new(Cast {
                                    this: arg,
                                    to: DataType::Date,
                                    double_colon_syntax: false,
                                    trailing_comments: Vec::new(),
                                    format: None,
                                    default: None,
                                })))
                            }
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::TimeStrToTimeConvert => {
                    // TIME_STR_TO_TIME(x[, zone]) -> dialect-specific CAST to timestamp type
                    if let Expression::Function(f) = e {
                        let mut args = f.args;
                        let this = args.remove(0);
                        let zone = if !args.is_empty() {
                            match &args[0] {
                                Expression::Literal(Literal::String(s)) => Some(s.clone()),
                                _ => None,
                            }
                        } else {
                            None
                        };
                        let has_zone = zone.is_some();

                        match target {
                            DialectType::SQLite => {
                                // SQLite: just the bare expression
                                Ok(this)
                            }
                            DialectType::MySQL => {
                                if has_zone {
                                    // MySQL with zone: TIMESTAMP(x)
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "TIMESTAMP".to_string(),
                                        vec![this],
                                    ))))
                                } else {
                                    // MySQL: CAST(x AS DATETIME) or with precision
                                    // Use DataType::Custom to avoid MySQL's transform_cast converting
                                    // CAST(x AS TIMESTAMP) -> TIMESTAMP(x)
                                    let precision =
                                        if let Expression::Literal(Literal::String(ref s)) = this {
                                            if let Some(dot_pos) = s.rfind('.') {
                                                let frac = &s[dot_pos + 1..];
                                                let digit_count = frac
                                                    .chars()
                                                    .take_while(|c| c.is_ascii_digit())
                                                    .count();
                                                if digit_count > 0 {
                                                    Some(digit_count)
                                                } else {
                                                    None
                                                }
                                            } else {
                                                None
                                            }
                                        } else {
                                            None
                                        };
                                    let type_name = match precision {
                                        Some(p) => format!("DATETIME({})", p),
                                        None => "DATETIME".to_string(),
                                    };
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this,
                                        to: DataType::Custom { name: type_name },
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    })))
                                }
                            }
                            DialectType::ClickHouse => {
                                if has_zone {
                                    // ClickHouse with zone: CAST(x AS DateTime64(6, 'zone'))
                                    // We need to strip the timezone offset from the literal if present
                                    let clean_this =
                                        if let Expression::Literal(Literal::String(ref s)) = this {
                                            // Strip timezone offset like "-08:00" or "+00:00"
                                            let re_offset = s.rfind(|c: char| c == '+' || c == '-');
                                            if let Some(offset_pos) = re_offset {
                                                if offset_pos > 10 {
                                                    // After the date part
                                                    let trimmed = s[..offset_pos].to_string();
                                                    Expression::Literal(Literal::String(trimmed))
                                                } else {
                                                    this.clone()
                                                }
                                            } else {
                                                this.clone()
                                            }
                                        } else {
                                            this.clone()
                                        };
                                    let zone_str = zone.unwrap();
                                    // Build: CAST(x AS DateTime64(6, 'zone'))
                                    let type_name = format!("DateTime64(6, '{}')", zone_str);
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this: clean_this,
                                        to: DataType::Custom { name: type_name },
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    })))
                                } else {
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this,
                                        to: DataType::Custom {
                                            name: "DateTime64(6)".to_string(),
                                        },
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    })))
                                }
                            }
                            DialectType::BigQuery => {
                                if has_zone {
                                    // BigQuery with zone: CAST(x AS TIMESTAMP)
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this,
                                        to: DataType::Timestamp {
                                            timezone: false,
                                            precision: None,
                                        },
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    })))
                                } else {
                                    // BigQuery: CAST(x AS DATETIME) - Timestamp{tz:false} renders as DATETIME for BigQuery
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this,
                                        to: DataType::Custom {
                                            name: "DATETIME".to_string(),
                                        },
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    })))
                                }
                            }
                            DialectType::Doris => {
                                // Doris: CAST(x AS DATETIME)
                                Ok(Expression::Cast(Box::new(Cast {
                                    this,
                                    to: DataType::Custom {
                                        name: "DATETIME".to_string(),
                                    },
                                    double_colon_syntax: false,
                                    trailing_comments: Vec::new(),
                                    format: None,
                                    default: None,
                                })))
                            }
                            DialectType::TSQL | DialectType::Fabric => {
                                if has_zone {
                                    // TSQL with zone: CAST(x AS DATETIMEOFFSET) AT TIME ZONE 'UTC'
                                    let cast_expr = Expression::Cast(Box::new(Cast {
                                        this,
                                        to: DataType::Custom {
                                            name: "DATETIMEOFFSET".to_string(),
                                        },
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    }));
                                    Ok(Expression::AtTimeZone(Box::new(
                                        crate::expressions::AtTimeZone {
                                            this: cast_expr,
                                            zone: Expression::Literal(Literal::String(
                                                "UTC".to_string(),
                                            )),
                                        },
                                    )))
                                } else {
                                    // TSQL: CAST(x AS DATETIME2)
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this,
                                        to: DataType::Custom {
                                            name: "DATETIME2".to_string(),
                                        },
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    })))
                                }
                            }
                            DialectType::DuckDB => {
                                if has_zone {
                                    // DuckDB with zone: CAST(x AS TIMESTAMPTZ)
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this,
                                        to: DataType::Timestamp {
                                            timezone: true,
                                            precision: None,
                                        },
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    })))
                                } else {
                                    // DuckDB: CAST(x AS TIMESTAMP)
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this,
                                        to: DataType::Timestamp {
                                            timezone: false,
                                            precision: None,
                                        },
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    })))
                                }
                            }
                            DialectType::PostgreSQL
                            | DialectType::Materialize
                            | DialectType::RisingWave => {
                                if has_zone {
                                    // PostgreSQL with zone: CAST(x AS TIMESTAMPTZ)
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this,
                                        to: DataType::Timestamp {
                                            timezone: true,
                                            precision: None,
                                        },
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    })))
                                } else {
                                    // PostgreSQL: CAST(x AS TIMESTAMP)
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this,
                                        to: DataType::Timestamp {
                                            timezone: false,
                                            precision: None,
                                        },
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    })))
                                }
                            }
                            DialectType::Snowflake => {
                                if has_zone {
                                    // Snowflake with zone: CAST(x AS TIMESTAMPTZ)
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this,
                                        to: DataType::Timestamp {
                                            timezone: true,
                                            precision: None,
                                        },
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    })))
                                } else {
                                    // Snowflake: CAST(x AS TIMESTAMP)
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this,
                                        to: DataType::Timestamp {
                                            timezone: false,
                                            precision: None,
                                        },
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    })))
                                }
                            }
                            DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                if has_zone {
                                    // Presto/Trino with zone: CAST(x AS TIMESTAMP WITH TIME ZONE)
                                    // Check for precision from sub-second digits
                                    let precision =
                                        if let Expression::Literal(Literal::String(ref s)) = this {
                                            if let Some(dot_pos) = s.rfind('.') {
                                                let frac = &s[dot_pos + 1..];
                                                let digit_count = frac
                                                    .chars()
                                                    .take_while(|c| c.is_ascii_digit())
                                                    .count();
                                                if digit_count > 0
                                                    && matches!(target, DialectType::Trino)
                                                {
                                                    Some(digit_count as u32)
                                                } else {
                                                    None
                                                }
                                            } else {
                                                None
                                            }
                                        } else {
                                            None
                                        };
                                    let dt = if let Some(prec) = precision {
                                        DataType::Timestamp {
                                            timezone: true,
                                            precision: Some(prec),
                                        }
                                    } else {
                                        DataType::Timestamp {
                                            timezone: true,
                                            precision: None,
                                        }
                                    };
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this,
                                        to: dt,
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    })))
                                } else {
                                    // Check for sub-second precision for Trino
                                    let precision =
                                        if let Expression::Literal(Literal::String(ref s)) = this {
                                            if let Some(dot_pos) = s.rfind('.') {
                                                let frac = &s[dot_pos + 1..];
                                                let digit_count = frac
                                                    .chars()
                                                    .take_while(|c| c.is_ascii_digit())
                                                    .count();
                                                if digit_count > 0
                                                    && matches!(target, DialectType::Trino)
                                                {
                                                    Some(digit_count as u32)
                                                } else {
                                                    None
                                                }
                                            } else {
                                                None
                                            }
                                        } else {
                                            None
                                        };
                                    let dt = DataType::Timestamp {
                                        timezone: false,
                                        precision,
                                    };
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this,
                                        to: dt,
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    })))
                                }
                            }
                            DialectType::Redshift => {
                                if has_zone {
                                    // Redshift with zone: CAST(x AS TIMESTAMP WITH TIME ZONE)
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this,
                                        to: DataType::Timestamp {
                                            timezone: true,
                                            precision: None,
                                        },
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    })))
                                } else {
                                    // Redshift: CAST(x AS TIMESTAMP)
                                    Ok(Expression::Cast(Box::new(Cast {
                                        this,
                                        to: DataType::Timestamp {
                                            timezone: false,
                                            precision: None,
                                        },
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    })))
                                }
                            }
                            _ => {
                                // Default: CAST(x AS TIMESTAMP)
                                Ok(Expression::Cast(Box::new(Cast {
                                    this,
                                    to: DataType::Timestamp {
                                        timezone: false,
                                        precision: None,
                                    },
                                    double_colon_syntax: false,
                                    trailing_comments: Vec::new(),
                                    format: None,
                                    default: None,
                                })))
                            }
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::DateToDateStrConvert => {
                    // DATE_TO_DATE_STR(x) -> CAST(x AS text_type) per dialect
                    if let Expression::Function(f) = e {
                        let arg = f.args.into_iter().next().unwrap();
                        let str_type = match target {
                            DialectType::DuckDB => DataType::Text,
                            DialectType::Hive | DialectType::Spark | DialectType::Databricks => {
                                DataType::Custom {
                                    name: "STRING".to_string(),
                                }
                            }
                            DialectType::Presto
                            | DialectType::Trino
                            | DialectType::Athena
                            | DialectType::Drill => DataType::VarChar {
                                length: None,
                                parenthesized_length: false,
                            },
                            _ => DataType::VarChar {
                                length: None,
                                parenthesized_length: false,
                            },
                        };
                        Ok(Expression::Cast(Box::new(Cast {
                            this: arg,
                            to: str_type,
                            double_colon_syntax: false,
                            trailing_comments: Vec::new(),
                            format: None,
                            default: None,
                        })))
                    } else {
                        Ok(e)
                    }
                }

                Action::DateToDiConvert => {
                    // DATE_TO_DI(x) -> CAST(format_func(x, fmt) AS INT)
                    if let Expression::Function(f) = e {
                        let arg = f.args.into_iter().next().unwrap();
                        let inner = match target {
                            DialectType::DuckDB => {
                                // STRFTIME(x, '%Y%m%d')
                                Expression::Function(Box::new(Function::new(
                                    "STRFTIME".to_string(),
                                    vec![arg, Expression::string("%Y%m%d")],
                                )))
                            }
                            DialectType::Hive | DialectType::Spark | DialectType::Databricks => {
                                // DATE_FORMAT(x, 'yyyyMMdd')
                                Expression::Function(Box::new(Function::new(
                                    "DATE_FORMAT".to_string(),
                                    vec![arg, Expression::string("yyyyMMdd")],
                                )))
                            }
                            DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                // DATE_FORMAT(x, '%Y%m%d')
                                Expression::Function(Box::new(Function::new(
                                    "DATE_FORMAT".to_string(),
                                    vec![arg, Expression::string("%Y%m%d")],
                                )))
                            }
                            DialectType::Drill => {
                                // TO_DATE(x, 'yyyyMMdd')
                                Expression::Function(Box::new(Function::new(
                                    "TO_DATE".to_string(),
                                    vec![arg, Expression::string("yyyyMMdd")],
                                )))
                            }
                            _ => {
                                // Default: STRFTIME(x, '%Y%m%d')
                                Expression::Function(Box::new(Function::new(
                                    "STRFTIME".to_string(),
                                    vec![arg, Expression::string("%Y%m%d")],
                                )))
                            }
                        };
                        // Use INT (not INTEGER) for Presto/Trino
                        let int_type = match target {
                            DialectType::Presto
                            | DialectType::Trino
                            | DialectType::Athena
                            | DialectType::TSQL
                            | DialectType::Fabric
                            | DialectType::SQLite
                            | DialectType::Redshift => DataType::Custom {
                                name: "INT".to_string(),
                            },
                            _ => DataType::Int {
                                length: None,
                                integer_spelling: false,
                            },
                        };
                        Ok(Expression::Cast(Box::new(Cast {
                            this: inner,
                            to: int_type,
                            double_colon_syntax: false,
                            trailing_comments: Vec::new(),
                            format: None,
                            default: None,
                        })))
                    } else {
                        Ok(e)
                    }
                }

                Action::DiToDateConvert => {
                    // DI_TO_DATE(x) -> dialect-specific integer-to-date conversion
                    if let Expression::Function(f) = e {
                        let arg = f.args.into_iter().next().unwrap();
                        match target {
                            DialectType::DuckDB => {
                                // CAST(STRPTIME(CAST(x AS TEXT), '%Y%m%d') AS DATE)
                                let cast_text = Expression::Cast(Box::new(Cast {
                                    this: arg,
                                    to: DataType::Text,
                                    double_colon_syntax: false,
                                    trailing_comments: Vec::new(),
                                    format: None,
                                    default: None,
                                }));
                                let strptime = Expression::Function(Box::new(Function::new(
                                    "STRPTIME".to_string(),
                                    vec![cast_text, Expression::string("%Y%m%d")],
                                )));
                                Ok(Expression::Cast(Box::new(Cast {
                                    this: strptime,
                                    to: DataType::Date,
                                    double_colon_syntax: false,
                                    trailing_comments: Vec::new(),
                                    format: None,
                                    default: None,
                                })))
                            }
                            DialectType::Hive | DialectType::Spark | DialectType::Databricks => {
                                // TO_DATE(CAST(x AS STRING), 'yyyyMMdd')
                                let cast_str = Expression::Cast(Box::new(Cast {
                                    this: arg,
                                    to: DataType::Custom {
                                        name: "STRING".to_string(),
                                    },
                                    double_colon_syntax: false,
                                    trailing_comments: Vec::new(),
                                    format: None,
                                    default: None,
                                }));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "TO_DATE".to_string(),
                                    vec![cast_str, Expression::string("yyyyMMdd")],
                                ))))
                            }
                            DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                // CAST(DATE_PARSE(CAST(x AS VARCHAR), '%Y%m%d') AS DATE)
                                let cast_varchar = Expression::Cast(Box::new(Cast {
                                    this: arg,
                                    to: DataType::VarChar {
                                        length: None,
                                        parenthesized_length: false,
                                    },
                                    double_colon_syntax: false,
                                    trailing_comments: Vec::new(),
                                    format: None,
                                    default: None,
                                }));
                                let date_parse = Expression::Function(Box::new(Function::new(
                                    "DATE_PARSE".to_string(),
                                    vec![cast_varchar, Expression::string("%Y%m%d")],
                                )));
                                Ok(Expression::Cast(Box::new(Cast {
                                    this: date_parse,
                                    to: DataType::Date,
                                    double_colon_syntax: false,
                                    trailing_comments: Vec::new(),
                                    format: None,
                                    default: None,
                                })))
                            }
                            DialectType::Drill => {
                                // TO_DATE(CAST(x AS VARCHAR), 'yyyyMMdd')
                                let cast_varchar = Expression::Cast(Box::new(Cast {
                                    this: arg,
                                    to: DataType::VarChar {
                                        length: None,
                                        parenthesized_length: false,
                                    },
                                    double_colon_syntax: false,
                                    trailing_comments: Vec::new(),
                                    format: None,
                                    default: None,
                                }));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "TO_DATE".to_string(),
                                    vec![cast_varchar, Expression::string("yyyyMMdd")],
                                ))))
                            }
                            _ => Ok(Expression::Function(Box::new(Function::new(
                                "DI_TO_DATE".to_string(),
                                vec![arg],
                            )))),
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::TsOrDiToDiConvert => {
                    // TS_OR_DI_TO_DI(x) -> CAST(SUBSTR(REPLACE(CAST(x AS type), '-', ''), 1, 8) AS INT)
                    if let Expression::Function(f) = e {
                        let arg = f.args.into_iter().next().unwrap();
                        let str_type = match target {
                            DialectType::DuckDB => DataType::Text,
                            DialectType::Hive | DialectType::Spark | DialectType::Databricks => {
                                DataType::Custom {
                                    name: "STRING".to_string(),
                                }
                            }
                            DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                DataType::VarChar {
                                    length: None,
                                    parenthesized_length: false,
                                }
                            }
                            _ => DataType::VarChar {
                                length: None,
                                parenthesized_length: false,
                            },
                        };
                        let cast_str = Expression::Cast(Box::new(Cast {
                            this: arg,
                            to: str_type,
                            double_colon_syntax: false,
                            trailing_comments: Vec::new(),
                            format: None,
                            default: None,
                        }));
                        let replace_expr = Expression::Function(Box::new(Function::new(
                            "REPLACE".to_string(),
                            vec![cast_str, Expression::string("-"), Expression::string("")],
                        )));
                        let substr_name = match target {
                            DialectType::DuckDB
                            | DialectType::Hive
                            | DialectType::Spark
                            | DialectType::Databricks => "SUBSTR",
                            _ => "SUBSTR",
                        };
                        let substr = Expression::Function(Box::new(Function::new(
                            substr_name.to_string(),
                            vec![replace_expr, Expression::number(1), Expression::number(8)],
                        )));
                        // Use INT (not INTEGER) for Presto/Trino etc.
                        let int_type = match target {
                            DialectType::Presto
                            | DialectType::Trino
                            | DialectType::Athena
                            | DialectType::TSQL
                            | DialectType::Fabric
                            | DialectType::SQLite
                            | DialectType::Redshift => DataType::Custom {
                                name: "INT".to_string(),
                            },
                            _ => DataType::Int {
                                length: None,
                                integer_spelling: false,
                            },
                        };
                        Ok(Expression::Cast(Box::new(Cast {
                            this: substr,
                            to: int_type,
                            double_colon_syntax: false,
                            trailing_comments: Vec::new(),
                            format: None,
                            default: None,
                        })))
                    } else {
                        Ok(e)
                    }
                }

                Action::UnixToStrConvert => {
                    // UNIX_TO_STR(x, fmt) -> convert to Expression::UnixToStr for generator
                    if let Expression::Function(f) = e {
                        let mut args = f.args;
                        let this = args.remove(0);
                        let fmt_expr = if !args.is_empty() {
                            Some(args.remove(0))
                        } else {
                            None
                        };

                        // Check if format is a string literal
                        let fmt_str = fmt_expr.as_ref().and_then(|f| {
                            if let Expression::Literal(Literal::String(s)) = f {
                                Some(s.clone())
                            } else {
                                None
                            }
                        });

                        if let Some(fmt_string) = fmt_str {
                            // String literal format -> use UnixToStr expression (generator handles it)
                            Ok(Expression::UnixToStr(Box::new(
                                crate::expressions::UnixToStr {
                                    this: Box::new(this),
                                    format: Some(fmt_string),
                                },
                            )))
                        } else if let Some(fmt_e) = fmt_expr {
                            // Non-literal format (e.g., identifier `y`) -> build target expression directly
                            match target {
                                DialectType::DuckDB => {
                                    // STRFTIME(TO_TIMESTAMP(x), y)
                                    let to_ts = Expression::Function(Box::new(Function::new(
                                        "TO_TIMESTAMP".to_string(),
                                        vec![this],
                                    )));
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "STRFTIME".to_string(),
                                        vec![to_ts, fmt_e],
                                    ))))
                                }
                                DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                    // DATE_FORMAT(FROM_UNIXTIME(x), y)
                                    let from_unix = Expression::Function(Box::new(Function::new(
                                        "FROM_UNIXTIME".to_string(),
                                        vec![this],
                                    )));
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "DATE_FORMAT".to_string(),
                                        vec![from_unix, fmt_e],
                                    ))))
                                }
                                DialectType::Hive
                                | DialectType::Spark
                                | DialectType::Databricks
                                | DialectType::Doris
                                | DialectType::StarRocks => {
                                    // FROM_UNIXTIME(x, y)
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "FROM_UNIXTIME".to_string(),
                                        vec![this, fmt_e],
                                    ))))
                                }
                                _ => {
                                    // Default: keep as UNIX_TO_STR(x, y)
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "UNIX_TO_STR".to_string(),
                                        vec![this, fmt_e],
                                    ))))
                                }
                            }
                        } else {
                            Ok(Expression::UnixToStr(Box::new(
                                crate::expressions::UnixToStr {
                                    this: Box::new(this),
                                    format: None,
                                },
                            )))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::UnixToTimeConvert => {
                    // UNIX_TO_TIME(x) -> convert to Expression::UnixToTime for generator
                    if let Expression::Function(f) = e {
                        let arg = f.args.into_iter().next().unwrap();
                        Ok(Expression::UnixToTime(Box::new(
                            crate::expressions::UnixToTime {
                                this: Box::new(arg),
                                scale: None,
                                zone: None,
                                hours: None,
                                minutes: None,
                                format: None,
                                target_type: None,
                            },
                        )))
                    } else {
                        Ok(e)
                    }
                }

                Action::UnixToTimeStrConvert => {
                    // UNIX_TO_TIME_STR(x) -> dialect-specific
                    if let Expression::Function(f) = e {
                        let arg = f.args.into_iter().next().unwrap();
                        match target {
                            DialectType::Hive | DialectType::Spark | DialectType::Databricks => {
                                // FROM_UNIXTIME(x)
                                Ok(Expression::Function(Box::new(Function::new(
                                    "FROM_UNIXTIME".to_string(),
                                    vec![arg],
                                ))))
                            }
                            DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                // CAST(FROM_UNIXTIME(x) AS VARCHAR)
                                let from_unix = Expression::Function(Box::new(Function::new(
                                    "FROM_UNIXTIME".to_string(),
                                    vec![arg],
                                )));
                                Ok(Expression::Cast(Box::new(Cast {
                                    this: from_unix,
                                    to: DataType::VarChar {
                                        length: None,
                                        parenthesized_length: false,
                                    },
                                    double_colon_syntax: false,
                                    trailing_comments: Vec::new(),
                                    format: None,
                                    default: None,
                                })))
                            }
                            DialectType::DuckDB => {
                                // CAST(TO_TIMESTAMP(x) AS TEXT)
                                let to_ts = Expression::Function(Box::new(Function::new(
                                    "TO_TIMESTAMP".to_string(),
                                    vec![arg],
                                )));
                                Ok(Expression::Cast(Box::new(Cast {
                                    this: to_ts,
                                    to: DataType::Text,
                                    double_colon_syntax: false,
                                    trailing_comments: Vec::new(),
                                    format: None,
                                    default: None,
                                })))
                            }
                            _ => Ok(Expression::Function(Box::new(Function::new(
                                "UNIX_TO_TIME_STR".to_string(),
                                vec![arg],
                            )))),
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::TimeToUnixConvert => {
                    // TIME_TO_UNIX(x) -> convert to Expression::TimeToUnix for generator
                    if let Expression::Function(f) = e {
                        let arg = f.args.into_iter().next().unwrap();
                        Ok(Expression::TimeToUnix(Box::new(
                            crate::expressions::UnaryFunc {
                                this: arg,
                                original_name: None,
                            },
                        )))
                    } else {
                        Ok(e)
                    }
                }

                Action::TimeToStrConvert => {
                    // TIME_TO_STR(x, fmt) -> convert to Expression::TimeToStr for generator
                    if let Expression::Function(f) = e {
                        let mut args = f.args;
                        let this = args.remove(0);
                        let fmt = match args.remove(0) {
                            Expression::Literal(Literal::String(s)) => s,
                            other => {
                                return Ok(Expression::Function(Box::new(Function::new(
                                    "TIME_TO_STR".to_string(),
                                    vec![this, other],
                                ))));
                            }
                        };
                        Ok(Expression::TimeToStr(Box::new(
                            crate::expressions::TimeToStr {
                                this: Box::new(this),
                                format: fmt,
                                culture: None,
                                zone: None,
                            },
                        )))
                    } else {
                        Ok(e)
                    }
                }

                Action::StrToUnixConvert => {
                    // STR_TO_UNIX(x, fmt) -> convert to Expression::StrToUnix for generator
                    if let Expression::Function(f) = e {
                        let mut args = f.args;
                        let this = args.remove(0);
                        let fmt = match args.remove(0) {
                            Expression::Literal(Literal::String(s)) => s,
                            other => {
                                return Ok(Expression::Function(Box::new(Function::new(
                                    "STR_TO_UNIX".to_string(),
                                    vec![this, other],
                                ))));
                            }
                        };
                        Ok(Expression::StrToUnix(Box::new(
                            crate::expressions::StrToUnix {
                                this: Some(Box::new(this)),
                                format: Some(fmt),
                            },
                        )))
                    } else {
                        Ok(e)
                    }
                }

                Action::TimeStrToUnixConvert => {
                    // TIME_STR_TO_UNIX(x) -> dialect-specific
                    if let Expression::Function(f) = e {
                        let arg = f.args.into_iter().next().unwrap();
                        match target {
                            DialectType::DuckDB => {
                                // EPOCH(CAST(x AS TIMESTAMP))
                                let cast_ts = Expression::Cast(Box::new(Cast {
                                    this: arg,
                                    to: DataType::Timestamp {
                                        timezone: false,
                                        precision: None,
                                    },
                                    double_colon_syntax: false,
                                    trailing_comments: Vec::new(),
                                    format: None,
                                    default: None,
                                }));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "EPOCH".to_string(),
                                    vec![cast_ts],
                                ))))
                            }
                            DialectType::Hive
                            | DialectType::Doris
                            | DialectType::StarRocks
                            | DialectType::MySQL => {
                                // UNIX_TIMESTAMP(x)
                                Ok(Expression::Function(Box::new(Function::new(
                                    "UNIX_TIMESTAMP".to_string(),
                                    vec![arg],
                                ))))
                            }
                            DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                // TO_UNIXTIME(DATE_PARSE(x, '%Y-%m-%d %T'))
                                let date_parse = Expression::Function(Box::new(Function::new(
                                    "DATE_PARSE".to_string(),
                                    vec![arg, Expression::string("%Y-%m-%d %T")],
                                )));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "TO_UNIXTIME".to_string(),
                                    vec![date_parse],
                                ))))
                            }
                            _ => Ok(Expression::Function(Box::new(Function::new(
                                "TIME_STR_TO_UNIX".to_string(),
                                vec![arg],
                            )))),
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::TimeToTimeStrConvert => {
                    // TIME_TO_TIME_STR(x) -> CAST(x AS str_type) per dialect
                    if let Expression::Function(f) = e {
                        let arg = f.args.into_iter().next().unwrap();
                        let str_type = match target {
                            DialectType::DuckDB => DataType::Text,
                            DialectType::Hive
                            | DialectType::Spark
                            | DialectType::Databricks
                            | DialectType::Doris
                            | DialectType::StarRocks => DataType::Custom {
                                name: "STRING".to_string(),
                            },
                            DialectType::Redshift => DataType::Custom {
                                name: "VARCHAR(MAX)".to_string(),
                            },
                            _ => DataType::VarChar {
                                length: None,
                                parenthesized_length: false,
                            },
                        };
                        Ok(Expression::Cast(Box::new(Cast {
                            this: arg,
                            to: str_type,
                            double_colon_syntax: false,
                            trailing_comments: Vec::new(),
                            format: None,
                            default: None,
                        })))
                    } else {
                        Ok(e)
                    }
                }

                Action::DateTruncSwapArgs => {
                    // DATE_TRUNC('unit', x) from Generic -> target-specific
                    if let Expression::Function(f) = e {
                        if f.args.len() == 2 {
                            let unit_arg = f.args[0].clone();
                            let expr_arg = f.args[1].clone();
                            // Extract unit string from the first arg
                            let unit_str = match &unit_arg {
                                Expression::Literal(Literal::String(s)) => s.to_uppercase(),
                                _ => return Ok(Expression::Function(f)),
                            };
                            match target {
                                DialectType::BigQuery => {
                                    // BigQuery: DATE_TRUNC(x, UNIT) - unquoted unit
                                    let unit_ident =
                                        Expression::Column(crate::expressions::Column {
                                            name: crate::expressions::Identifier::new(unit_str),
                                            table: None,
                                            join_mark: false,
                                            trailing_comments: Vec::new(),
                                        });
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "DATE_TRUNC".to_string(),
                                        vec![expr_arg, unit_ident],
                                    ))))
                                }
                                DialectType::Doris => {
                                    // Doris: DATE_TRUNC(x, 'UNIT')
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "DATE_TRUNC".to_string(),
                                        vec![expr_arg, Expression::string(&unit_str)],
                                    ))))
                                }
                                DialectType::StarRocks => {
                                    // StarRocks: DATE_TRUNC('UNIT', x) - keep standard order
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "DATE_TRUNC".to_string(),
                                        vec![Expression::string(&unit_str), expr_arg],
                                    ))))
                                }
                                DialectType::Spark | DialectType::Databricks => {
                                    // Spark: TRUNC(x, 'UNIT')
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "TRUNC".to_string(),
                                        vec![expr_arg, Expression::string(&unit_str)],
                                    ))))
                                }
                                DialectType::MySQL => {
                                    // MySQL: complex expansion based on unit
                                    Self::date_trunc_to_mysql(&unit_str, &expr_arg)
                                }
                                _ => Ok(Expression::Function(f)),
                            }
                        } else {
                            Ok(Expression::Function(f))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::TimestampTruncConvert => {
                    // TIMESTAMP_TRUNC(x, UNIT[, tz]) from Generic -> target-specific
                    if let Expression::Function(f) = e {
                        if f.args.len() >= 2 {
                            let expr_arg = f.args[0].clone();
                            let unit_arg = f.args[1].clone();
                            let tz_arg = if f.args.len() >= 3 {
                                Some(f.args[2].clone())
                            } else {
                                None
                            };
                            // Extract unit string
                            let unit_str = match &unit_arg {
                                Expression::Literal(Literal::String(s)) => s.to_uppercase(),
                                Expression::Column(c) => c.name.name.to_uppercase(),
                                _ => {
                                    return Ok(Expression::Function(f));
                                }
                            };
                            match target {
                                DialectType::Spark | DialectType::Databricks => {
                                    // Spark: DATE_TRUNC('UNIT', x)
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "DATE_TRUNC".to_string(),
                                        vec![Expression::string(&unit_str), expr_arg],
                                    ))))
                                }
                                DialectType::Doris | DialectType::StarRocks => {
                                    // Doris: DATE_TRUNC(x, 'UNIT')
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "DATE_TRUNC".to_string(),
                                        vec![expr_arg, Expression::string(&unit_str)],
                                    ))))
                                }
                                DialectType::BigQuery => {
                                    // BigQuery: TIMESTAMP_TRUNC(x, UNIT) - keep but with unquoted unit
                                    let unit_ident =
                                        Expression::Column(crate::expressions::Column {
                                            name: crate::expressions::Identifier::new(unit_str),
                                            table: None,
                                            join_mark: false,
                                            trailing_comments: Vec::new(),
                                        });
                                    let mut args = vec![expr_arg, unit_ident];
                                    if let Some(tz) = tz_arg {
                                        args.push(tz);
                                    }
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "TIMESTAMP_TRUNC".to_string(),
                                        args,
                                    ))))
                                }
                                DialectType::DuckDB => {
                                    // DuckDB with timezone: DATE_TRUNC('UNIT', x AT TIME ZONE 'tz') AT TIME ZONE 'tz'
                                    if let Some(tz) = tz_arg {
                                        let tz_str = match &tz {
                                            Expression::Literal(Literal::String(s)) => s.clone(),
                                            _ => "UTC".to_string(),
                                        };
                                        // x AT TIME ZONE 'tz'
                                        let at_tz = Expression::AtTimeZone(Box::new(
                                            crate::expressions::AtTimeZone {
                                                this: expr_arg,
                                                zone: Expression::string(&tz_str),
                                            },
                                        ));
                                        // DATE_TRUNC('UNIT', x AT TIME ZONE 'tz')
                                        let trunc = Expression::Function(Box::new(Function::new(
                                            "DATE_TRUNC".to_string(),
                                            vec![Expression::string(&unit_str), at_tz],
                                        )));
                                        // DATE_TRUNC(...) AT TIME ZONE 'tz'
                                        Ok(Expression::AtTimeZone(Box::new(
                                            crate::expressions::AtTimeZone {
                                                this: trunc,
                                                zone: Expression::string(&tz_str),
                                            },
                                        )))
                                    } else {
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "DATE_TRUNC".to_string(),
                                            vec![Expression::string(&unit_str), expr_arg],
                                        ))))
                                    }
                                }
                                DialectType::Presto
                                | DialectType::Trino
                                | DialectType::Athena
                                | DialectType::Snowflake => {
                                    // Presto/Snowflake: DATE_TRUNC('UNIT', x) - drop timezone
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "DATE_TRUNC".to_string(),
                                        vec![Expression::string(&unit_str), expr_arg],
                                    ))))
                                }
                                _ => {
                                    // For most dialects: DATE_TRUNC('UNIT', x) + tz handling
                                    let mut args = vec![Expression::string(&unit_str), expr_arg];
                                    if let Some(tz) = tz_arg {
                                        args.push(tz);
                                    }
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "DATE_TRUNC".to_string(),
                                        args,
                                    ))))
                                }
                            }
                        } else {
                            Ok(Expression::Function(f))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::StrToDateConvert => {
                    // STR_TO_DATE(x, fmt) from Generic -> dialect-specific date parsing
                    if let Expression::Function(f) = e {
                        if f.args.len() == 2 {
                            let mut args = f.args;
                            let this = args.remove(0);
                            let fmt_expr = args.remove(0);
                            let fmt_str = match &fmt_expr {
                                Expression::Literal(Literal::String(s)) => Some(s.clone()),
                                _ => None,
                            };
                            let default_date = "%Y-%m-%d";
                            let default_time = "%Y-%m-%d %H:%M:%S";
                            let is_default = fmt_str
                                .as_ref()
                                .map_or(false, |f| f == default_date || f == default_time);

                            if is_default {
                                // Default format: handle per-dialect
                                match target {
                                    DialectType::MySQL
                                    | DialectType::Doris
                                    | DialectType::StarRocks => {
                                        // Keep STR_TO_DATE(x, fmt) as-is
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "STR_TO_DATE".to_string(),
                                            vec![this, fmt_expr],
                                        ))))
                                    }
                                    DialectType::Hive => {
                                        // Hive: CAST(x AS DATE)
                                        Ok(Expression::Cast(Box::new(Cast {
                                            this,
                                            to: DataType::Date,
                                            double_colon_syntax: false,
                                            trailing_comments: Vec::new(),
                                            format: None,
                                            default: None,
                                        })))
                                    }
                                    DialectType::Presto
                                    | DialectType::Trino
                                    | DialectType::Athena => {
                                        // Presto: CAST(DATE_PARSE(x, '%Y-%m-%d') AS DATE)
                                        let date_parse =
                                            Expression::Function(Box::new(Function::new(
                                                "DATE_PARSE".to_string(),
                                                vec![this, fmt_expr],
                                            )));
                                        Ok(Expression::Cast(Box::new(Cast {
                                            this: date_parse,
                                            to: DataType::Date,
                                            double_colon_syntax: false,
                                            trailing_comments: Vec::new(),
                                            format: None,
                                            default: None,
                                        })))
                                    }
                                    _ => {
                                        // Others: TsOrDsToDate (delegates to generator)
                                        Ok(Expression::TsOrDsToDate(Box::new(
                                            crate::expressions::TsOrDsToDate {
                                                this: Box::new(this),
                                                format: None,
                                                safe: None,
                                            },
                                        )))
                                    }
                                }
                            } else if let Some(fmt) = fmt_str {
                                match target {
                                    DialectType::Doris
                                    | DialectType::StarRocks
                                    | DialectType::MySQL => {
                                        // Keep STR_TO_DATE but with normalized format (%H:%M:%S -> %T, %-d -> %e)
                                        let mut normalized = fmt.clone();
                                        normalized = normalized.replace("%-d", "%e");
                                        normalized = normalized.replace("%-m", "%c");
                                        normalized = normalized.replace("%H:%M:%S", "%T");
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "STR_TO_DATE".to_string(),
                                            vec![this, Expression::string(&normalized)],
                                        ))))
                                    }
                                    DialectType::Hive => {
                                        // Hive: CAST(FROM_UNIXTIME(UNIX_TIMESTAMP(x, java_fmt)) AS DATE)
                                        let java_fmt = crate::generator::Generator::strftime_to_java_format_static(&fmt);
                                        let unix_ts =
                                            Expression::Function(Box::new(Function::new(
                                                "UNIX_TIMESTAMP".to_string(),
                                                vec![this, Expression::string(&java_fmt)],
                                            )));
                                        let from_unix =
                                            Expression::Function(Box::new(Function::new(
                                                "FROM_UNIXTIME".to_string(),
                                                vec![unix_ts],
                                            )));
                                        Ok(Expression::Cast(Box::new(Cast {
                                            this: from_unix,
                                            to: DataType::Date,
                                            double_colon_syntax: false,
                                            trailing_comments: Vec::new(),
                                            format: None,
                                            default: None,
                                        })))
                                    }
                                    DialectType::Spark | DialectType::Databricks => {
                                        // Spark: TO_DATE(x, java_fmt)
                                        let java_fmt = crate::generator::Generator::strftime_to_java_format_static(&fmt);
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "TO_DATE".to_string(),
                                            vec![this, Expression::string(&java_fmt)],
                                        ))))
                                    }
                                    DialectType::Drill => {
                                        // Drill: TO_DATE(x, java_fmt) with T quoted as 'T' in Java format
                                        // The generator's string literal escaping will double the quotes: 'T' -> ''T''
                                        let java_fmt = crate::generator::Generator::strftime_to_java_format_static(&fmt);
                                        let java_fmt = java_fmt.replace('T', "'T'");
                                        Ok(Expression::Function(Box::new(Function::new(
                                            "TO_DATE".to_string(),
                                            vec![this, Expression::string(&java_fmt)],
                                        ))))
                                    }
                                    _ => {
                                        // For other dialects: use TsOrDsToDate which delegates to generator
                                        Ok(Expression::TsOrDsToDate(Box::new(
                                            crate::expressions::TsOrDsToDate {
                                                this: Box::new(this),
                                                format: Some(fmt),
                                                safe: None,
                                            },
                                        )))
                                    }
                                }
                            } else {
                                // Non-string format - keep as-is
                                let mut new_args = Vec::new();
                                new_args.push(this);
                                new_args.push(fmt_expr);
                                Ok(Expression::Function(Box::new(Function::new(
                                    "STR_TO_DATE".to_string(),
                                    new_args,
                                ))))
                            }
                        } else {
                            Ok(Expression::Function(f))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::TsOrDsAddConvert => {
                    // TS_OR_DS_ADD(x, n, 'UNIT') from Generic -> dialect-specific DATE_ADD
                    if let Expression::Function(f) = e {
                        if f.args.len() == 3 {
                            let mut args = f.args;
                            let x = args.remove(0);
                            let n = args.remove(0);
                            let unit_expr = args.remove(0);
                            let unit_str = match &unit_expr {
                                Expression::Literal(Literal::String(s)) => s.to_uppercase(),
                                _ => "DAY".to_string(),
                            };

                            match target {
                                DialectType::Hive
                                | DialectType::Spark
                                | DialectType::Databricks => {
                                    // DATE_ADD(x, n) - only supports DAY unit
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "DATE_ADD".to_string(),
                                        vec![x, n],
                                    ))))
                                }
                                DialectType::MySQL => {
                                    // DATE_ADD(x, INTERVAL n UNIT)
                                    let iu = match unit_str.to_uppercase().as_str() {
                                        "YEAR" => crate::expressions::IntervalUnit::Year,
                                        "QUARTER" => crate::expressions::IntervalUnit::Quarter,
                                        "MONTH" => crate::expressions::IntervalUnit::Month,
                                        "WEEK" => crate::expressions::IntervalUnit::Week,
                                        "HOUR" => crate::expressions::IntervalUnit::Hour,
                                        "MINUTE" => crate::expressions::IntervalUnit::Minute,
                                        "SECOND" => crate::expressions::IntervalUnit::Second,
                                        _ => crate::expressions::IntervalUnit::Day,
                                    };
                                    let interval = Expression::Interval(Box::new(
                                        crate::expressions::Interval {
                                            this: Some(n),
                                            unit: Some(
                                                crate::expressions::IntervalUnitSpec::Simple {
                                                    unit: iu,
                                                    use_plural: false,
                                                },
                                            ),
                                        },
                                    ));
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "DATE_ADD".to_string(),
                                        vec![x, interval],
                                    ))))
                                }
                                DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                    // DATE_ADD('UNIT', n, CAST(CAST(x AS TIMESTAMP) AS DATE))
                                    let cast_ts = Expression::Cast(Box::new(Cast {
                                        this: x,
                                        to: DataType::Timestamp {
                                            precision: None,
                                            timezone: false,
                                        },
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    }));
                                    let cast_date = Expression::Cast(Box::new(Cast {
                                        this: cast_ts,
                                        to: DataType::Date,
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    }));
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "DATE_ADD".to_string(),
                                        vec![Expression::string(&unit_str), n, cast_date],
                                    ))))
                                }
                                DialectType::DuckDB => {
                                    // CAST(x AS DATE) + INTERVAL n UNIT
                                    let cast_date = Expression::Cast(Box::new(Cast {
                                        this: x,
                                        to: DataType::Date,
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    }));
                                    let iu = match unit_str.to_uppercase().as_str() {
                                        "YEAR" => crate::expressions::IntervalUnit::Year,
                                        "QUARTER" => crate::expressions::IntervalUnit::Quarter,
                                        "MONTH" => crate::expressions::IntervalUnit::Month,
                                        "WEEK" => crate::expressions::IntervalUnit::Week,
                                        "HOUR" => crate::expressions::IntervalUnit::Hour,
                                        "MINUTE" => crate::expressions::IntervalUnit::Minute,
                                        "SECOND" => crate::expressions::IntervalUnit::Second,
                                        _ => crate::expressions::IntervalUnit::Day,
                                    };
                                    let interval = Expression::Interval(Box::new(
                                        crate::expressions::Interval {
                                            this: Some(n),
                                            unit: Some(
                                                crate::expressions::IntervalUnitSpec::Simple {
                                                    unit: iu,
                                                    use_plural: false,
                                                },
                                            ),
                                        },
                                    ));
                                    Ok(Expression::Add(Box::new(crate::expressions::BinaryOp {
                                        left: cast_date,
                                        right: interval,
                                        left_comments: Vec::new(),
                                        operator_comments: Vec::new(),
                                        trailing_comments: Vec::new(),
                                    })))
                                }
                                DialectType::Drill => {
                                    // DATE_ADD(CAST(x AS DATE), INTERVAL n UNIT)
                                    let cast_date = Expression::Cast(Box::new(Cast {
                                        this: x,
                                        to: DataType::Date,
                                        double_colon_syntax: false,
                                        trailing_comments: Vec::new(),
                                        format: None,
                                        default: None,
                                    }));
                                    let iu = match unit_str.to_uppercase().as_str() {
                                        "YEAR" => crate::expressions::IntervalUnit::Year,
                                        "QUARTER" => crate::expressions::IntervalUnit::Quarter,
                                        "MONTH" => crate::expressions::IntervalUnit::Month,
                                        "WEEK" => crate::expressions::IntervalUnit::Week,
                                        "HOUR" => crate::expressions::IntervalUnit::Hour,
                                        "MINUTE" => crate::expressions::IntervalUnit::Minute,
                                        "SECOND" => crate::expressions::IntervalUnit::Second,
                                        _ => crate::expressions::IntervalUnit::Day,
                                    };
                                    let interval = Expression::Interval(Box::new(
                                        crate::expressions::Interval {
                                            this: Some(n),
                                            unit: Some(
                                                crate::expressions::IntervalUnitSpec::Simple {
                                                    unit: iu,
                                                    use_plural: false,
                                                },
                                            ),
                                        },
                                    ));
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "DATE_ADD".to_string(),
                                        vec![cast_date, interval],
                                    ))))
                                }
                                _ => {
                                    // Default: keep as TS_OR_DS_ADD
                                    Ok(Expression::Function(Box::new(Function::new(
                                        "TS_OR_DS_ADD".to_string(),
                                        vec![x, n, unit_expr],
                                    ))))
                                }
                            }
                        } else {
                            Ok(Expression::Function(f))
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::DateFromUnixDateConvert => {
                    // DATE_FROM_UNIX_DATE(n) -> DATEADD(DAY, n, CAST('1970-01-01' AS DATE))
                    if let Expression::Function(f) = e {
                        // Keep as-is for dialects that support DATE_FROM_UNIX_DATE natively
                        if matches!(
                            target,
                            DialectType::Spark | DialectType::Databricks | DialectType::BigQuery
                        ) {
                            return Ok(Expression::Function(Box::new(Function::new(
                                "DATE_FROM_UNIX_DATE".to_string(),
                                f.args,
                            ))));
                        }
                        let n = f.args.into_iter().next().unwrap();
                        let epoch_date = Expression::Cast(Box::new(Cast {
                            this: Expression::string("1970-01-01"),
                            to: DataType::Date,
                            double_colon_syntax: false,
                            trailing_comments: Vec::new(),
                            format: None,
                            default: None,
                        }));
                        match target {
                            DialectType::DuckDB => {
                                // CAST('1970-01-01' AS DATE) + INTERVAL n DAY
                                let interval =
                                    Expression::Interval(Box::new(crate::expressions::Interval {
                                        this: Some(n),
                                        unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                            unit: crate::expressions::IntervalUnit::Day,
                                            use_plural: false,
                                        }),
                                    }));
                                Ok(Expression::Add(Box::new(
                                    crate::expressions::BinaryOp::new(epoch_date, interval),
                                )))
                            }
                            DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                                // DATE_ADD('DAY', n, CAST('1970-01-01' AS DATE))
                                Ok(Expression::Function(Box::new(Function::new(
                                    "DATE_ADD".to_string(),
                                    vec![Expression::string("DAY"), n, epoch_date],
                                ))))
                            }
                            DialectType::Snowflake | DialectType::Redshift | DialectType::TSQL => {
                                // DATEADD(DAY, n, CAST('1970-01-01' AS DATE))
                                Ok(Expression::Function(Box::new(Function::new(
                                    "DATEADD".to_string(),
                                    vec![
                                        Expression::Identifier(Identifier::new("DAY")),
                                        n,
                                        epoch_date,
                                    ],
                                ))))
                            }
                            DialectType::BigQuery => {
                                // DATE_ADD(CAST('1970-01-01' AS DATE), INTERVAL n DAY)
                                let interval =
                                    Expression::Interval(Box::new(crate::expressions::Interval {
                                        this: Some(n),
                                        unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                            unit: crate::expressions::IntervalUnit::Day,
                                            use_plural: false,
                                        }),
                                    }));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "DATE_ADD".to_string(),
                                    vec![epoch_date, interval],
                                ))))
                            }
                            DialectType::MySQL
                            | DialectType::Doris
                            | DialectType::StarRocks
                            | DialectType::Drill => {
                                // DATE_ADD(CAST('1970-01-01' AS DATE), INTERVAL n DAY)
                                let interval =
                                    Expression::Interval(Box::new(crate::expressions::Interval {
                                        this: Some(n),
                                        unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                            unit: crate::expressions::IntervalUnit::Day,
                                            use_plural: false,
                                        }),
                                    }));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "DATE_ADD".to_string(),
                                    vec![epoch_date, interval],
                                ))))
                            }
                            DialectType::Hive | DialectType::Spark | DialectType::Databricks => {
                                // DATE_ADD(CAST('1970-01-01' AS DATE), n)
                                Ok(Expression::Function(Box::new(Function::new(
                                    "DATE_ADD".to_string(),
                                    vec![epoch_date, n],
                                ))))
                            }
                            DialectType::PostgreSQL
                            | DialectType::Materialize
                            | DialectType::RisingWave => {
                                // CAST('1970-01-01' AS DATE) + INTERVAL 'n DAY'
                                let n_str = match &n {
                                    Expression::Literal(Literal::Number(s)) => s.clone(),
                                    _ => Self::expr_to_string_static(&n),
                                };
                                let interval =
                                    Expression::Interval(Box::new(crate::expressions::Interval {
                                        this: Some(Expression::string(&format!("{} DAY", n_str))),
                                        unit: None,
                                    }));
                                Ok(Expression::Add(Box::new(
                                    crate::expressions::BinaryOp::new(epoch_date, interval),
                                )))
                            }
                            _ => {
                                // Default: keep as-is
                                Ok(Expression::Function(Box::new(Function::new(
                                    "DATE_FROM_UNIX_DATE".to_string(),
                                    vec![n],
                                ))))
                            }
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::ArrayRemoveConvert => {
                    // ARRAY_REMOVE(arr, target) -> LIST_FILTER/arrayFilter
                    if let Expression::ArrayRemove(bf) = e {
                        let arr = bf.this;
                        let target_val = bf.expression;
                        match target {
                            DialectType::DuckDB => {
                                let u_id = crate::expressions::Identifier::new("_u");
                                let lambda =
                                    Expression::Lambda(Box::new(crate::expressions::LambdaExpr {
                                        parameters: vec![u_id.clone()],
                                        body: Expression::Neq(Box::new(BinaryOp {
                                            left: Expression::Identifier(u_id),
                                            right: target_val,
                                            left_comments: Vec::new(),
                                            operator_comments: Vec::new(),
                                            trailing_comments: Vec::new(),
                                        })),
                                        colon: false,
                                        parameter_types: Vec::new(),
                                    }));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "LIST_FILTER".to_string(),
                                    vec![arr, lambda],
                                ))))
                            }
                            DialectType::ClickHouse => {
                                let u_id = crate::expressions::Identifier::new("_u");
                                let lambda =
                                    Expression::Lambda(Box::new(crate::expressions::LambdaExpr {
                                        parameters: vec![u_id.clone()],
                                        body: Expression::Neq(Box::new(BinaryOp {
                                            left: Expression::Identifier(u_id),
                                            right: target_val,
                                            left_comments: Vec::new(),
                                            operator_comments: Vec::new(),
                                            trailing_comments: Vec::new(),
                                        })),
                                        colon: false,
                                        parameter_types: Vec::new(),
                                    }));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "arrayFilter".to_string(),
                                    vec![lambda, arr],
                                ))))
                            }
                            DialectType::BigQuery => {
                                // ARRAY(SELECT _u FROM UNNEST(the_array) AS _u WHERE _u <> target)
                                let u_id = crate::expressions::Identifier::new("_u");
                                let u_col = Expression::Column(crate::expressions::Column {
                                    name: u_id.clone(),
                                    table: None,
                                    join_mark: false,
                                    trailing_comments: Vec::new(),
                                });
                                let unnest_expr =
                                    Expression::Unnest(Box::new(crate::expressions::UnnestFunc {
                                        this: arr,
                                        expressions: Vec::new(),
                                        with_ordinality: false,
                                        alias: None,
                                        offset_alias: None,
                                    }));
                                let aliased_unnest =
                                    Expression::Alias(Box::new(crate::expressions::Alias {
                                        this: unnest_expr,
                                        alias: u_id.clone(),
                                        column_aliases: Vec::new(),
                                        pre_alias_comments: Vec::new(),
                                        trailing_comments: Vec::new(),
                                    }));
                                let where_cond = Expression::Neq(Box::new(BinaryOp {
                                    left: u_col.clone(),
                                    right: target_val,
                                    left_comments: Vec::new(),
                                    operator_comments: Vec::new(),
                                    trailing_comments: Vec::new(),
                                }));
                                let subquery = Expression::Select(Box::new(
                                    crate::expressions::Select::new()
                                        .column(u_col)
                                        .from(aliased_unnest)
                                        .where_(where_cond),
                                ));
                                Ok(Expression::ArrayFunc(Box::new(
                                    crate::expressions::ArrayConstructor {
                                        expressions: vec![subquery],
                                        bracket_notation: false,
                                        use_list_keyword: false,
                                    },
                                )))
                            }
                            _ => Ok(Expression::ArrayRemove(Box::new(
                                crate::expressions::BinaryFunc {
                                    original_name: None,
                                    this: arr,
                                    expression: target_val,
                                },
                            ))),
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::ArrayReverseConvert => {
                    // ARRAY_REVERSE(x) -> arrayReverse(x) for ClickHouse
                    if let Expression::ArrayReverse(af) = e {
                        Ok(Expression::Function(Box::new(Function::new(
                            "arrayReverse".to_string(),
                            vec![af.this],
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::JsonKeysConvert => {
                    // JSON_KEYS(x) -> JSON_OBJECT_KEYS/OBJECT_KEYS
                    if let Expression::JsonKeys(uf) = e {
                        match target {
                            DialectType::Spark | DialectType::Databricks => {
                                Ok(Expression::Function(Box::new(Function::new(
                                    "JSON_OBJECT_KEYS".to_string(),
                                    vec![uf.this],
                                ))))
                            }
                            DialectType::Snowflake => Ok(Expression::Function(Box::new(
                                Function::new("OBJECT_KEYS".to_string(), vec![uf.this]),
                            ))),
                            _ => Ok(Expression::JsonKeys(uf)),
                        }
                    } else {
                        Ok(e)
                    }
                }

                Action::ParseJsonStrip => {
                    // PARSE_JSON(x) -> x (strip wrapper for SQLite/Doris)
                    if let Expression::ParseJson(uf) = e {
                        Ok(uf.this)
                    } else {
                        Ok(e)
                    }
                }

                Action::ArraySizeDrill => {
                    // ARRAY_SIZE(x) -> REPEATED_COUNT(x) for Drill
                    if let Expression::ArraySize(uf) = e {
                        Ok(Expression::Function(Box::new(Function::new(
                            "REPEATED_COUNT".to_string(),
                            vec![uf.this],
                        ))))
                    } else {
                        Ok(e)
                    }
                }

                Action::WeekOfYearToWeekIso => {
                    // WEEKOFYEAR(x) -> WEEKISO(x) for Snowflake (cross-dialect normalization)
                    if let Expression::WeekOfYear(uf) = e {
                        Ok(Expression::Function(Box::new(Function::new(
                            "WEEKISO".to_string(),
                            vec![uf.this],
                        ))))
                    } else {
                        Ok(e)
                    }
                }
            }
        })
    }

    /// Convert DATE_TRUNC('unit', x) to MySQL-specific expansion
    fn date_trunc_to_mysql(unit: &str, expr: &Expression) -> Result<Expression> {
        use crate::expressions::Function;
        match unit {
            "DAY" => {
                // DATE(x)
                Ok(Expression::Function(Box::new(Function::new(
                    "DATE".to_string(),
                    vec![expr.clone()],
                ))))
            }
            "WEEK" => {
                // STR_TO_DATE(CONCAT(YEAR(x), ' ', WEEK(x, 1), ' 1'), '%Y %u %w')
                let year_x = Expression::Function(Box::new(Function::new(
                    "YEAR".to_string(),
                    vec![expr.clone()],
                )));
                let week_x = Expression::Function(Box::new(Function::new(
                    "WEEK".to_string(),
                    vec![expr.clone(), Expression::number(1)],
                )));
                let concat_args = vec![
                    year_x,
                    Expression::string(" "),
                    week_x,
                    Expression::string(" 1"),
                ];
                let concat = Expression::Function(Box::new(Function::new(
                    "CONCAT".to_string(),
                    concat_args,
                )));
                Ok(Expression::Function(Box::new(Function::new(
                    "STR_TO_DATE".to_string(),
                    vec![concat, Expression::string("%Y %u %w")],
                ))))
            }
            "MONTH" => {
                // STR_TO_DATE(CONCAT(YEAR(x), ' ', MONTH(x), ' 1'), '%Y %c %e')
                let year_x = Expression::Function(Box::new(Function::new(
                    "YEAR".to_string(),
                    vec![expr.clone()],
                )));
                let month_x = Expression::Function(Box::new(Function::new(
                    "MONTH".to_string(),
                    vec![expr.clone()],
                )));
                let concat_args = vec![
                    year_x,
                    Expression::string(" "),
                    month_x,
                    Expression::string(" 1"),
                ];
                let concat = Expression::Function(Box::new(Function::new(
                    "CONCAT".to_string(),
                    concat_args,
                )));
                Ok(Expression::Function(Box::new(Function::new(
                    "STR_TO_DATE".to_string(),
                    vec![concat, Expression::string("%Y %c %e")],
                ))))
            }
            "QUARTER" => {
                // STR_TO_DATE(CONCAT(YEAR(x), ' ', QUARTER(x) * 3 - 2, ' 1'), '%Y %c %e')
                let year_x = Expression::Function(Box::new(Function::new(
                    "YEAR".to_string(),
                    vec![expr.clone()],
                )));
                let quarter_x = Expression::Function(Box::new(Function::new(
                    "QUARTER".to_string(),
                    vec![expr.clone()],
                )));
                // QUARTER(x) * 3 - 2
                let mul = Expression::Mul(Box::new(crate::expressions::BinaryOp {
                    left: quarter_x,
                    right: Expression::number(3),
                    left_comments: Vec::new(),
                    operator_comments: Vec::new(),
                    trailing_comments: Vec::new(),
                }));
                let sub = Expression::Sub(Box::new(crate::expressions::BinaryOp {
                    left: mul,
                    right: Expression::number(2),
                    left_comments: Vec::new(),
                    operator_comments: Vec::new(),
                    trailing_comments: Vec::new(),
                }));
                let concat_args = vec![
                    year_x,
                    Expression::string(" "),
                    sub,
                    Expression::string(" 1"),
                ];
                let concat = Expression::Function(Box::new(Function::new(
                    "CONCAT".to_string(),
                    concat_args,
                )));
                Ok(Expression::Function(Box::new(Function::new(
                    "STR_TO_DATE".to_string(),
                    vec![concat, Expression::string("%Y %c %e")],
                ))))
            }
            "YEAR" => {
                // STR_TO_DATE(CONCAT(YEAR(x), ' 1 1'), '%Y %c %e')
                let year_x = Expression::Function(Box::new(Function::new(
                    "YEAR".to_string(),
                    vec![expr.clone()],
                )));
                let concat_args = vec![year_x, Expression::string(" 1 1")];
                let concat = Expression::Function(Box::new(Function::new(
                    "CONCAT".to_string(),
                    concat_args,
                )));
                Ok(Expression::Function(Box::new(Function::new(
                    "STR_TO_DATE".to_string(),
                    vec![concat, Expression::string("%Y %c %e")],
                ))))
            }
            _ => {
                // Unsupported unit -> keep as DATE_TRUNC
                Ok(Expression::Function(Box::new(Function::new(
                    "DATE_TRUNC".to_string(),
                    vec![Expression::string(unit), expr.clone()],
                ))))
            }
        }
    }

    /// Check if a DataType is or contains VARCHAR/CHAR (for Spark VARCHAR->STRING normalization)
    fn has_varchar_char_type(dt: &crate::expressions::DataType) -> bool {
        use crate::expressions::DataType;
        match dt {
            DataType::VarChar { .. } | DataType::Char { .. } => true,
            DataType::Struct { fields, .. } => fields
                .iter()
                .any(|f| Self::has_varchar_char_type(&f.data_type)),
            _ => false,
        }
    }

    /// Recursively normalize VARCHAR/CHAR to STRING in a DataType (for Spark)
    fn normalize_varchar_to_string(
        dt: crate::expressions::DataType,
    ) -> crate::expressions::DataType {
        use crate::expressions::DataType;
        match dt {
            DataType::VarChar { .. } | DataType::Char { .. } => DataType::Custom {
                name: "STRING".to_string(),
            },
            DataType::Struct { fields, nested } => {
                let fields = fields
                    .into_iter()
                    .map(|mut f| {
                        f.data_type = Self::normalize_varchar_to_string(f.data_type);
                        f
                    })
                    .collect();
                DataType::Struct { fields, nested }
            }
            other => other,
        }
    }

    /// Normalize an interval string like '1day' or '  2   days  ' to proper INTERVAL expression
    fn normalize_interval_string(expr: Expression, target: DialectType) -> Expression {
        if let Expression::Literal(crate::expressions::Literal::String(ref s)) = expr {
            // Try to parse patterns like '1day', '1 day', '2 days', '  2   days  '
            let trimmed = s.trim();

            // Find where digits end and unit text begins
            let digit_end = trimmed
                .find(|c: char| !c.is_ascii_digit())
                .unwrap_or(trimmed.len());
            if digit_end == 0 || digit_end == trimmed.len() {
                return expr;
            }
            let num = &trimmed[..digit_end];
            let unit_text = trimmed[digit_end..].trim().to_uppercase();
            if unit_text.is_empty() {
                return expr;
            }

            let known_units = [
                "DAY", "DAYS", "HOUR", "HOURS", "MINUTE", "MINUTES", "SECOND", "SECONDS", "WEEK",
                "WEEKS", "MONTH", "MONTHS", "YEAR", "YEARS",
            ];
            if !known_units.contains(&unit_text.as_str()) {
                return expr;
            }

            let unit_str = unit_text.clone();
            // Singularize
            let unit_singular = if unit_str.ends_with('S') && unit_str.len() > 3 {
                &unit_str[..unit_str.len() - 1]
            } else {
                &unit_str
            };
            let unit = unit_singular;

            match target {
                DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                    // INTERVAL '2' DAY
                    let iu = match unit {
                        "DAY" => crate::expressions::IntervalUnit::Day,
                        "HOUR" => crate::expressions::IntervalUnit::Hour,
                        "MINUTE" => crate::expressions::IntervalUnit::Minute,
                        "SECOND" => crate::expressions::IntervalUnit::Second,
                        "WEEK" => crate::expressions::IntervalUnit::Week,
                        "MONTH" => crate::expressions::IntervalUnit::Month,
                        "YEAR" => crate::expressions::IntervalUnit::Year,
                        _ => return expr,
                    };
                    return Expression::Interval(Box::new(crate::expressions::Interval {
                        this: Some(Expression::string(num)),
                        unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                            unit: iu,
                            use_plural: false,
                        }),
                    }));
                }
                DialectType::PostgreSQL | DialectType::Redshift | DialectType::DuckDB => {
                    // INTERVAL '2 DAYS'
                    let plural = if num != "1" && !unit_str.ends_with('S') {
                        format!("{} {}S", num, unit)
                    } else if unit_str.ends_with('S') {
                        format!("{} {}", num, unit_str)
                    } else {
                        format!("{} {}", num, unit)
                    };
                    return Expression::Interval(Box::new(crate::expressions::Interval {
                        this: Some(Expression::string(&plural)),
                        unit: None,
                    }));
                }
                _ => {
                    // Spark/Databricks/Hive: INTERVAL '1' DAY
                    let iu = match unit {
                        "DAY" => crate::expressions::IntervalUnit::Day,
                        "HOUR" => crate::expressions::IntervalUnit::Hour,
                        "MINUTE" => crate::expressions::IntervalUnit::Minute,
                        "SECOND" => crate::expressions::IntervalUnit::Second,
                        "WEEK" => crate::expressions::IntervalUnit::Week,
                        "MONTH" => crate::expressions::IntervalUnit::Month,
                        "YEAR" => crate::expressions::IntervalUnit::Year,
                        _ => return expr,
                    };
                    return Expression::Interval(Box::new(crate::expressions::Interval {
                        this: Some(Expression::string(num)),
                        unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                            unit: iu,
                            use_plural: false,
                        }),
                    }));
                }
            }
        }
        // If it's already an INTERVAL expression, pass through
        expr
    }

    /// Rewrite SELECT expressions containing UNNEST into expanded form with CROSS JOINs.
    /// DuckDB: SELECT UNNEST(arr1), UNNEST(arr2) ->
    /// BigQuery: SELECT IF(pos = pos_2, col, NULL) AS col, ... FROM UNNEST(GENERATE_ARRAY(0, ...)) AS pos CROSS JOIN ...
    /// Presto:  SELECT IF(_u.pos = _u_2.pos_2, _u_2.col) AS col, ... FROM UNNEST(SEQUENCE(1, ...)) AS _u(pos) CROSS JOIN ...
    fn rewrite_unnest_expansion(
        select: &crate::expressions::Select,
        target: DialectType,
    ) -> Option<crate::expressions::Select> {
        use crate::expressions::{
            Alias, BinaryOp, Column, From, Function, Identifier, Join, JoinKind, Literal,
            UnnestFunc,
        };

        let index_offset: i64 = match target {
            DialectType::Presto | DialectType::Trino => 1,
            _ => 0, // BigQuery, Snowflake
        };

        let if_func_name = match target {
            DialectType::Snowflake => "IFF",
            _ => "IF",
        };

        let array_length_func = match target {
            DialectType::BigQuery => "ARRAY_LENGTH",
            DialectType::Presto | DialectType::Trino => "CARDINALITY",
            DialectType::Snowflake => "ARRAY_SIZE",
            _ => "ARRAY_LENGTH",
        };

        let use_table_aliases = matches!(
            target,
            DialectType::Presto | DialectType::Trino | DialectType::Snowflake
        );
        let null_third_arg = matches!(target, DialectType::BigQuery | DialectType::Snowflake);

        fn make_col(name: &str, table: Option<&str>) -> Expression {
            if let Some(tbl) = table {
                Expression::Column(Column {
                    name: Identifier::new(name.to_string()),
                    table: Some(Identifier::new(tbl.to_string())),
                    join_mark: false,
                    trailing_comments: Vec::new(),
                })
            } else {
                Expression::Identifier(Identifier::new(name.to_string()))
            }
        }

        fn make_join(this: Expression) -> Join {
            Join {
                this,
                on: None,
                using: Vec::new(),
                kind: JoinKind::Cross,
                use_inner_keyword: false,
                use_outer_keyword: false,
                deferred_condition: false,
                join_hint: None,
                match_condition: None,
                pivots: Vec::new(),
                comments: Vec::new(),
                nesting_group: 0,
                directed: false,
            }
        }

        // Collect UNNEST info from SELECT expressions
        struct UnnestInfo {
            arr_expr: Expression,
            col_alias: String,
            pos_alias: String,
            source_alias: String,
            original_expr: Expression,
            has_outer_alias: Option<String>,
        }

        let mut unnest_infos: Vec<UnnestInfo> = Vec::new();
        let mut col_counter = 0usize;
        let mut pos_counter = 1usize;
        let mut source_counter = 1usize;

        fn extract_unnest_arg(expr: &Expression) -> Option<Expression> {
            match expr {
                Expression::Unnest(u) => Some(u.this.clone()),
                Expression::Function(f)
                    if f.name.eq_ignore_ascii_case("UNNEST") && !f.args.is_empty() =>
                {
                    Some(f.args[0].clone())
                }
                Expression::Alias(a) => extract_unnest_arg(&a.this),
                Expression::Add(op)
                | Expression::Sub(op)
                | Expression::Mul(op)
                | Expression::Div(op) => {
                    extract_unnest_arg(&op.left).or_else(|| extract_unnest_arg(&op.right))
                }
                _ => None,
            }
        }

        fn get_alias_name(expr: &Expression) -> Option<String> {
            if let Expression::Alias(a) = expr {
                Some(a.alias.name.clone())
            } else {
                None
            }
        }

        for sel_expr in &select.expressions {
            if let Some(arr) = extract_unnest_arg(sel_expr) {
                col_counter += 1;
                pos_counter += 1;
                source_counter += 1;

                let col_alias = if col_counter == 1 {
                    "col".to_string()
                } else {
                    format!("col_{}", col_counter)
                };
                let pos_alias = format!("pos_{}", pos_counter);
                let source_alias = format!("_u_{}", source_counter);
                let has_outer_alias = get_alias_name(sel_expr);

                unnest_infos.push(UnnestInfo {
                    arr_expr: arr,
                    col_alias,
                    pos_alias,
                    source_alias,
                    original_expr: sel_expr.clone(),
                    has_outer_alias,
                });
            }
        }

        if unnest_infos.is_empty() {
            return None;
        }

        let series_alias = "pos".to_string();
        let series_source_alias = "_u".to_string();
        let tbl_ref = if use_table_aliases {
            Some(series_source_alias.as_str())
        } else {
            None
        };

        // Build new SELECT expressions
        let mut new_select_exprs = Vec::new();
        for info in &unnest_infos {
            let actual_col_name = info.has_outer_alias.as_ref().unwrap_or(&info.col_alias);
            let src_ref = if use_table_aliases {
                Some(info.source_alias.as_str())
            } else {
                None
            };

            let pos_col = make_col(&series_alias, tbl_ref);
            let unnest_pos_col = make_col(&info.pos_alias, src_ref);
            let col_ref = make_col(actual_col_name, src_ref);

            let eq_cond = Expression::Eq(Box::new(BinaryOp::new(
                pos_col.clone(),
                unnest_pos_col.clone(),
            )));
            let mut if_args = vec![eq_cond, col_ref];
            if null_third_arg {
                if_args.push(Expression::Null(crate::expressions::Null));
            }

            let if_expr =
                Expression::Function(Box::new(Function::new(if_func_name.to_string(), if_args)));
            let final_expr = Self::replace_unnest_with_if(&info.original_expr, &if_expr);

            new_select_exprs.push(Expression::Alias(Box::new(Alias::new(
                final_expr,
                Identifier::new(actual_col_name.clone()),
            ))));
        }

        // Build array size expressions for GREATEST
        let size_exprs: Vec<Expression> = unnest_infos
            .iter()
            .map(|info| {
                Expression::Function(Box::new(Function::new(
                    array_length_func.to_string(),
                    vec![info.arr_expr.clone()],
                )))
            })
            .collect();

        let greatest =
            Expression::Function(Box::new(Function::new("GREATEST".to_string(), size_exprs)));

        let series_end = if index_offset == 0 {
            Expression::Sub(Box::new(BinaryOp::new(
                greatest,
                Expression::Literal(Literal::Number("1".to_string())),
            )))
        } else {
            greatest
        };

        // Build the position array source
        let series_unnest_expr = match target {
            DialectType::BigQuery => {
                let gen_array = Expression::Function(Box::new(Function::new(
                    "GENERATE_ARRAY".to_string(),
                    vec![
                        Expression::Literal(Literal::Number("0".to_string())),
                        series_end,
                    ],
                )));
                Expression::Unnest(Box::new(UnnestFunc {
                    this: gen_array,
                    expressions: Vec::new(),
                    with_ordinality: false,
                    alias: None,
                    offset_alias: None,
                }))
            }
            DialectType::Presto | DialectType::Trino => {
                let sequence = Expression::Function(Box::new(Function::new(
                    "SEQUENCE".to_string(),
                    vec![
                        Expression::Literal(Literal::Number("1".to_string())),
                        series_end,
                    ],
                )));
                Expression::Unnest(Box::new(UnnestFunc {
                    this: sequence,
                    expressions: Vec::new(),
                    with_ordinality: false,
                    alias: None,
                    offset_alias: None,
                }))
            }
            DialectType::Snowflake => {
                let range_end = Expression::Add(Box::new(BinaryOp::new(
                    Expression::Paren(Box::new(crate::expressions::Paren {
                        this: series_end,
                        trailing_comments: Vec::new(),
                    })),
                    Expression::Literal(Literal::Number("1".to_string())),
                )));
                let gen_range = Expression::Function(Box::new(Function::new(
                    "ARRAY_GENERATE_RANGE".to_string(),
                    vec![
                        Expression::Literal(Literal::Number("0".to_string())),
                        range_end,
                    ],
                )));
                let flatten_arg =
                    Expression::NamedArgument(Box::new(crate::expressions::NamedArgument {
                        name: Identifier::new("INPUT".to_string()),
                        value: gen_range,
                        separator: crate::expressions::NamedArgSeparator::DArrow,
                    }));
                let flatten = Expression::Function(Box::new(Function::new(
                    "FLATTEN".to_string(),
                    vec![flatten_arg],
                )));
                Expression::Function(Box::new(Function::new("TABLE".to_string(), vec![flatten])))
            }
            _ => return None,
        };

        // Build series alias expression
        let series_alias_expr = if use_table_aliases {
            let col_aliases = if matches!(target, DialectType::Snowflake) {
                vec![
                    Identifier::new("seq".to_string()),
                    Identifier::new("key".to_string()),
                    Identifier::new("path".to_string()),
                    Identifier::new("index".to_string()),
                    Identifier::new(series_alias.clone()),
                    Identifier::new("this".to_string()),
                ]
            } else {
                vec![Identifier::new(series_alias.clone())]
            };
            Expression::Alias(Box::new(Alias {
                this: series_unnest_expr,
                alias: Identifier::new(series_source_alias.clone()),
                column_aliases: col_aliases,
                pre_alias_comments: Vec::new(),
                trailing_comments: Vec::new(),
            }))
        } else {
            Expression::Alias(Box::new(Alias::new(
                series_unnest_expr,
                Identifier::new(series_alias.clone()),
            )))
        };

        // Build CROSS JOINs for each UNNEST
        let mut joins = Vec::new();
        for info in &unnest_infos {
            let actual_col_name = info.has_outer_alias.as_ref().unwrap_or(&info.col_alias);

            let unnest_join_expr = match target {
                DialectType::BigQuery => {
                    // UNNEST([1,2,3]) AS col WITH OFFSET AS pos_2
                    let unnest = UnnestFunc {
                        this: info.arr_expr.clone(),
                        expressions: Vec::new(),
                        with_ordinality: true,
                        alias: Some(Identifier::new(actual_col_name.clone())),
                        offset_alias: Some(Identifier::new(info.pos_alias.clone())),
                    };
                    Expression::Unnest(Box::new(unnest))
                }
                DialectType::Presto | DialectType::Trino => {
                    let unnest = UnnestFunc {
                        this: info.arr_expr.clone(),
                        expressions: Vec::new(),
                        with_ordinality: true,
                        alias: None,
                        offset_alias: None,
                    };
                    Expression::Alias(Box::new(Alias {
                        this: Expression::Unnest(Box::new(unnest)),
                        alias: Identifier::new(info.source_alias.clone()),
                        column_aliases: vec![
                            Identifier::new(actual_col_name.clone()),
                            Identifier::new(info.pos_alias.clone()),
                        ],
                        pre_alias_comments: Vec::new(),
                        trailing_comments: Vec::new(),
                    }))
                }
                DialectType::Snowflake => {
                    let flatten_arg =
                        Expression::NamedArgument(Box::new(crate::expressions::NamedArgument {
                            name: Identifier::new("INPUT".to_string()),
                            value: info.arr_expr.clone(),
                            separator: crate::expressions::NamedArgSeparator::DArrow,
                        }));
                    let flatten = Expression::Function(Box::new(Function::new(
                        "FLATTEN".to_string(),
                        vec![flatten_arg],
                    )));
                    let table_fn = Expression::Function(Box::new(Function::new(
                        "TABLE".to_string(),
                        vec![flatten],
                    )));
                    Expression::Alias(Box::new(Alias {
                        this: table_fn,
                        alias: Identifier::new(info.source_alias.clone()),
                        column_aliases: vec![
                            Identifier::new("seq".to_string()),
                            Identifier::new("key".to_string()),
                            Identifier::new("path".to_string()),
                            Identifier::new(info.pos_alias.clone()),
                            Identifier::new(actual_col_name.clone()),
                            Identifier::new("this".to_string()),
                        ],
                        pre_alias_comments: Vec::new(),
                        trailing_comments: Vec::new(),
                    }))
                }
                _ => return None,
            };

            joins.push(make_join(unnest_join_expr));
        }

        // Build WHERE clause
        let mut where_conditions: Vec<Expression> = Vec::new();
        for info in &unnest_infos {
            let src_ref = if use_table_aliases {
                Some(info.source_alias.as_str())
            } else {
                None
            };
            let pos_col = make_col(&series_alias, tbl_ref);
            let unnest_pos_col = make_col(&info.pos_alias, src_ref);

            let arr_size = Expression::Function(Box::new(Function::new(
                array_length_func.to_string(),
                vec![info.arr_expr.clone()],
            )));

            let size_ref = if index_offset == 0 {
                Expression::Paren(Box::new(crate::expressions::Paren {
                    this: Expression::Sub(Box::new(BinaryOp::new(
                        arr_size,
                        Expression::Literal(Literal::Number("1".to_string())),
                    ))),
                    trailing_comments: Vec::new(),
                }))
            } else {
                arr_size
            };

            let eq = Expression::Eq(Box::new(BinaryOp::new(
                pos_col.clone(),
                unnest_pos_col.clone(),
            )));
            let gt = Expression::Gt(Box::new(BinaryOp::new(pos_col, size_ref.clone())));
            let pos_eq_size = Expression::Eq(Box::new(BinaryOp::new(unnest_pos_col, size_ref)));
            let and_cond = Expression::And(Box::new(BinaryOp::new(gt, pos_eq_size)));
            let paren_and = Expression::Paren(Box::new(crate::expressions::Paren {
                this: and_cond,
                trailing_comments: Vec::new(),
            }));
            let or_cond = Expression::Or(Box::new(BinaryOp::new(eq, paren_and)));

            where_conditions.push(or_cond);
        }

        let where_expr = if where_conditions.len() == 1 {
            // Single condition: no parens needed
            where_conditions.into_iter().next().unwrap()
        } else {
            // Multiple conditions: wrap each OR in parens, then combine with AND
            let wrap = |e: Expression| {
                Expression::Paren(Box::new(crate::expressions::Paren {
                    this: e,
                    trailing_comments: Vec::new(),
                }))
            };
            let mut iter = where_conditions.into_iter();
            let first = wrap(iter.next().unwrap());
            let second = wrap(iter.next().unwrap());
            let mut combined = Expression::Paren(Box::new(crate::expressions::Paren {
                this: Expression::And(Box::new(BinaryOp::new(first, second))),
                trailing_comments: Vec::new(),
            }));
            for cond in iter {
                combined = Expression::And(Box::new(BinaryOp::new(combined, wrap(cond))));
            }
            combined
        };

        // Build the new SELECT
        let mut new_select = select.clone();
        new_select.expressions = new_select_exprs;

        if new_select.from.is_some() {
            let mut all_joins = vec![make_join(series_alias_expr)];
            all_joins.extend(joins);
            new_select.joins.extend(all_joins);
        } else {
            new_select.from = Some(From {
                expressions: vec![series_alias_expr],
            });
            new_select.joins.extend(joins);
        }

        if let Some(ref existing_where) = new_select.where_clause {
            let combined = Expression::And(Box::new(BinaryOp::new(
                existing_where.this.clone(),
                where_expr,
            )));
            new_select.where_clause = Some(crate::expressions::Where { this: combined });
        } else {
            new_select.where_clause = Some(crate::expressions::Where { this: where_expr });
        }

        Some(new_select)
    }

    /// Helper to replace UNNEST(...) inside an expression with a replacement expression.
    fn replace_unnest_with_if(original: &Expression, replacement: &Expression) -> Expression {
        match original {
            Expression::Unnest(_) => replacement.clone(),
            Expression::Function(f) if f.name.eq_ignore_ascii_case("UNNEST") => replacement.clone(),
            Expression::Alias(a) => Self::replace_unnest_with_if(&a.this, replacement),
            Expression::Add(op) => {
                let left = Self::replace_unnest_with_if(&op.left, replacement);
                let right = Self::replace_unnest_with_if(&op.right, replacement);
                Expression::Add(Box::new(crate::expressions::BinaryOp::new(left, right)))
            }
            Expression::Sub(op) => {
                let left = Self::replace_unnest_with_if(&op.left, replacement);
                let right = Self::replace_unnest_with_if(&op.right, replacement);
                Expression::Sub(Box::new(crate::expressions::BinaryOp::new(left, right)))
            }
            Expression::Mul(op) => {
                let left = Self::replace_unnest_with_if(&op.left, replacement);
                let right = Self::replace_unnest_with_if(&op.right, replacement);
                Expression::Mul(Box::new(crate::expressions::BinaryOp::new(left, right)))
            }
            Expression::Div(op) => {
                let left = Self::replace_unnest_with_if(&op.left, replacement);
                let right = Self::replace_unnest_with_if(&op.right, replacement);
                Expression::Div(Box::new(crate::expressions::BinaryOp::new(left, right)))
            }
            _ => original.clone(),
        }
    }

    /// Decompose a JSON path like `$.y[0].z` into individual parts: `["y", "0", "z"]`.
    /// Strips `$` prefix, handles bracket notation, quoted strings, and removes `[*]` wildcards.
    fn decompose_json_path(path: &str) -> Vec<String> {
        let mut parts = Vec::new();
        let path = if path.starts_with("$.") {
            &path[2..]
        } else if path.starts_with('$') {
            &path[1..]
        } else {
            path
        };
        if path.is_empty() {
            return parts;
        }
        let mut current = String::new();
        let chars: Vec<char> = path.chars().collect();
        let mut i = 0;
        while i < chars.len() {
            match chars[i] {
                '.' => {
                    if !current.is_empty() {
                        parts.push(current.clone());
                        current.clear();
                    }
                    i += 1;
                }
                '[' => {
                    if !current.is_empty() {
                        parts.push(current.clone());
                        current.clear();
                    }
                    i += 1;
                    let mut bracket_content = String::new();
                    while i < chars.len() && chars[i] != ']' {
                        if chars[i] == '"' || chars[i] == '\'' {
                            let quote = chars[i];
                            i += 1;
                            while i < chars.len() && chars[i] != quote {
                                bracket_content.push(chars[i]);
                                i += 1;
                            }
                            if i < chars.len() {
                                i += 1;
                            }
                        } else {
                            bracket_content.push(chars[i]);
                            i += 1;
                        }
                    }
                    if i < chars.len() {
                        i += 1;
                    }
                    if bracket_content != "*" {
                        parts.push(bracket_content);
                    }
                }
                _ => {
                    current.push(chars[i]);
                    i += 1;
                }
            }
        }
        if !current.is_empty() {
            parts.push(current);
        }
        parts
    }

    /// Strip `$` prefix from a JSON path, keeping the rest.
    /// `$.y[0].z` -> `y[0].z`, `$["a b"]` -> `["a b"]`
    fn strip_json_dollar_prefix(path: &str) -> String {
        if path.starts_with("$.") {
            path[2..].to_string()
        } else if path.starts_with('$') {
            path[1..].to_string()
        } else {
            path.to_string()
        }
    }

    /// Strip `[*]` wildcards from a JSON path.
    /// `$.y[*]` -> `$.y`, `$.y[*].z` -> `$.y.z`
    fn strip_json_wildcards(path: &str) -> String {
        path.replace("[*]", "")
            .replace("..", ".") // Clean double dots from `$.y[*].z` -> `$.y..z`
            .trim_end_matches('.')
            .to_string()
    }

    /// Convert bracket notation to dot notation for JSON paths.
    /// `$["a b"]` -> `$."a b"`, `$["key"]` -> `$.key`
    fn bracket_to_dot_notation(path: &str) -> String {
        let mut result = String::new();
        let chars: Vec<char> = path.chars().collect();
        let mut i = 0;
        while i < chars.len() {
            if chars[i] == '[' {
                // Read bracket content
                i += 1;
                let mut bracket_content = String::new();
                let mut is_quoted = false;
                let mut _quote_char = '"';
                while i < chars.len() && chars[i] != ']' {
                    if chars[i] == '"' || chars[i] == '\'' {
                        is_quoted = true;
                        _quote_char = chars[i];
                        i += 1;
                        while i < chars.len() && chars[i] != _quote_char {
                            bracket_content.push(chars[i]);
                            i += 1;
                        }
                        if i < chars.len() {
                            i += 1;
                        }
                    } else {
                        bracket_content.push(chars[i]);
                        i += 1;
                    }
                }
                if i < chars.len() {
                    i += 1;
                } // skip ]
                if bracket_content == "*" {
                    // Keep wildcard as-is
                    result.push_str("[*]");
                } else if is_quoted {
                    // Quoted bracket -> dot notation with quotes
                    result.push('.');
                    result.push('"');
                    result.push_str(&bracket_content);
                    result.push('"');
                } else {
                    // Numeric index -> keep as bracket
                    result.push('[');
                    result.push_str(&bracket_content);
                    result.push(']');
                }
            } else {
                result.push(chars[i]);
                i += 1;
            }
        }
        result
    }

    /// Convert JSON path bracket quoted strings to use single quotes instead of double quotes.
    /// `$["a b"]` -> `$['a b']`
    fn bracket_to_single_quotes(path: &str) -> String {
        let mut result = String::new();
        let chars: Vec<char> = path.chars().collect();
        let mut i = 0;
        while i < chars.len() {
            if chars[i] == '[' && i + 1 < chars.len() && chars[i + 1] == '"' {
                result.push('[');
                result.push('\'');
                i += 2; // skip [ and "
                while i < chars.len() && chars[i] != '"' {
                    result.push(chars[i]);
                    i += 1;
                }
                if i < chars.len() {
                    i += 1;
                } // skip closing "
                result.push('\'');
            } else {
                result.push(chars[i]);
                i += 1;
            }
        }
        result
    }

    /// Transform TSQL SELECT INTO -> CREATE TABLE AS for DuckDB/Snowflake
    /// or PostgreSQL #temp -> TEMPORARY.
    /// Also strips # from INSERT INTO #table for non-TSQL targets.
    fn transform_select_into(
        expr: Expression,
        _source: DialectType,
        target: DialectType,
    ) -> Expression {
        use crate::expressions::{CreateTable, Expression, TableRef};

        // Handle INSERT INTO #temp -> INSERT INTO temp for non-TSQL targets
        if let Expression::Insert(ref insert) = expr {
            if insert.table.name.name.starts_with('#')
                && !matches!(target, DialectType::TSQL | DialectType::Fabric)
            {
                let mut new_insert = insert.clone();
                new_insert.table.name.name =
                    insert.table.name.name.trim_start_matches('#').to_string();
                return Expression::Insert(new_insert);
            }
            return expr;
        }

        if let Expression::Select(ref select) = expr {
            if let Some(ref into) = select.into {
                let table_name_raw = match &into.this {
                    Expression::Table(tr) => tr.name.name.clone(),
                    Expression::Identifier(id) => id.name.clone(),
                    _ => String::new(),
                };
                let is_temp = table_name_raw.starts_with('#') || into.temporary;
                let clean_name = table_name_raw.trim_start_matches('#').to_string();

                match target {
                    DialectType::DuckDB | DialectType::Snowflake => {
                        // SELECT INTO -> CREATE TABLE AS SELECT
                        let mut new_select = select.clone();
                        new_select.into = None;
                        let ct = CreateTable {
                            name: TableRef::new(clean_name),
                            on_cluster: None,
                            columns: Vec::new(),
                            constraints: Vec::new(),
                            if_not_exists: false,
                            temporary: is_temp,
                            or_replace: false,
                            table_modifier: None,
                            as_select: Some(Expression::Select(new_select)),
                            as_select_parenthesized: false,
                            on_commit: None,
                            clone_source: None,
                            clone_at_clause: None,
                            shallow_clone: false,
                            is_copy: false,
                            leading_comments: Vec::new(),
                            with_properties: Vec::new(),
                            teradata_post_name_options: Vec::new(),
                            with_data: None,
                            with_statistics: None,
                            teradata_indexes: Vec::new(),
                            with_cte: None,
                            properties: Vec::new(),
                            partition_of: None,
                            post_table_properties: Vec::new(),
                            mysql_table_options: Vec::new(),
                            inherits: Vec::new(),
                            on_property: None,
                            copy_grants: false,
                            using_template: None,
                            rollup: None,
                        };
                        return Expression::CreateTable(Box::new(ct));
                    }
                    DialectType::PostgreSQL | DialectType::Redshift => {
                        // PostgreSQL: #foo -> INTO TEMPORARY foo
                        if is_temp && !into.temporary {
                            let mut new_select = select.clone();
                            let mut new_into = into.clone();
                            new_into.temporary = true;
                            new_into.unlogged = false;
                            new_into.this = Expression::Table(TableRef::new(clean_name));
                            new_select.into = Some(new_into);
                            Expression::Select(new_select)
                        } else {
                            expr
                        }
                    }
                    _ => expr,
                }
            } else {
                expr
            }
        } else {
            expr
        }
    }

    /// Transform CREATE TABLE WITH properties for cross-dialect transpilation.
    /// Handles FORMAT, PARTITIONED_BY, and other Presto WITH properties.
    fn transform_create_table_properties(
        ct: &mut crate::expressions::CreateTable,
        _source: DialectType,
        target: DialectType,
    ) {
        use crate::expressions::{
            BinaryOp, BooleanLiteral, Expression, FileFormatProperty, Identifier, Literal,
            Properties,
        };

        // Helper to convert a raw property value string to the correct Expression
        let value_to_expr = |v: &str| -> Expression {
            let trimmed = v.trim();
            // Check if it's a quoted string (starts and ends with ')
            if trimmed.starts_with('\'') && trimmed.ends_with('\'') {
                Expression::Literal(Literal::String(trimmed[1..trimmed.len() - 1].to_string()))
            }
            // Check if it's a number
            else if trimmed.parse::<i64>().is_ok() || trimmed.parse::<f64>().is_ok() {
                Expression::Literal(Literal::Number(trimmed.to_string()))
            }
            // Check if it's ARRAY[...] or ARRAY(...)
            else if trimmed.to_uppercase().starts_with("ARRAY") {
                // Convert ARRAY['y'] to ARRAY('y') for Hive/Spark
                let inner = trimmed
                    .trim_start_matches(|c: char| c.is_alphabetic()) // Remove ARRAY
                    .trim_start_matches('[')
                    .trim_start_matches('(')
                    .trim_end_matches(']')
                    .trim_end_matches(')');
                let elements: Vec<Expression> = inner
                    .split(',')
                    .map(|e| {
                        let elem = e.trim().trim_matches('\'');
                        Expression::Literal(Literal::String(elem.to_string()))
                    })
                    .collect();
                Expression::Function(Box::new(crate::expressions::Function::new(
                    "ARRAY".to_string(),
                    elements,
                )))
            }
            // Otherwise, just output as identifier (unquoted)
            else {
                Expression::Identifier(Identifier::new(trimmed.to_string()))
            }
        };

        if ct.with_properties.is_empty() && ct.properties.is_empty() {
            return;
        }

        // Handle Presto-style WITH properties
        if !ct.with_properties.is_empty() {
            // Extract FORMAT property and remaining properties
            let mut format_value: Option<String> = None;
            let mut partitioned_by: Option<String> = None;
            let mut other_props: Vec<(String, String)> = Vec::new();

            for (key, value) in ct.with_properties.drain(..) {
                let key_upper = key.to_uppercase();
                if key_upper == "FORMAT" {
                    // Strip surrounding quotes from value if present
                    format_value = Some(value.trim_matches('\'').to_string());
                } else if key_upper == "PARTITIONED_BY" {
                    partitioned_by = Some(value);
                } else {
                    other_props.push((key, value));
                }
            }

            match target {
                DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                    // Presto: keep WITH properties but lowercase 'format' key
                    if let Some(fmt) = format_value {
                        ct.with_properties
                            .push(("format".to_string(), format!("'{}'", fmt)));
                    }
                    if let Some(part) = partitioned_by {
                        // Convert (col1, col2) to ARRAY['col1', 'col2'] format
                        let trimmed = part.trim();
                        let inner = trimmed.trim_start_matches('(').trim_end_matches(')');
                        // Also handle ARRAY['...'] format - keep as-is
                        if trimmed.to_uppercase().starts_with("ARRAY") {
                            ct.with_properties
                                .push(("PARTITIONED_BY".to_string(), part));
                        } else {
                            // Parse column names from the parenthesized list
                            let cols: Vec<&str> = inner
                                .split(',')
                                .map(|c| c.trim().trim_matches('"').trim_matches('\''))
                                .collect();
                            let array_val = format!(
                                "ARRAY[{}]",
                                cols.iter()
                                    .map(|c| format!("'{}'", c))
                                    .collect::<Vec<_>>()
                                    .join(", ")
                            );
                            ct.with_properties
                                .push(("PARTITIONED_BY".to_string(), array_val));
                        }
                    }
                    ct.with_properties.extend(other_props);
                }
                DialectType::Hive => {
                    // Hive: FORMAT -> STORED AS, other props -> TBLPROPERTIES
                    if let Some(fmt) = format_value {
                        ct.properties.push(Expression::FileFormatProperty(Box::new(
                            FileFormatProperty {
                                this: Some(Box::new(Expression::Identifier(Identifier::new(fmt)))),
                                expressions: vec![],
                                hive_format: Some(Box::new(Expression::Boolean(BooleanLiteral {
                                    value: true,
                                }))),
                            },
                        )));
                    }
                    if let Some(_part) = partitioned_by {
                        // PARTITIONED_BY handling is complex - move columns to partitioned by
                        // For now, the partition columns are extracted from the column list
                        Self::apply_partitioned_by(ct, &_part, target);
                    }
                    if !other_props.is_empty() {
                        let eq_exprs: Vec<Expression> = other_props
                            .into_iter()
                            .map(|(k, v)| {
                                Expression::Eq(Box::new(BinaryOp::new(
                                    Expression::Literal(Literal::String(k)),
                                    value_to_expr(&v),
                                )))
                            })
                            .collect();
                        ct.properties
                            .push(Expression::Properties(Box::new(Properties {
                                expressions: eq_exprs,
                            })));
                    }
                }
                DialectType::Spark | DialectType::Databricks => {
                    // Spark: FORMAT -> USING, other props -> TBLPROPERTIES
                    if let Some(fmt) = format_value {
                        ct.properties.push(Expression::FileFormatProperty(Box::new(
                            FileFormatProperty {
                                this: Some(Box::new(Expression::Identifier(Identifier::new(fmt)))),
                                expressions: vec![],
                                hive_format: None, // None means USING syntax
                            },
                        )));
                    }
                    if let Some(_part) = partitioned_by {
                        Self::apply_partitioned_by(ct, &_part, target);
                    }
                    if !other_props.is_empty() {
                        let eq_exprs: Vec<Expression> = other_props
                            .into_iter()
                            .map(|(k, v)| {
                                Expression::Eq(Box::new(BinaryOp::new(
                                    Expression::Literal(Literal::String(k)),
                                    value_to_expr(&v),
                                )))
                            })
                            .collect();
                        ct.properties
                            .push(Expression::Properties(Box::new(Properties {
                                expressions: eq_exprs,
                            })));
                    }
                }
                DialectType::DuckDB => {
                    // DuckDB: strip all WITH properties (FORMAT, PARTITIONED_BY, etc.)
                    // Keep nothing
                }
                _ => {
                    // For other dialects, keep WITH properties as-is
                    if let Some(fmt) = format_value {
                        ct.with_properties
                            .push(("FORMAT".to_string(), format!("'{}'", fmt)));
                    }
                    if let Some(part) = partitioned_by {
                        ct.with_properties
                            .push(("PARTITIONED_BY".to_string(), part));
                    }
                    ct.with_properties.extend(other_props);
                }
            }
        }

        // Handle STORED AS 'PARQUET' (quoted format name) -> STORED AS PARQUET (unquoted)
        // and Hive STORED AS -> Presto WITH (format=...) conversion
        if !ct.properties.is_empty() {
            let is_presto_target = matches!(
                target,
                DialectType::Presto | DialectType::Trino | DialectType::Athena
            );
            let is_duckdb_target = matches!(target, DialectType::DuckDB);

            if is_presto_target || is_duckdb_target {
                let mut new_properties = Vec::new();
                for prop in ct.properties.drain(..) {
                    match &prop {
                        Expression::FileFormatProperty(ffp) => {
                            if is_presto_target {
                                // Convert STORED AS/USING to WITH (format=...)
                                if let Some(ref fmt_expr) = ffp.this {
                                    let fmt_str = match fmt_expr.as_ref() {
                                        Expression::Identifier(id) => id.name.clone(),
                                        Expression::Literal(Literal::String(s)) => s.clone(),
                                        _ => {
                                            new_properties.push(prop);
                                            continue;
                                        }
                                    };
                                    ct.with_properties
                                        .push(("format".to_string(), format!("'{}'", fmt_str)));
                                }
                            }
                            // DuckDB: just strip file format properties
                        }
                        // Convert TBLPROPERTIES to WITH properties for Presto target
                        Expression::Properties(props) if is_presto_target => {
                            for expr in &props.expressions {
                                if let Expression::Eq(eq) = expr {
                                    // Extract key and value from the Eq expression
                                    let key = match &eq.left {
                                        Expression::Literal(Literal::String(s)) => s.clone(),
                                        Expression::Identifier(id) => id.name.clone(),
                                        _ => continue,
                                    };
                                    let value = match &eq.right {
                                        Expression::Literal(Literal::String(s)) => {
                                            format!("'{}'", s)
                                        }
                                        Expression::Literal(Literal::Number(n)) => n.clone(),
                                        Expression::Identifier(id) => id.name.clone(),
                                        _ => continue,
                                    };
                                    ct.with_properties.push((key, value));
                                }
                            }
                        }
                        // Convert PartitionedByProperty for Presto target
                        Expression::PartitionedByProperty(ref pbp) if is_presto_target => {
                            // Check if it contains ColumnDef expressions (Hive-style with types)
                            if let Expression::Tuple(ref tuple) = *pbp.this {
                                let mut col_names: Vec<String> = Vec::new();
                                let mut col_defs: Vec<crate::expressions::ColumnDef> = Vec::new();
                                let mut has_col_defs = false;
                                for expr in &tuple.expressions {
                                    if let Expression::ColumnDef(ref cd) = expr {
                                        has_col_defs = true;
                                        col_names.push(cd.name.name.clone());
                                        col_defs.push(*cd.clone());
                                    } else if let Expression::Column(ref col) = expr {
                                        col_names.push(col.name.name.clone());
                                    } else if let Expression::Identifier(ref id) = expr {
                                        col_names.push(id.name.clone());
                                    } else {
                                        // For function expressions like MONTHS(y), serialize to SQL
                                        let generic = Dialect::get(DialectType::Generic);
                                        if let Ok(sql) = generic.generate(expr) {
                                            col_names.push(sql);
                                        }
                                    }
                                }
                                if has_col_defs {
                                    // Merge partition column defs into the main column list
                                    for cd in col_defs {
                                        ct.columns.push(cd);
                                    }
                                }
                                if !col_names.is_empty() {
                                    // Add PARTITIONED_BY property
                                    let array_val = format!(
                                        "ARRAY[{}]",
                                        col_names
                                            .iter()
                                            .map(|n| format!("'{}'", n))
                                            .collect::<Vec<_>>()
                                            .join(", ")
                                    );
                                    ct.with_properties
                                        .push(("PARTITIONED_BY".to_string(), array_val));
                                }
                            }
                            // Skip - don't keep in properties
                        }
                        _ => {
                            if !is_duckdb_target {
                                new_properties.push(prop);
                            }
                        }
                    }
                }
                ct.properties = new_properties;
            } else {
                // For Hive/Spark targets, unquote format names in STORED AS
                for prop in &mut ct.properties {
                    if let Expression::FileFormatProperty(ref mut ffp) = prop {
                        if let Some(ref mut fmt_expr) = ffp.this {
                            if let Expression::Literal(Literal::String(s)) = fmt_expr.as_ref() {
                                // Convert STORED AS 'PARQUET' to STORED AS PARQUET (unquote)
                                let unquoted = s.clone();
                                *fmt_expr =
                                    Box::new(Expression::Identifier(Identifier::new(unquoted)));
                            }
                        }
                    }
                }
            }
        }
    }

    /// Apply PARTITIONED_BY conversion: move partition columns from column list to PARTITIONED BY
    fn apply_partitioned_by(
        ct: &mut crate::expressions::CreateTable,
        partitioned_by_value: &str,
        target: DialectType,
    ) {
        use crate::expressions::{Column, Expression, Identifier, PartitionedByProperty, Tuple};

        // Parse the ARRAY['col1', 'col2'] value to extract column names
        let mut col_names: Vec<String> = Vec::new();
        // The value looks like ARRAY['y', 'z'] or ARRAY('y', 'z')
        let inner = partitioned_by_value
            .trim()
            .trim_start_matches("ARRAY")
            .trim_start_matches('[')
            .trim_start_matches('(')
            .trim_end_matches(']')
            .trim_end_matches(')');
        for part in inner.split(',') {
            let col = part.trim().trim_matches('\'').trim_matches('"');
            if !col.is_empty() {
                col_names.push(col.to_string());
            }
        }

        if col_names.is_empty() {
            return;
        }

        if matches!(target, DialectType::Hive) {
            // Hive: PARTITIONED BY (col_name type, ...) - move columns out of column list
            let mut partition_col_defs = Vec::new();
            for col_name in &col_names {
                // Find and remove from columns
                if let Some(pos) = ct
                    .columns
                    .iter()
                    .position(|c| c.name.name.eq_ignore_ascii_case(col_name))
                {
                    let col_def = ct.columns.remove(pos);
                    partition_col_defs.push(Expression::ColumnDef(Box::new(col_def)));
                }
            }
            if !partition_col_defs.is_empty() {
                ct.properties
                    .push(Expression::PartitionedByProperty(Box::new(
                        PartitionedByProperty {
                            this: Box::new(Expression::Tuple(Box::new(Tuple {
                                expressions: partition_col_defs,
                            }))),
                        },
                    )));
            }
        } else if matches!(target, DialectType::Spark | DialectType::Databricks) {
            // Spark: PARTITIONED BY (col1, col2) - just column names, keep in column list
            // Use quoted identifiers to match the quoting style of the original column definitions
            let partition_exprs: Vec<Expression> = col_names
                .iter()
                .map(|name| {
                    // Check if the column exists in the column list and use its quoting
                    let is_quoted = ct
                        .columns
                        .iter()
                        .any(|c| c.name.name.eq_ignore_ascii_case(name) && c.name.quoted);
                    let ident = if is_quoted {
                        Identifier::quoted(name.clone())
                    } else {
                        Identifier::new(name.clone())
                    };
                    Expression::Column(Column {
                        name: ident,
                        table: None,
                        join_mark: false,
                        trailing_comments: Vec::new(),
                    })
                })
                .collect();
            ct.properties
                .push(Expression::PartitionedByProperty(Box::new(
                    PartitionedByProperty {
                        this: Box::new(Expression::Tuple(Box::new(Tuple {
                            expressions: partition_exprs,
                        }))),
                    },
                )));
        }
        // DuckDB: strip partitioned_by entirely (already handled)
    }

    /// Convert a DataType to Spark's type string format (using angle brackets)
    fn data_type_to_spark_string(dt: &crate::expressions::DataType) -> String {
        use crate::expressions::DataType;
        match dt {
            DataType::Int { .. } => "INT".to_string(),
            DataType::BigInt { .. } => "BIGINT".to_string(),
            DataType::SmallInt { .. } => "SMALLINT".to_string(),
            DataType::TinyInt { .. } => "TINYINT".to_string(),
            DataType::Float { .. } => "FLOAT".to_string(),
            DataType::Double { .. } => "DOUBLE".to_string(),
            DataType::Decimal {
                precision: Some(p),
                scale: Some(s),
            } => format!("DECIMAL({}, {})", p, s),
            DataType::Decimal {
                precision: Some(p), ..
            } => format!("DECIMAL({})", p),
            DataType::Decimal { .. } => "DECIMAL".to_string(),
            DataType::VarChar { .. } | DataType::Text | DataType::String { .. } => {
                "STRING".to_string()
            }
            DataType::Char { .. } => "STRING".to_string(),
            DataType::Boolean => "BOOLEAN".to_string(),
            DataType::Date => "DATE".to_string(),
            DataType::Timestamp { .. } => "TIMESTAMP".to_string(),
            DataType::Json | DataType::JsonB => "STRING".to_string(),
            DataType::Binary { .. } => "BINARY".to_string(),
            DataType::Array { element_type, .. } => {
                format!("ARRAY<{}>", Self::data_type_to_spark_string(element_type))
            }
            DataType::Map {
                key_type,
                value_type,
            } => format!(
                "MAP<{}, {}>",
                Self::data_type_to_spark_string(key_type),
                Self::data_type_to_spark_string(value_type)
            ),
            DataType::Struct { fields, .. } => {
                let field_strs: Vec<String> = fields
                    .iter()
                    .map(|f| {
                        if f.name.is_empty() {
                            Self::data_type_to_spark_string(&f.data_type)
                        } else {
                            format!(
                                "{}: {}",
                                f.name,
                                Self::data_type_to_spark_string(&f.data_type)
                            )
                        }
                    })
                    .collect();
                format!("STRUCT<{}>", field_strs.join(", "))
            }
            DataType::Custom { name } => name.clone(),
            _ => format!("{:?}", dt),
        }
    }

    /// Extract value and unit from an Interval expression
    /// Returns (value_expression, IntervalUnit)
    fn extract_interval_parts(
        interval_expr: &Expression,
    ) -> (Expression, crate::expressions::IntervalUnit) {
        use crate::expressions::{IntervalUnit, IntervalUnitSpec};

        if let Expression::Interval(iv) = interval_expr {
            let val = iv.this.clone().unwrap_or(Expression::number(0));
            let unit = match &iv.unit {
                Some(IntervalUnitSpec::Simple { unit, .. }) => *unit,
                None => {
                    // Unit might be embedded in the string value (Snowflake format: '5 DAY')
                    if let Expression::Literal(crate::expressions::Literal::String(s)) = &val {
                        let parts: Vec<&str> = s.trim().splitn(2, ' ').collect();
                        if parts.len() == 2 {
                            let unit_str = parts[1].trim().to_uppercase();
                            let parsed_unit = match unit_str.as_str() {
                                "YEAR" | "YEARS" => IntervalUnit::Year,
                                "QUARTER" | "QUARTERS" => IntervalUnit::Quarter,
                                "MONTH" | "MONTHS" => IntervalUnit::Month,
                                "WEEK" | "WEEKS" | "ISOWEEK" => IntervalUnit::Week,
                                "DAY" | "DAYS" => IntervalUnit::Day,
                                "HOUR" | "HOURS" => IntervalUnit::Hour,
                                "MINUTE" | "MINUTES" => IntervalUnit::Minute,
                                "SECOND" | "SECONDS" => IntervalUnit::Second,
                                "MILLISECOND" | "MILLISECONDS" => IntervalUnit::Millisecond,
                                "MICROSECOND" | "MICROSECONDS" => IntervalUnit::Microsecond,
                                _ => IntervalUnit::Day,
                            };
                            // Return just the numeric part as value and parsed unit
                            return (
                                Expression::Literal(crate::expressions::Literal::String(
                                    parts[0].to_string(),
                                )),
                                parsed_unit,
                            );
                        }
                        IntervalUnit::Day
                    } else {
                        IntervalUnit::Day
                    }
                }
                _ => IntervalUnit::Day,
            };
            (val, unit)
        } else {
            // Not an interval - pass through
            (interval_expr.clone(), crate::expressions::IntervalUnit::Day)
        }
    }

    /// Normalize BigQuery-specific functions to standard forms that target dialects can handle
    fn normalize_bigquery_function(
        e: Expression,
        source: DialectType,
        target: DialectType,
    ) -> Result<Expression> {
        use crate::expressions::{BinaryOp, Cast, DataType, Function, Identifier, Literal, Paren};

        let f = if let Expression::Function(f) = e {
            *f
        } else {
            return Ok(e);
        };
        let name = f.name.to_uppercase();
        let mut args = f.args;

        /// Helper to extract unit string from an identifier, column, or literal expression
        fn get_unit_str(expr: &Expression) -> String {
            match expr {
                Expression::Identifier(id) => id.name.to_uppercase(),
                Expression::Literal(Literal::String(s)) => s.to_uppercase(),
                Expression::Column(col) => col.name.name.to_uppercase(),
                // Handle WEEK(MONDAY), WEEK(SUNDAY) etc. which are parsed as Function("WEEK", [Column("MONDAY")])
                Expression::Function(f) => {
                    let base = f.name.to_uppercase();
                    if !f.args.is_empty() {
                        // e.g., WEEK(MONDAY) -> "WEEK(MONDAY)"
                        let inner = get_unit_str(&f.args[0]);
                        format!("{}({})", base, inner)
                    } else {
                        base
                    }
                }
                _ => "DAY".to_string(),
            }
        }

        /// Parse unit string to IntervalUnit
        fn parse_interval_unit(s: &str) -> crate::expressions::IntervalUnit {
            match s {
                "YEAR" => crate::expressions::IntervalUnit::Year,
                "QUARTER" => crate::expressions::IntervalUnit::Quarter,
                "MONTH" => crate::expressions::IntervalUnit::Month,
                "WEEK" | "ISOWEEK" => crate::expressions::IntervalUnit::Week,
                "DAY" => crate::expressions::IntervalUnit::Day,
                "HOUR" => crate::expressions::IntervalUnit::Hour,
                "MINUTE" => crate::expressions::IntervalUnit::Minute,
                "SECOND" => crate::expressions::IntervalUnit::Second,
                "MILLISECOND" => crate::expressions::IntervalUnit::Millisecond,
                "MICROSECOND" => crate::expressions::IntervalUnit::Microsecond,
                _ if s.starts_with("WEEK(") => crate::expressions::IntervalUnit::Week,
                _ => crate::expressions::IntervalUnit::Day,
            }
        }

        match name.as_str() {
            // TIMESTAMP_DIFF(date1, date2, unit) -> TIMESTAMPDIFF(unit, date2, date1)
            // (BigQuery: result = date1 - date2, Standard: result = end - start)
            "TIMESTAMP_DIFF" | "DATETIME_DIFF" | "TIME_DIFF" if args.len() == 3 => {
                let date1 = args.remove(0);
                let date2 = args.remove(0);
                let unit_expr = args.remove(0);
                let unit_str = get_unit_str(&unit_expr);

                if matches!(target, DialectType::BigQuery) {
                    // BigQuery -> BigQuery: just uppercase the unit
                    let unit = Expression::Identifier(Identifier::new(unit_str.clone()));
                    return Ok(Expression::Function(Box::new(Function::new(
                        f.name,
                        vec![date1, date2, unit],
                    ))));
                }

                // For Snowflake: use TimestampDiff expression so it generates TIMESTAMPDIFF
                // (Function("TIMESTAMPDIFF") would be converted to DATEDIFF by Snowflake's function normalization)
                if matches!(target, DialectType::Snowflake) {
                    return Ok(Expression::TimestampDiff(Box::new(
                        crate::expressions::TimestampDiff {
                            this: Box::new(date2),
                            expression: Box::new(date1),
                            unit: Some(unit_str),
                        },
                    )));
                }

                // For DuckDB: DATE_DIFF('UNIT', start, end) with proper CAST
                if matches!(target, DialectType::DuckDB) {
                    let (cast_d1, cast_d2) = if name == "TIME_DIFF" {
                        // CAST to TIME
                        let cast_fn = |e: Expression| -> Expression {
                            match e {
                                Expression::Literal(Literal::String(s)) => {
                                    Expression::Cast(Box::new(Cast {
                                        this: Expression::Literal(Literal::String(s)),
                                        to: DataType::Custom {
                                            name: "TIME".to_string(),
                                        },
                                        trailing_comments: vec![],
                                        double_colon_syntax: false,
                                        format: None,
                                        default: None,
                                    }))
                                }
                                other => other,
                            }
                        };
                        (cast_fn(date1), cast_fn(date2))
                    } else if name == "DATETIME_DIFF" {
                        // CAST to TIMESTAMP
                        (
                            Self::ensure_cast_timestamp(date1),
                            Self::ensure_cast_timestamp(date2),
                        )
                    } else {
                        // TIMESTAMP_DIFF: CAST to TIMESTAMPTZ
                        (
                            Self::ensure_cast_timestamptz(date1),
                            Self::ensure_cast_timestamptz(date2),
                        )
                    };
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATE_DIFF".to_string(),
                        vec![
                            Expression::Literal(Literal::String(unit_str)),
                            cast_d2,
                            cast_d1,
                        ],
                    ))));
                }

                // Convert to standard TIMESTAMPDIFF(unit, start, end)
                let unit = Expression::Identifier(Identifier::new(unit_str));
                Ok(Expression::Function(Box::new(Function::new(
                    "TIMESTAMPDIFF".to_string(),
                    vec![unit, date2, date1],
                ))))
            }

            // DATEDIFF(unit, start, end) -> target-specific form
            // Used by: Redshift, Snowflake, TSQL, Databricks, Spark
            "DATEDIFF" if args.len() == 3 => {
                let arg0 = args.remove(0);
                let arg1 = args.remove(0);
                let arg2 = args.remove(0);
                let unit_str = get_unit_str(&arg0);

                // Redshift DATEDIFF(unit, start, end) order: result = end - start
                // Snowflake DATEDIFF(unit, start, end) order: result = end - start
                // TSQL DATEDIFF(unit, start, end) order: result = end - start

                if matches!(target, DialectType::Snowflake) {
                    // Snowflake: DATEDIFF(UNIT, start, end) - uppercase unit
                    let unit = Expression::Identifier(Identifier::new(unit_str));
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATEDIFF".to_string(),
                        vec![unit, arg1, arg2],
                    ))));
                }

                if matches!(target, DialectType::DuckDB) {
                    // DuckDB: DATE_DIFF('UNIT', start, end) with CAST
                    let cast_d1 = Self::ensure_cast_timestamp(arg1);
                    let cast_d2 = Self::ensure_cast_timestamp(arg2);
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATE_DIFF".to_string(),
                        vec![
                            Expression::Literal(Literal::String(unit_str)),
                            cast_d1,
                            cast_d2,
                        ],
                    ))));
                }

                if matches!(target, DialectType::BigQuery) {
                    // BigQuery: DATE_DIFF(end_date, start_date, UNIT) - reversed args, CAST to DATETIME
                    let cast_d1 = Self::ensure_cast_datetime(arg1);
                    let cast_d2 = Self::ensure_cast_datetime(arg2);
                    let unit = Expression::Identifier(Identifier::new(unit_str));
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATE_DIFF".to_string(),
                        vec![cast_d2, cast_d1, unit],
                    ))));
                }

                if matches!(target, DialectType::Spark | DialectType::Databricks) {
                    // Spark/Databricks: DATEDIFF(UNIT, start, end) - uppercase unit
                    let unit = Expression::Identifier(Identifier::new(unit_str));
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATEDIFF".to_string(),
                        vec![unit, arg1, arg2],
                    ))));
                }

                if matches!(target, DialectType::Hive) {
                    // Hive: DATEDIFF(end, start) for DAY only, use MONTHS_BETWEEN for MONTH
                    match unit_str.as_str() {
                        "MONTH" => {
                            return Ok(Expression::Function(Box::new(Function::new(
                                "CAST".to_string(),
                                vec![Expression::Function(Box::new(Function::new(
                                    "MONTHS_BETWEEN".to_string(),
                                    vec![arg2, arg1],
                                )))],
                            ))));
                        }
                        "WEEK" => {
                            return Ok(Expression::Cast(Box::new(Cast {
                                this: Expression::Div(Box::new(crate::expressions::BinaryOp::new(
                                    Expression::Function(Box::new(Function::new(
                                        "DATEDIFF".to_string(),
                                        vec![arg2, arg1],
                                    ))),
                                    Expression::Literal(Literal::Number("7".to_string())),
                                ))),
                                to: DataType::Int {
                                    length: None,
                                    integer_spelling: false,
                                },
                                trailing_comments: vec![],
                                double_colon_syntax: false,
                                format: None,
                                default: None,
                            })));
                        }
                        _ => {
                            // Default: DATEDIFF(end, start) for DAY
                            return Ok(Expression::Function(Box::new(Function::new(
                                "DATEDIFF".to_string(),
                                vec![arg2, arg1],
                            ))));
                        }
                    }
                }

                if matches!(
                    target,
                    DialectType::Presto | DialectType::Trino | DialectType::Athena
                ) {
                    // Presto/Trino: DATE_DIFF('UNIT', start, end)
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATE_DIFF".to_string(),
                        vec![Expression::Literal(Literal::String(unit_str)), arg1, arg2],
                    ))));
                }

                if matches!(target, DialectType::TSQL) {
                    // TSQL: DATEDIFF(UNIT, start, CAST(end AS DATETIME2))
                    let cast_d2 = Self::ensure_cast_datetime2(arg2);
                    let unit = Expression::Identifier(Identifier::new(unit_str));
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATEDIFF".to_string(),
                        vec![unit, arg1, cast_d2],
                    ))));
                }

                if matches!(target, DialectType::PostgreSQL) {
                    // PostgreSQL doesn't have DATEDIFF - use date subtraction or EXTRACT
                    // For now, use DATEDIFF (passthrough) with uppercased unit
                    let unit = Expression::Identifier(Identifier::new(unit_str));
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATEDIFF".to_string(),
                        vec![unit, arg1, arg2],
                    ))));
                }

                // Default: DATEDIFF(UNIT, start, end) with uppercase unit
                let unit = Expression::Identifier(Identifier::new(unit_str));
                Ok(Expression::Function(Box::new(Function::new(
                    "DATEDIFF".to_string(),
                    vec![unit, arg1, arg2],
                ))))
            }

            // DATE_DIFF(date1, date2, unit) -> standard form
            "DATE_DIFF" if args.len() == 3 => {
                let date1 = args.remove(0);
                let date2 = args.remove(0);
                let unit_expr = args.remove(0);
                let unit_str = get_unit_str(&unit_expr);

                if matches!(target, DialectType::BigQuery) {
                    // BigQuery -> BigQuery: just uppercase the unit, normalize WEEK(SUNDAY) -> WEEK
                    let norm_unit = if unit_str == "WEEK(SUNDAY)" {
                        "WEEK".to_string()
                    } else {
                        unit_str
                    };
                    let norm_d1 = Self::date_literal_to_cast(date1);
                    let norm_d2 = Self::date_literal_to_cast(date2);
                    let unit = Expression::Identifier(Identifier::new(norm_unit));
                    return Ok(Expression::Function(Box::new(Function::new(
                        f.name,
                        vec![norm_d1, norm_d2, unit],
                    ))));
                }

                if matches!(target, DialectType::MySQL) {
                    // MySQL DATEDIFF only takes 2 args (date1, date2), returns day difference
                    let norm_d1 = Self::date_literal_to_cast(date1);
                    let norm_d2 = Self::date_literal_to_cast(date2);
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATEDIFF".to_string(),
                        vec![norm_d1, norm_d2],
                    ))));
                }

                if matches!(target, DialectType::StarRocks) {
                    // StarRocks: DATE_DIFF('UNIT', date1, date2) - unit as string, args NOT swapped
                    let norm_d1 = Self::date_literal_to_cast(date1);
                    let norm_d2 = Self::date_literal_to_cast(date2);
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATE_DIFF".to_string(),
                        vec![
                            Expression::Literal(Literal::String(unit_str)),
                            norm_d1,
                            norm_d2,
                        ],
                    ))));
                }

                if matches!(target, DialectType::DuckDB) {
                    // DuckDB: DATE_DIFF('UNIT', date2, date1) with proper CAST for dates
                    let norm_d1 = Self::ensure_cast_date(date1);
                    let norm_d2 = Self::ensure_cast_date(date2);

                    // Handle WEEK variants: WEEK(MONDAY)/WEEK(SUNDAY)/ISOWEEK/WEEK
                    let is_week_variant = unit_str == "WEEK"
                        || unit_str.starts_with("WEEK(")
                        || unit_str == "ISOWEEK";
                    if is_week_variant {
                        // For DuckDB, WEEK-based diffs use DATE_TRUNC approach
                        // WEEK(MONDAY) / ISOWEEK: DATE_DIFF('WEEK', DATE_TRUNC('WEEK', d2), DATE_TRUNC('WEEK', d1))
                        // WEEK / WEEK(SUNDAY): DATE_DIFF('WEEK', DATE_TRUNC('WEEK', d2 + INTERVAL '1' DAY), DATE_TRUNC('WEEK', d1 + INTERVAL '1' DAY))
                        // WEEK(SATURDAY): DATE_DIFF('WEEK', DATE_TRUNC('WEEK', d2 + INTERVAL '-5' DAY), DATE_TRUNC('WEEK', d1 + INTERVAL '-5' DAY))
                        let day_offset = if unit_str == "WEEK(MONDAY)" || unit_str == "ISOWEEK" {
                            None // ISO weeks start on Monday, aligned with DATE_TRUNC('WEEK')
                        } else if unit_str == "WEEK" || unit_str == "WEEK(SUNDAY)" {
                            Some("1") // Shift Sunday to Monday alignment
                        } else if unit_str == "WEEK(SATURDAY)" {
                            Some("-5")
                        } else if unit_str == "WEEK(TUESDAY)" {
                            Some("-1")
                        } else if unit_str == "WEEK(WEDNESDAY)" {
                            Some("-2")
                        } else if unit_str == "WEEK(THURSDAY)" {
                            Some("-3")
                        } else if unit_str == "WEEK(FRIDAY)" {
                            Some("-4")
                        } else {
                            Some("1") // default to Sunday
                        };

                        let make_trunc = |date: Expression, offset: Option<&str>| -> Expression {
                            let shifted = if let Some(off) = offset {
                                let interval =
                                    Expression::Interval(Box::new(crate::expressions::Interval {
                                        this: Some(Expression::Literal(Literal::String(
                                            off.to_string(),
                                        ))),
                                        unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                            unit: crate::expressions::IntervalUnit::Day,
                                            use_plural: false,
                                        }),
                                    }));
                                Expression::Add(Box::new(crate::expressions::BinaryOp::new(
                                    date, interval,
                                )))
                            } else {
                                date
                            };
                            Expression::Function(Box::new(Function::new(
                                "DATE_TRUNC".to_string(),
                                vec![
                                    Expression::Literal(Literal::String("WEEK".to_string())),
                                    shifted,
                                ],
                            )))
                        };

                        let trunc_d2 = make_trunc(norm_d2, day_offset);
                        let trunc_d1 = make_trunc(norm_d1, day_offset);
                        return Ok(Expression::Function(Box::new(Function::new(
                            "DATE_DIFF".to_string(),
                            vec![
                                Expression::Literal(Literal::String("WEEK".to_string())),
                                trunc_d2,
                                trunc_d1,
                            ],
                        ))));
                    }

                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATE_DIFF".to_string(),
                        vec![
                            Expression::Literal(Literal::String(unit_str)),
                            norm_d2,
                            norm_d1,
                        ],
                    ))));
                }

                // Default: DATEDIFF(unit, date2, date1)
                let unit = Expression::Identifier(Identifier::new(unit_str));
                Ok(Expression::Function(Box::new(Function::new(
                    "DATEDIFF".to_string(),
                    vec![unit, date2, date1],
                ))))
            }

            // TIMESTAMP_ADD(ts, INTERVAL n UNIT) -> target-specific
            "TIMESTAMP_ADD" | "DATETIME_ADD" | "TIME_ADD" if args.len() == 2 => {
                let ts = args.remove(0);
                let interval_expr = args.remove(0);
                let (val, unit) = Self::extract_interval_parts(&interval_expr);

                match target {
                    DialectType::Snowflake => {
                        // TIMESTAMPADD(UNIT, val, CAST(ts AS TIMESTAMPTZ))
                        // Use TimestampAdd expression so Snowflake generates TIMESTAMPADD
                        // (Function("TIMESTAMPADD") would be converted to DATEADD by Snowflake's function normalization)
                        let unit_str = Self::interval_unit_to_string(&unit);
                        let cast_ts = Self::maybe_cast_ts_to_tz(ts, &name);
                        Ok(Expression::TimestampAdd(Box::new(
                            crate::expressions::TimestampAdd {
                                this: Box::new(val),
                                expression: Box::new(cast_ts),
                                unit: Some(unit_str),
                            },
                        )))
                    }
                    DialectType::Spark | DialectType::Databricks => {
                        if name == "DATETIME_ADD" && matches!(target, DialectType::Spark) {
                            // Spark DATETIME_ADD: ts + INTERVAL val UNIT
                            let interval =
                                Expression::Interval(Box::new(crate::expressions::Interval {
                                    this: Some(val),
                                    unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                        unit,
                                        use_plural: false,
                                    }),
                                }));
                            Ok(Expression::Add(Box::new(
                                crate::expressions::BinaryOp::new(ts, interval),
                            )))
                        } else if name == "DATETIME_ADD"
                            && matches!(target, DialectType::Databricks)
                        {
                            // Databricks DATETIME_ADD: TIMESTAMPADD(UNIT, val, ts)
                            let unit_str = Self::interval_unit_to_string(&unit);
                            Ok(Expression::Function(Box::new(Function::new(
                                "TIMESTAMPADD".to_string(),
                                vec![Expression::Identifier(Identifier::new(unit_str)), val, ts],
                            ))))
                        } else {
                            // Presto-style: DATE_ADD('unit', val, CAST(ts AS TIMESTAMP))
                            let unit_str = Self::interval_unit_to_string(&unit);
                            let cast_ts =
                                if name.starts_with("TIMESTAMP") || name.starts_with("DATETIME") {
                                    Self::maybe_cast_ts(ts)
                                } else {
                                    ts
                                };
                            Ok(Expression::Function(Box::new(Function::new(
                                "DATE_ADD".to_string(),
                                vec![
                                    Expression::Identifier(Identifier::new(unit_str)),
                                    val,
                                    cast_ts,
                                ],
                            ))))
                        }
                    }
                    DialectType::MySQL => {
                        // DATE_ADD(TIMESTAMP(ts), INTERVAL val UNIT) for MySQL
                        let mysql_ts = if name.starts_with("TIMESTAMP") {
                            // Check if already wrapped in TIMESTAMP() function (from cross-dialect normalization)
                            match &ts {
                                Expression::Function(ref inner_f)
                                    if inner_f.name.eq_ignore_ascii_case("TIMESTAMP") =>
                                {
                                    // Already wrapped, keep as-is
                                    ts
                                }
                                _ => {
                                    // Unwrap typed literals: TIMESTAMP '...' -> '...' for TIMESTAMP() wrapper
                                    let unwrapped = match ts {
                                        Expression::Literal(Literal::Timestamp(s)) => {
                                            Expression::Literal(Literal::String(s))
                                        }
                                        other => other,
                                    };
                                    Expression::Function(Box::new(Function::new(
                                        "TIMESTAMP".to_string(),
                                        vec![unwrapped],
                                    )))
                                }
                            }
                        } else {
                            ts
                        };
                        Ok(Expression::DateAdd(Box::new(
                            crate::expressions::DateAddFunc {
                                this: mysql_ts,
                                interval: val,
                                unit,
                            },
                        )))
                    }
                    _ => {
                        // DuckDB and others use DateAdd expression (DuckDB converts to + INTERVAL)
                        let cast_ts = if matches!(target, DialectType::DuckDB) {
                            if name == "DATETIME_ADD" {
                                Self::ensure_cast_timestamp(ts)
                            } else if name.starts_with("TIMESTAMP") {
                                Self::maybe_cast_ts_to_tz(ts, &name)
                            } else {
                                ts
                            }
                        } else {
                            ts
                        };
                        Ok(Expression::DateAdd(Box::new(
                            crate::expressions::DateAddFunc {
                                this: cast_ts,
                                interval: val,
                                unit,
                            },
                        )))
                    }
                }
            }

            // TIMESTAMP_SUB(ts, INTERVAL n UNIT) -> target-specific
            "TIMESTAMP_SUB" | "DATETIME_SUB" | "TIME_SUB" if args.len() == 2 => {
                let ts = args.remove(0);
                let interval_expr = args.remove(0);
                let (val, unit) = Self::extract_interval_parts(&interval_expr);

                match target {
                    DialectType::Snowflake => {
                        // TIMESTAMPADD(UNIT, val * -1, CAST(ts AS TIMESTAMPTZ))
                        let unit_str = Self::interval_unit_to_string(&unit);
                        let cast_ts = Self::maybe_cast_ts_to_tz(ts, &name);
                        let neg_val = Expression::Mul(Box::new(crate::expressions::BinaryOp::new(
                            val,
                            Expression::Neg(Box::new(crate::expressions::UnaryOp {
                                this: Expression::number(1),
                            })),
                        )));
                        Ok(Expression::TimestampAdd(Box::new(
                            crate::expressions::TimestampAdd {
                                this: Box::new(neg_val),
                                expression: Box::new(cast_ts),
                                unit: Some(unit_str),
                            },
                        )))
                    }
                    DialectType::Spark | DialectType::Databricks => {
                        if (name == "DATETIME_SUB" && matches!(target, DialectType::Spark))
                            || (name == "TIMESTAMP_SUB" && matches!(target, DialectType::Spark))
                        {
                            // Spark: ts - INTERVAL val UNIT
                            let cast_ts = if name.starts_with("TIMESTAMP") {
                                Self::maybe_cast_ts(ts)
                            } else {
                                ts
                            };
                            let interval =
                                Expression::Interval(Box::new(crate::expressions::Interval {
                                    this: Some(val),
                                    unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                        unit,
                                        use_plural: false,
                                    }),
                                }));
                            Ok(Expression::Sub(Box::new(
                                crate::expressions::BinaryOp::new(cast_ts, interval),
                            )))
                        } else {
                            // Databricks: TIMESTAMPADD(UNIT, val * -1, ts)
                            let unit_str = Self::interval_unit_to_string(&unit);
                            let neg_val =
                                Expression::Mul(Box::new(crate::expressions::BinaryOp::new(
                                    val,
                                    Expression::Neg(Box::new(crate::expressions::UnaryOp {
                                        this: Expression::number(1),
                                    })),
                                )));
                            Ok(Expression::Function(Box::new(Function::new(
                                "TIMESTAMPADD".to_string(),
                                vec![
                                    Expression::Identifier(Identifier::new(unit_str)),
                                    neg_val,
                                    ts,
                                ],
                            ))))
                        }
                    }
                    DialectType::MySQL => {
                        let mysql_ts = if name.starts_with("TIMESTAMP") {
                            // Check if already wrapped in TIMESTAMP() function (from cross-dialect normalization)
                            match &ts {
                                Expression::Function(ref inner_f)
                                    if inner_f.name.eq_ignore_ascii_case("TIMESTAMP") =>
                                {
                                    // Already wrapped, keep as-is
                                    ts
                                }
                                _ => {
                                    let unwrapped = match ts {
                                        Expression::Literal(Literal::Timestamp(s)) => {
                                            Expression::Literal(Literal::String(s))
                                        }
                                        other => other,
                                    };
                                    Expression::Function(Box::new(Function::new(
                                        "TIMESTAMP".to_string(),
                                        vec![unwrapped],
                                    )))
                                }
                            }
                        } else {
                            ts
                        };
                        Ok(Expression::DateSub(Box::new(
                            crate::expressions::DateAddFunc {
                                this: mysql_ts,
                                interval: val,
                                unit,
                            },
                        )))
                    }
                    _ => {
                        let cast_ts = if matches!(target, DialectType::DuckDB) {
                            if name == "DATETIME_SUB" {
                                Self::ensure_cast_timestamp(ts)
                            } else if name.starts_with("TIMESTAMP") {
                                Self::maybe_cast_ts_to_tz(ts, &name)
                            } else {
                                ts
                            }
                        } else {
                            ts
                        };
                        Ok(Expression::DateSub(Box::new(
                            crate::expressions::DateAddFunc {
                                this: cast_ts,
                                interval: val,
                                unit,
                            },
                        )))
                    }
                }
            }

            // DATE_SUB(date, INTERVAL n UNIT) -> target-specific
            "DATE_SUB" if args.len() == 2 => {
                let date = args.remove(0);
                let interval_expr = args.remove(0);
                let (val, unit) = Self::extract_interval_parts(&interval_expr);

                match target {
                    DialectType::Databricks | DialectType::Spark => {
                        // Databricks/Spark: DATE_ADD(date, -val)
                        // Use DateAdd expression with negative val so it generates correctly
                        // The generator will output DATE_ADD(date, INTERVAL -val DAY)
                        // Then Databricks transform converts 2-arg DATE_ADD(date, interval) to DATEADD(DAY, interval, date)
                        // Instead, we directly output as a simple negated DateSub
                        Ok(Expression::DateSub(Box::new(
                            crate::expressions::DateAddFunc {
                                this: date,
                                interval: val,
                                unit,
                            },
                        )))
                    }
                    DialectType::DuckDB => {
                        // DuckDB: CAST(date AS DATE) - INTERVAL 'val' UNIT
                        let cast_date = Self::ensure_cast_date(date);
                        let interval =
                            Expression::Interval(Box::new(crate::expressions::Interval {
                                this: Some(val),
                                unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                    unit,
                                    use_plural: false,
                                }),
                            }));
                        Ok(Expression::Sub(Box::new(
                            crate::expressions::BinaryOp::new(cast_date, interval),
                        )))
                    }
                    DialectType::Snowflake => {
                        // Snowflake: Let Snowflake's own DateSub -> DATEADD(UNIT, val * -1, date) handler work
                        // Just ensure the date is cast properly
                        let cast_date = Self::ensure_cast_date(date);
                        Ok(Expression::DateSub(Box::new(
                            crate::expressions::DateAddFunc {
                                this: cast_date,
                                interval: val,
                                unit,
                            },
                        )))
                    }
                    DialectType::PostgreSQL => {
                        // PostgreSQL: date - INTERVAL 'val UNIT'
                        let unit_str = Self::interval_unit_to_string(&unit);
                        let interval =
                            Expression::Interval(Box::new(crate::expressions::Interval {
                                this: Some(Expression::Literal(Literal::String(format!(
                                    "{} {}",
                                    Self::expr_to_string(&val),
                                    unit_str
                                )))),
                                unit: None,
                            }));
                        Ok(Expression::Sub(Box::new(
                            crate::expressions::BinaryOp::new(date, interval),
                        )))
                    }
                    _ => Ok(Expression::DateSub(Box::new(
                        crate::expressions::DateAddFunc {
                            this: date,
                            interval: val,
                            unit,
                        },
                    ))),
                }
            }

            // DATEADD(unit, val, date) -> target-specific form
            // Used by: Redshift, Snowflake, TSQL, ClickHouse
            "DATEADD" if args.len() == 3 => {
                let arg0 = args.remove(0);
                let arg1 = args.remove(0);
                let arg2 = args.remove(0);
                let unit_str = get_unit_str(&arg0);

                if matches!(target, DialectType::Snowflake | DialectType::TSQL) {
                    // Keep DATEADD(UNIT, val, date) with uppercased unit
                    let unit = Expression::Identifier(Identifier::new(unit_str));
                    // Only CAST to DATETIME2 for TSQL target when source is NOT Spark/Databricks family
                    let date = if matches!(target, DialectType::TSQL)
                        && !matches!(
                            source,
                            DialectType::Spark | DialectType::Databricks | DialectType::Hive
                        ) {
                        Self::ensure_cast_datetime2(arg2)
                    } else {
                        arg2
                    };
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATEADD".to_string(),
                        vec![unit, arg1, date],
                    ))));
                }

                if matches!(target, DialectType::DuckDB) {
                    // DuckDB: date + INTERVAL 'val' UNIT
                    let iu = parse_interval_unit(&unit_str);
                    let interval = Expression::Interval(Box::new(crate::expressions::Interval {
                        this: Some(arg1),
                        unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                            unit: iu,
                            use_plural: false,
                        }),
                    }));
                    let cast_date = Self::ensure_cast_timestamp(arg2);
                    return Ok(Expression::Add(Box::new(
                        crate::expressions::BinaryOp::new(cast_date, interval),
                    )));
                }

                if matches!(target, DialectType::BigQuery) {
                    // BigQuery: DATE_ADD(date, INTERVAL val UNIT) or TIMESTAMP_ADD(ts, INTERVAL val UNIT)
                    let iu = parse_interval_unit(&unit_str);
                    let interval = Expression::Interval(Box::new(crate::expressions::Interval {
                        this: Some(arg1),
                        unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                            unit: iu,
                            use_plural: false,
                        }),
                    }));
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATE_ADD".to_string(),
                        vec![arg2, interval],
                    ))));
                }

                if matches!(target, DialectType::Databricks) {
                    // Databricks: keep DATEADD(UNIT, val, date) format
                    let unit = Expression::Identifier(Identifier::new(unit_str));
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATEADD".to_string(),
                        vec![unit, arg1, arg2],
                    ))));
                }

                if matches!(target, DialectType::Spark) {
                    // Spark: convert month-based units to ADD_MONTHS, rest to DATE_ADD
                    fn multiply_expr_dateadd(expr: Expression, factor: i64) -> Expression {
                        if let Expression::Literal(crate::expressions::Literal::Number(n)) = &expr {
                            if let Ok(val) = n.parse::<i64>() {
                                return Expression::Literal(crate::expressions::Literal::Number(
                                    (val * factor).to_string(),
                                ));
                            }
                        }
                        Expression::Mul(Box::new(crate::expressions::BinaryOp::new(
                            expr,
                            Expression::Literal(crate::expressions::Literal::Number(
                                factor.to_string(),
                            )),
                        )))
                    }
                    match unit_str.as_str() {
                        "YEAR" => {
                            let months = multiply_expr_dateadd(arg1, 12);
                            return Ok(Expression::Function(Box::new(Function::new(
                                "ADD_MONTHS".to_string(),
                                vec![arg2, months],
                            ))));
                        }
                        "QUARTER" => {
                            let months = multiply_expr_dateadd(arg1, 3);
                            return Ok(Expression::Function(Box::new(Function::new(
                                "ADD_MONTHS".to_string(),
                                vec![arg2, months],
                            ))));
                        }
                        "MONTH" => {
                            return Ok(Expression::Function(Box::new(Function::new(
                                "ADD_MONTHS".to_string(),
                                vec![arg2, arg1],
                            ))));
                        }
                        "WEEK" => {
                            let days = multiply_expr_dateadd(arg1, 7);
                            return Ok(Expression::Function(Box::new(Function::new(
                                "DATE_ADD".to_string(),
                                vec![arg2, days],
                            ))));
                        }
                        "DAY" => {
                            return Ok(Expression::Function(Box::new(Function::new(
                                "DATE_ADD".to_string(),
                                vec![arg2, arg1],
                            ))));
                        }
                        _ => {
                            let unit = Expression::Identifier(Identifier::new(unit_str));
                            return Ok(Expression::Function(Box::new(Function::new(
                                "DATE_ADD".to_string(),
                                vec![unit, arg1, arg2],
                            ))));
                        }
                    }
                }

                if matches!(target, DialectType::Hive) {
                    // Hive: DATE_ADD(date, val) for DAY, or date + INTERVAL for others
                    match unit_str.as_str() {
                        "DAY" => {
                            return Ok(Expression::Function(Box::new(Function::new(
                                "DATE_ADD".to_string(),
                                vec![arg2, arg1],
                            ))));
                        }
                        "MONTH" => {
                            return Ok(Expression::Function(Box::new(Function::new(
                                "ADD_MONTHS".to_string(),
                                vec![arg2, arg1],
                            ))));
                        }
                        _ => {
                            let iu = parse_interval_unit(&unit_str);
                            let interval =
                                Expression::Interval(Box::new(crate::expressions::Interval {
                                    this: Some(arg1),
                                    unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                        unit: iu,
                                        use_plural: false,
                                    }),
                                }));
                            return Ok(Expression::Add(Box::new(
                                crate::expressions::BinaryOp::new(arg2, interval),
                            )));
                        }
                    }
                }

                if matches!(target, DialectType::PostgreSQL) {
                    // PostgreSQL: date + INTERVAL 'val UNIT'
                    let interval = Expression::Interval(Box::new(crate::expressions::Interval {
                        this: Some(Expression::Literal(Literal::String(format!(
                            "{} {}",
                            Self::expr_to_string(&arg1),
                            unit_str
                        )))),
                        unit: None,
                    }));
                    return Ok(Expression::Add(Box::new(
                        crate::expressions::BinaryOp::new(arg2, interval),
                    )));
                }

                if matches!(
                    target,
                    DialectType::Presto | DialectType::Trino | DialectType::Athena
                ) {
                    // Presto/Trino: DATE_ADD('UNIT', val, date)
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATE_ADD".to_string(),
                        vec![Expression::Literal(Literal::String(unit_str)), arg1, arg2],
                    ))));
                }

                if matches!(target, DialectType::ClickHouse) {
                    // ClickHouse: DATE_ADD(UNIT, val, date)
                    let unit = Expression::Identifier(Identifier::new(unit_str));
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATE_ADD".to_string(),
                        vec![unit, arg1, arg2],
                    ))));
                }

                // Default: keep DATEADD with uppercased unit
                let unit = Expression::Identifier(Identifier::new(unit_str));
                Ok(Expression::Function(Box::new(Function::new(
                    "DATEADD".to_string(),
                    vec![unit, arg1, arg2],
                ))))
            }

            // DATE_ADD(unit, val, date) - 3 arg form from ClickHouse/Presto
            "DATE_ADD" if args.len() == 3 => {
                let arg0 = args.remove(0);
                let arg1 = args.remove(0);
                let arg2 = args.remove(0);
                let unit_str = get_unit_str(&arg0);

                if matches!(
                    target,
                    DialectType::Presto | DialectType::Trino | DialectType::Athena
                ) {
                    // Presto/Trino: DATE_ADD('UNIT', val, date)
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATE_ADD".to_string(),
                        vec![Expression::Literal(Literal::String(unit_str)), arg1, arg2],
                    ))));
                }

                if matches!(
                    target,
                    DialectType::Snowflake | DialectType::TSQL | DialectType::Redshift
                ) {
                    // DATEADD(UNIT, val, date)
                    let unit = Expression::Identifier(Identifier::new(unit_str));
                    let date = if matches!(target, DialectType::TSQL) {
                        Self::ensure_cast_datetime2(arg2)
                    } else {
                        arg2
                    };
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATEADD".to_string(),
                        vec![unit, arg1, date],
                    ))));
                }

                if matches!(target, DialectType::DuckDB) {
                    // DuckDB: date + INTERVAL val UNIT
                    let iu = parse_interval_unit(&unit_str);
                    let interval = Expression::Interval(Box::new(crate::expressions::Interval {
                        this: Some(arg1),
                        unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                            unit: iu,
                            use_plural: false,
                        }),
                    }));
                    return Ok(Expression::Add(Box::new(
                        crate::expressions::BinaryOp::new(arg2, interval),
                    )));
                }

                if matches!(target, DialectType::Spark | DialectType::Databricks) {
                    // Spark: DATE_ADD(UNIT, val, date) with uppercased unit
                    let unit = Expression::Identifier(Identifier::new(unit_str));
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATE_ADD".to_string(),
                        vec![unit, arg1, arg2],
                    ))));
                }

                // Default: DATE_ADD(UNIT, val, date)
                let unit = Expression::Identifier(Identifier::new(unit_str));
                Ok(Expression::Function(Box::new(Function::new(
                    "DATE_ADD".to_string(),
                    vec![unit, arg1, arg2],
                ))))
            }

            // DATE_ADD(date, INTERVAL val UNIT) - 2 arg BigQuery form
            "DATE_ADD" if args.len() == 2 => {
                let date = args.remove(0);
                let interval_expr = args.remove(0);
                let (val, unit) = Self::extract_interval_parts(&interval_expr);
                let unit_str = Self::interval_unit_to_string(&unit);

                match target {
                    DialectType::DuckDB => {
                        // DuckDB: CAST(date AS DATE) + INTERVAL 'val' UNIT
                        let cast_date = Self::ensure_cast_date(date);
                        let quoted_val = Self::quote_interval_val(&val);
                        let interval =
                            Expression::Interval(Box::new(crate::expressions::Interval {
                                this: Some(quoted_val),
                                unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                    unit,
                                    use_plural: false,
                                }),
                            }));
                        Ok(Expression::Add(Box::new(
                            crate::expressions::BinaryOp::new(cast_date, interval),
                        )))
                    }
                    DialectType::PostgreSQL => {
                        // PostgreSQL: date + INTERVAL 'val UNIT'
                        let interval =
                            Expression::Interval(Box::new(crate::expressions::Interval {
                                this: Some(Expression::Literal(Literal::String(format!(
                                    "{} {}",
                                    Self::expr_to_string(&val),
                                    unit_str
                                )))),
                                unit: None,
                            }));
                        Ok(Expression::Add(Box::new(
                            crate::expressions::BinaryOp::new(date, interval),
                        )))
                    }
                    DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                        // Presto: DATE_ADD('UNIT', CAST('val' AS BIGINT), date)
                        let val_str = Self::expr_to_string(&val);
                        Ok(Expression::Function(Box::new(Function::new(
                            "DATE_ADD".to_string(),
                            vec![
                                Expression::Literal(Literal::String(unit_str)),
                                Expression::Cast(Box::new(Cast {
                                    this: Expression::Literal(Literal::String(val_str)),
                                    to: DataType::BigInt { length: None },
                                    trailing_comments: vec![],
                                    double_colon_syntax: false,
                                    format: None,
                                    default: None,
                                })),
                                date,
                            ],
                        ))))
                    }
                    DialectType::Spark | DialectType::Hive => {
                        // Spark/Hive: DATE_ADD(date, val) for DAY
                        match unit_str.as_str() {
                            "DAY" => Ok(Expression::Function(Box::new(Function::new(
                                "DATE_ADD".to_string(),
                                vec![date, val],
                            )))),
                            "MONTH" => Ok(Expression::Function(Box::new(Function::new(
                                "ADD_MONTHS".to_string(),
                                vec![date, val],
                            )))),
                            _ => {
                                let iu = parse_interval_unit(&unit_str);
                                let interval =
                                    Expression::Interval(Box::new(crate::expressions::Interval {
                                        this: Some(val),
                                        unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                            unit: iu,
                                            use_plural: false,
                                        }),
                                    }));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "DATE_ADD".to_string(),
                                    vec![date, interval],
                                ))))
                            }
                        }
                    }
                    DialectType::Snowflake => {
                        // Snowflake: DATEADD(UNIT, 'val', CAST(date AS DATE))
                        let cast_date = Self::ensure_cast_date(date);
                        let val_str = Self::expr_to_string(&val);
                        Ok(Expression::Function(Box::new(Function::new(
                            "DATEADD".to_string(),
                            vec![
                                Expression::Identifier(Identifier::new(unit_str)),
                                Expression::Literal(Literal::String(val_str)),
                                cast_date,
                            ],
                        ))))
                    }
                    DialectType::TSQL | DialectType::Fabric => {
                        let cast_date = Self::ensure_cast_datetime2(date);
                        Ok(Expression::Function(Box::new(Function::new(
                            "DATEADD".to_string(),
                            vec![
                                Expression::Identifier(Identifier::new(unit_str)),
                                val,
                                cast_date,
                            ],
                        ))))
                    }
                    DialectType::Redshift => Ok(Expression::Function(Box::new(Function::new(
                        "DATEADD".to_string(),
                        vec![Expression::Identifier(Identifier::new(unit_str)), val, date],
                    )))),
                    DialectType::MySQL => {
                        // MySQL: DATE_ADD(date, INTERVAL 'val' UNIT)
                        let quoted_val = Self::quote_interval_val(&val);
                        let iu = parse_interval_unit(&unit_str);
                        let interval =
                            Expression::Interval(Box::new(crate::expressions::Interval {
                                this: Some(quoted_val),
                                unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                    unit: iu,
                                    use_plural: false,
                                }),
                            }));
                        Ok(Expression::Function(Box::new(Function::new(
                            "DATE_ADD".to_string(),
                            vec![date, interval],
                        ))))
                    }
                    DialectType::BigQuery => {
                        // BigQuery: DATE_ADD(date, INTERVAL 'val' UNIT)
                        let quoted_val = Self::quote_interval_val(&val);
                        let iu = parse_interval_unit(&unit_str);
                        let interval =
                            Expression::Interval(Box::new(crate::expressions::Interval {
                                this: Some(quoted_val),
                                unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                    unit: iu,
                                    use_plural: false,
                                }),
                            }));
                        Ok(Expression::Function(Box::new(Function::new(
                            "DATE_ADD".to_string(),
                            vec![date, interval],
                        ))))
                    }
                    DialectType::Databricks => Ok(Expression::Function(Box::new(Function::new(
                        "DATEADD".to_string(),
                        vec![Expression::Identifier(Identifier::new(unit_str)), val, date],
                    )))),
                    _ => {
                        // Default: keep as DATE_ADD with decomposed interval
                        Ok(Expression::DateAdd(Box::new(
                            crate::expressions::DateAddFunc {
                                this: date,
                                interval: val,
                                unit,
                            },
                        )))
                    }
                }
            }

            // ADD_MONTHS(date, val) -> target-specific form
            "ADD_MONTHS" if args.len() == 2 => {
                let date = args.remove(0);
                let val = args.remove(0);

                if matches!(target, DialectType::TSQL) {
                    // TSQL: DATEADD(MONTH, val, CAST(date AS DATETIME2))
                    let cast_date = Self::ensure_cast_datetime2(date);
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATEADD".to_string(),
                        vec![
                            Expression::Identifier(Identifier::new("MONTH")),
                            val,
                            cast_date,
                        ],
                    ))));
                }

                if matches!(target, DialectType::DuckDB) {
                    // DuckDB: date + INTERVAL val MONTH
                    let interval = Expression::Interval(Box::new(crate::expressions::Interval {
                        this: Some(val),
                        unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                            unit: crate::expressions::IntervalUnit::Month,
                            use_plural: false,
                        }),
                    }));
                    return Ok(Expression::Add(Box::new(
                        crate::expressions::BinaryOp::new(date, interval),
                    )));
                }

                if matches!(target, DialectType::Snowflake) {
                    // Snowflake: keep ADD_MONTHS when source is also Snowflake, else DATEADD
                    if matches!(source, DialectType::Snowflake) {
                        return Ok(Expression::Function(Box::new(Function::new(
                            "ADD_MONTHS".to_string(),
                            vec![date, val],
                        ))));
                    }
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATEADD".to_string(),
                        vec![Expression::Identifier(Identifier::new("MONTH")), val, date],
                    ))));
                }

                if matches!(target, DialectType::Spark | DialectType::Databricks) {
                    // Spark: ADD_MONTHS(date, val) - keep as is
                    return Ok(Expression::Function(Box::new(Function::new(
                        "ADD_MONTHS".to_string(),
                        vec![date, val],
                    ))));
                }

                if matches!(target, DialectType::Hive) {
                    return Ok(Expression::Function(Box::new(Function::new(
                        "ADD_MONTHS".to_string(),
                        vec![date, val],
                    ))));
                }

                if matches!(
                    target,
                    DialectType::Presto | DialectType::Trino | DialectType::Athena
                ) {
                    // Presto: DATE_ADD('MONTH', val, date)
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATE_ADD".to_string(),
                        vec![
                            Expression::Literal(Literal::String("MONTH".to_string())),
                            val,
                            date,
                        ],
                    ))));
                }

                // Default: keep ADD_MONTHS
                Ok(Expression::Function(Box::new(Function::new(
                    "ADD_MONTHS".to_string(),
                    vec![date, val],
                ))))
            }

            // SAFE_DIVIDE(x, y) -> target-specific form directly
            "SAFE_DIVIDE" if args.len() == 2 => {
                let x = args.remove(0);
                let y = args.remove(0);
                // Wrap x and y in parens if they're complex expressions
                let y_ref = match &y {
                    Expression::Column(_) | Expression::Literal(_) | Expression::Identifier(_) => {
                        y.clone()
                    }
                    _ => Expression::Paren(Box::new(Paren {
                        this: y.clone(),
                        trailing_comments: vec![],
                    })),
                };
                let x_ref = match &x {
                    Expression::Column(_) | Expression::Literal(_) | Expression::Identifier(_) => {
                        x.clone()
                    }
                    _ => Expression::Paren(Box::new(Paren {
                        this: x.clone(),
                        trailing_comments: vec![],
                    })),
                };
                let condition = Expression::Neq(Box::new(crate::expressions::BinaryOp::new(
                    y_ref.clone(),
                    Expression::number(0),
                )));
                let div_expr = Expression::Div(Box::new(crate::expressions::BinaryOp::new(
                    x_ref.clone(),
                    y_ref.clone(),
                )));

                match target {
                    DialectType::DuckDB | DialectType::PostgreSQL => {
                        // CASE WHEN y <> 0 THEN x / y ELSE NULL END
                        let result_div = if matches!(target, DialectType::PostgreSQL) {
                            let cast_x = Expression::Cast(Box::new(Cast {
                                this: x_ref,
                                to: DataType::Custom {
                                    name: "DOUBLE PRECISION".to_string(),
                                },
                                trailing_comments: vec![],
                                double_colon_syntax: false,
                                format: None,
                                default: None,
                            }));
                            Expression::Div(Box::new(crate::expressions::BinaryOp::new(
                                cast_x, y_ref,
                            )))
                        } else {
                            div_expr
                        };
                        Ok(Expression::Case(Box::new(crate::expressions::Case {
                            operand: None,
                            whens: vec![(condition, result_div)],
                            else_: Some(Expression::Null(crate::expressions::Null)),
                            comments: Vec::new(),
                        })))
                    }
                    DialectType::Snowflake => {
                        // IFF(y <> 0, x / y, NULL)
                        Ok(Expression::IfFunc(Box::new(crate::expressions::IfFunc {
                            condition,
                            true_value: div_expr,
                            false_value: Some(Expression::Null(crate::expressions::Null)),
                            original_name: Some("IFF".to_string()),
                        })))
                    }
                    DialectType::Presto | DialectType::Trino => {
                        // IF(y <> 0, CAST(x AS DOUBLE) / y, NULL)
                        let cast_x = Expression::Cast(Box::new(Cast {
                            this: x_ref,
                            to: DataType::Double {
                                precision: None,
                                scale: None,
                            },
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        }));
                        let cast_div = Expression::Div(Box::new(
                            crate::expressions::BinaryOp::new(cast_x, y_ref),
                        ));
                        Ok(Expression::IfFunc(Box::new(crate::expressions::IfFunc {
                            condition,
                            true_value: cast_div,
                            false_value: Some(Expression::Null(crate::expressions::Null)),
                            original_name: None,
                        })))
                    }
                    _ => {
                        // IF(y <> 0, x / y, NULL)
                        Ok(Expression::IfFunc(Box::new(crate::expressions::IfFunc {
                            condition,
                            true_value: div_expr,
                            false_value: Some(Expression::Null(crate::expressions::Null)),
                            original_name: None,
                        })))
                    }
                }
            }

            // GENERATE_UUID() -> UUID() with CAST to string
            "GENERATE_UUID" => {
                let uuid_expr = Expression::Uuid(Box::new(crate::expressions::Uuid {
                    this: None,
                    name: None,
                    is_string: None,
                }));
                // Most targets need CAST(UUID() AS TEXT/VARCHAR/STRING)
                let cast_type = match target {
                    DialectType::DuckDB => Some(DataType::Text),
                    DialectType::Presto | DialectType::Trino => Some(DataType::VarChar {
                        length: None,
                        parenthesized_length: false,
                    }),
                    DialectType::Spark | DialectType::Databricks | DialectType::Hive => {
                        Some(DataType::String { length: None })
                    }
                    _ => None,
                };
                if let Some(dt) = cast_type {
                    Ok(Expression::Cast(Box::new(Cast {
                        this: uuid_expr,
                        to: dt,
                        trailing_comments: vec![],
                        double_colon_syntax: false,
                        format: None,
                        default: None,
                    })))
                } else {
                    Ok(uuid_expr)
                }
            }

            // COUNTIF(x) -> CountIf expression
            "COUNTIF" if args.len() == 1 => {
                let arg = args.remove(0);
                Ok(Expression::CountIf(Box::new(crate::expressions::AggFunc {
                    this: arg,
                    distinct: false,
                    filter: None,
                    order_by: vec![],
                    name: None,
                    ignore_nulls: None,
                    having_max: None,
                    limit: None,
                })))
            }

            // EDIT_DISTANCE(col1, col2, ...) -> Levenshtein expression
            "EDIT_DISTANCE" => {
                // Strip named arguments (max_distance => N) and pass as positional
                let mut positional_args: Vec<Expression> = vec![];
                for arg in args {
                    match arg {
                        Expression::NamedArgument(na) => {
                            positional_args.push(na.value);
                        }
                        other => positional_args.push(other),
                    }
                }
                if positional_args.len() >= 2 {
                    let col1 = positional_args.remove(0);
                    let col2 = positional_args.remove(0);
                    let levenshtein = crate::expressions::BinaryFunc {
                        this: col1,
                        expression: col2,
                        original_name: None,
                    };
                    // Pass extra args through a function wrapper with all args
                    if !positional_args.is_empty() {
                        let max_dist = positional_args.remove(0);
                        // DuckDB: CASE WHEN LEVENSHTEIN(a, b) IS NULL OR max IS NULL THEN NULL ELSE LEAST(LEVENSHTEIN(a, b), max) END
                        if matches!(target, DialectType::DuckDB) {
                            let lev = Expression::Function(Box::new(Function::new(
                                "LEVENSHTEIN".to_string(),
                                vec![levenshtein.this, levenshtein.expression],
                            )));
                            let lev_is_null =
                                Expression::IsNull(Box::new(crate::expressions::IsNull {
                                    this: lev.clone(),
                                    not: false,
                                    postfix_form: false,
                                }));
                            let max_is_null =
                                Expression::IsNull(Box::new(crate::expressions::IsNull {
                                    this: max_dist.clone(),
                                    not: false,
                                    postfix_form: false,
                                }));
                            let null_check =
                                Expression::Or(Box::new(crate::expressions::BinaryOp {
                                    left: lev_is_null,
                                    right: max_is_null,
                                    left_comments: Vec::new(),
                                    operator_comments: Vec::new(),
                                    trailing_comments: Vec::new(),
                                }));
                            let least =
                                Expression::Least(Box::new(crate::expressions::VarArgFunc {
                                    expressions: vec![lev, max_dist],
                                    original_name: None,
                                }));
                            return Ok(Expression::Case(Box::new(crate::expressions::Case {
                                operand: None,
                                whens: vec![(
                                    null_check,
                                    Expression::Null(crate::expressions::Null),
                                )],
                                else_: Some(least),
                                comments: Vec::new(),
                            })));
                        }
                        let mut all_args = vec![levenshtein.this, levenshtein.expression, max_dist];
                        all_args.extend(positional_args);
                        // PostgreSQL: use LEVENSHTEIN_LESS_EQUAL when max_distance is provided
                        let func_name = if matches!(target, DialectType::PostgreSQL) {
                            "LEVENSHTEIN_LESS_EQUAL"
                        } else {
                            "LEVENSHTEIN"
                        };
                        return Ok(Expression::Function(Box::new(Function::new(
                            func_name.to_string(),
                            all_args,
                        ))));
                    }
                    Ok(Expression::Levenshtein(Box::new(levenshtein)))
                } else {
                    Ok(Expression::Function(Box::new(Function::new(
                        "EDIT_DISTANCE".to_string(),
                        positional_args,
                    ))))
                }
            }

            // TIMESTAMP_SECONDS(x) -> UnixToTime with scale 0
            "TIMESTAMP_SECONDS" if args.len() == 1 => {
                let arg = args.remove(0);
                Ok(Expression::UnixToTime(Box::new(
                    crate::expressions::UnixToTime {
                        this: Box::new(arg),
                        scale: Some(0),
                        zone: None,
                        hours: None,
                        minutes: None,
                        format: None,
                        target_type: None,
                    },
                )))
            }

            // TIMESTAMP_MILLIS(x) -> UnixToTime with scale 3
            "TIMESTAMP_MILLIS" if args.len() == 1 => {
                let arg = args.remove(0);
                Ok(Expression::UnixToTime(Box::new(
                    crate::expressions::UnixToTime {
                        this: Box::new(arg),
                        scale: Some(3),
                        zone: None,
                        hours: None,
                        minutes: None,
                        format: None,
                        target_type: None,
                    },
                )))
            }

            // TIMESTAMP_MICROS(x) -> UnixToTime with scale 6
            "TIMESTAMP_MICROS" if args.len() == 1 => {
                let arg = args.remove(0);
                Ok(Expression::UnixToTime(Box::new(
                    crate::expressions::UnixToTime {
                        this: Box::new(arg),
                        scale: Some(6),
                        zone: None,
                        hours: None,
                        minutes: None,
                        format: None,
                        target_type: None,
                    },
                )))
            }

            // DIV(x, y) -> IntDiv expression
            "DIV" if args.len() == 2 => {
                let x = args.remove(0);
                let y = args.remove(0);
                Ok(Expression::IntDiv(Box::new(
                    crate::expressions::BinaryFunc {
                        this: x,
                        expression: y,
                        original_name: None,
                    },
                )))
            }

            // TO_HEX(x) -> target-specific form
            "TO_HEX" if args.len() == 1 => {
                let arg = args.remove(0);
                // Check if inner function already returns hex string in certain targets
                let inner_returns_hex = matches!(&arg, Expression::Function(f) if matches!(f.name.as_str(), "MD5" | "SHA1" | "SHA256" | "SHA512"));
                if matches!(target, DialectType::BigQuery) {
                    // BQ->BQ: keep as TO_HEX
                    Ok(Expression::Function(Box::new(Function::new(
                        "TO_HEX".to_string(),
                        vec![arg],
                    ))))
                } else if matches!(target, DialectType::DuckDB) && inner_returns_hex {
                    // DuckDB: MD5/SHA already return hex strings, so TO_HEX is redundant
                    Ok(arg)
                } else if matches!(target, DialectType::Snowflake) && inner_returns_hex {
                    // Snowflake: TO_HEX(SHA1(x)) -> TO_CHAR(SHA1_BINARY(x))
                    // TO_HEX(MD5(x)) -> TO_CHAR(MD5_BINARY(x))
                    // TO_HEX(SHA256(x)) -> TO_CHAR(SHA2_BINARY(x, 256))
                    // TO_HEX(SHA512(x)) -> TO_CHAR(SHA2_BINARY(x, 512))
                    if let Expression::Function(ref inner_f) = arg {
                        let inner_args = inner_f.args.clone();
                        let binary_func = match inner_f.name.to_uppercase().as_str() {
                            "SHA1" => Expression::Function(Box::new(Function::new(
                                "SHA1_BINARY".to_string(),
                                inner_args,
                            ))),
                            "MD5" => Expression::Function(Box::new(Function::new(
                                "MD5_BINARY".to_string(),
                                inner_args,
                            ))),
                            "SHA256" => {
                                let mut a = inner_args;
                                a.push(Expression::number(256));
                                Expression::Function(Box::new(Function::new(
                                    "SHA2_BINARY".to_string(),
                                    a,
                                )))
                            }
                            "SHA512" => {
                                let mut a = inner_args;
                                a.push(Expression::number(512));
                                Expression::Function(Box::new(Function::new(
                                    "SHA2_BINARY".to_string(),
                                    a,
                                )))
                            }
                            _ => arg.clone(),
                        };
                        Ok(Expression::Function(Box::new(Function::new(
                            "TO_CHAR".to_string(),
                            vec![binary_func],
                        ))))
                    } else {
                        let inner = Expression::Function(Box::new(Function::new(
                            "HEX".to_string(),
                            vec![arg],
                        )));
                        Ok(Expression::Lower(Box::new(
                            crate::expressions::UnaryFunc::new(inner),
                        )))
                    }
                } else if matches!(target, DialectType::Presto | DialectType::Trino) {
                    let inner = Expression::Function(Box::new(Function::new(
                        "TO_HEX".to_string(),
                        vec![arg],
                    )));
                    Ok(Expression::Lower(Box::new(
                        crate::expressions::UnaryFunc::new(inner),
                    )))
                } else {
                    let inner =
                        Expression::Function(Box::new(Function::new("HEX".to_string(), vec![arg])));
                    Ok(Expression::Lower(Box::new(
                        crate::expressions::UnaryFunc::new(inner),
                    )))
                }
            }

            // LAST_DAY(date, unit) -> strip unit for most targets, or transform for PostgreSQL
            "LAST_DAY" if args.len() == 2 => {
                let date = args.remove(0);
                let _unit = args.remove(0); // Strip the unit (MONTH is default)
                Ok(Expression::Function(Box::new(Function::new(
                    "LAST_DAY".to_string(),
                    vec![date],
                ))))
            }

            // GENERATE_ARRAY(start, end, step?) -> GenerateSeries expression
            "GENERATE_ARRAY" => {
                let start = args.get(0).cloned();
                let end = args.get(1).cloned();
                let step = args.get(2).cloned();
                Ok(Expression::GenerateSeries(Box::new(
                    crate::expressions::GenerateSeries {
                        start: start.map(Box::new),
                        end: end.map(Box::new),
                        step: step.map(Box::new),
                        is_end_exclusive: None,
                    },
                )))
            }

            // GENERATE_TIMESTAMP_ARRAY(start, end, step) -> GenerateSeries expression
            "GENERATE_TIMESTAMP_ARRAY" => {
                let start = args.get(0).cloned();
                let end = args.get(1).cloned();
                let step = args.get(2).cloned();

                if matches!(target, DialectType::DuckDB) {
                    // DuckDB: GENERATE_SERIES(CAST(start AS TIMESTAMP), CAST(end AS TIMESTAMP), step)
                    // Only cast string literals - leave columns/expressions as-is
                    let maybe_cast_ts = |expr: Expression| -> Expression {
                        if matches!(&expr, Expression::Literal(Literal::String(_))) {
                            Expression::Cast(Box::new(Cast {
                                this: expr,
                                to: DataType::Timestamp {
                                    precision: None,
                                    timezone: false,
                                },
                                trailing_comments: vec![],
                                double_colon_syntax: false,
                                format: None,
                                default: None,
                            }))
                        } else {
                            expr
                        }
                    };
                    let cast_start = start.map(maybe_cast_ts);
                    let cast_end = end.map(maybe_cast_ts);
                    Ok(Expression::GenerateSeries(Box::new(
                        crate::expressions::GenerateSeries {
                            start: cast_start.map(Box::new),
                            end: cast_end.map(Box::new),
                            step: step.map(Box::new),
                            is_end_exclusive: None,
                        },
                    )))
                } else {
                    Ok(Expression::GenerateSeries(Box::new(
                        crate::expressions::GenerateSeries {
                            start: start.map(Box::new),
                            end: end.map(Box::new),
                            step: step.map(Box::new),
                            is_end_exclusive: None,
                        },
                    )))
                }
            }

            // TO_JSON(x) -> target-specific (from Spark/Hive)
            "TO_JSON" => {
                match target {
                    DialectType::Presto | DialectType::Trino => {
                        // JSON_FORMAT(CAST(x AS JSON))
                        let arg = args
                            .into_iter()
                            .next()
                            .unwrap_or(Expression::Null(crate::expressions::Null));
                        let cast_json = Expression::Cast(Box::new(Cast {
                            this: arg,
                            to: DataType::Custom {
                                name: "JSON".to_string(),
                            },
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        }));
                        Ok(Expression::Function(Box::new(Function::new(
                            "JSON_FORMAT".to_string(),
                            vec![cast_json],
                        ))))
                    }
                    DialectType::BigQuery => Ok(Expression::Function(Box::new(Function::new(
                        "TO_JSON_STRING".to_string(),
                        args,
                    )))),
                    DialectType::DuckDB => {
                        // CAST(TO_JSON(x) AS TEXT)
                        let arg = args
                            .into_iter()
                            .next()
                            .unwrap_or(Expression::Null(crate::expressions::Null));
                        let to_json = Expression::Function(Box::new(Function::new(
                            "TO_JSON".to_string(),
                            vec![arg],
                        )));
                        Ok(Expression::Cast(Box::new(Cast {
                            this: to_json,
                            to: DataType::Text,
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        })))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "TO_JSON".to_string(),
                        args,
                    )))),
                }
            }

            // TO_JSON_STRING(x) -> target-specific
            "TO_JSON_STRING" => {
                match target {
                    DialectType::Spark | DialectType::Databricks | DialectType::Hive => Ok(
                        Expression::Function(Box::new(Function::new("TO_JSON".to_string(), args))),
                    ),
                    DialectType::Presto | DialectType::Trino => {
                        // JSON_FORMAT(CAST(x AS JSON))
                        let arg = args
                            .into_iter()
                            .next()
                            .unwrap_or(Expression::Null(crate::expressions::Null));
                        let cast_json = Expression::Cast(Box::new(Cast {
                            this: arg,
                            to: DataType::Custom {
                                name: "JSON".to_string(),
                            },
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        }));
                        Ok(Expression::Function(Box::new(Function::new(
                            "JSON_FORMAT".to_string(),
                            vec![cast_json],
                        ))))
                    }
                    DialectType::DuckDB => {
                        // CAST(TO_JSON(x) AS TEXT)
                        let arg = args
                            .into_iter()
                            .next()
                            .unwrap_or(Expression::Null(crate::expressions::Null));
                        let to_json = Expression::Function(Box::new(Function::new(
                            "TO_JSON".to_string(),
                            vec![arg],
                        )));
                        Ok(Expression::Cast(Box::new(Cast {
                            this: to_json,
                            to: DataType::Text,
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        })))
                    }
                    DialectType::Snowflake => {
                        // TO_JSON(x)
                        Ok(Expression::Function(Box::new(Function::new(
                            "TO_JSON".to_string(),
                            args,
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "TO_JSON_STRING".to_string(),
                        args,
                    )))),
                }
            }

            // SAFE_ADD(x, y) -> SafeAdd expression
            "SAFE_ADD" if args.len() == 2 => {
                let x = args.remove(0);
                let y = args.remove(0);
                Ok(Expression::SafeAdd(Box::new(crate::expressions::SafeAdd {
                    this: Box::new(x),
                    expression: Box::new(y),
                })))
            }

            // SAFE_SUBTRACT(x, y) -> SafeSubtract expression
            "SAFE_SUBTRACT" if args.len() == 2 => {
                let x = args.remove(0);
                let y = args.remove(0);
                Ok(Expression::SafeSubtract(Box::new(
                    crate::expressions::SafeSubtract {
                        this: Box::new(x),
                        expression: Box::new(y),
                    },
                )))
            }

            // SAFE_MULTIPLY(x, y) -> SafeMultiply expression
            "SAFE_MULTIPLY" if args.len() == 2 => {
                let x = args.remove(0);
                let y = args.remove(0);
                Ok(Expression::SafeMultiply(Box::new(
                    crate::expressions::SafeMultiply {
                        this: Box::new(x),
                        expression: Box::new(y),
                    },
                )))
            }

            // REGEXP_CONTAINS(str, pattern) -> RegexpLike expression
            "REGEXP_CONTAINS" if args.len() == 2 => {
                let str_expr = args.remove(0);
                let pattern = args.remove(0);
                Ok(Expression::RegexpLike(Box::new(
                    crate::expressions::RegexpFunc {
                        this: str_expr,
                        pattern,
                        flags: None,
                    },
                )))
            }

            // CONTAINS_SUBSTR(a, b) -> CONTAINS(LOWER(a), LOWER(b))
            "CONTAINS_SUBSTR" if args.len() == 2 => {
                let a = args.remove(0);
                let b = args.remove(0);
                let lower_a = Expression::Lower(Box::new(crate::expressions::UnaryFunc::new(a)));
                let lower_b = Expression::Lower(Box::new(crate::expressions::UnaryFunc::new(b)));
                Ok(Expression::Function(Box::new(Function::new(
                    "CONTAINS".to_string(),
                    vec![lower_a, lower_b],
                ))))
            }

            // INT64(x) -> CAST(x AS BIGINT)
            "INT64" if args.len() == 1 => {
                let arg = args.remove(0);
                Ok(Expression::Cast(Box::new(Cast {
                    this: arg,
                    to: DataType::BigInt { length: None },
                    trailing_comments: vec![],
                    double_colon_syntax: false,
                    format: None,
                    default: None,
                })))
            }

            // INSTR(str, substr) -> target-specific
            "INSTR" if args.len() >= 2 => {
                let str_expr = args.remove(0);
                let substr = args.remove(0);
                if matches!(target, DialectType::Snowflake) {
                    // CHARINDEX(substr, str)
                    Ok(Expression::Function(Box::new(Function::new(
                        "CHARINDEX".to_string(),
                        vec![substr, str_expr],
                    ))))
                } else if matches!(target, DialectType::BigQuery) {
                    // Keep as INSTR
                    Ok(Expression::Function(Box::new(Function::new(
                        "INSTR".to_string(),
                        vec![str_expr, substr],
                    ))))
                } else {
                    // Default: keep as INSTR
                    Ok(Expression::Function(Box::new(Function::new(
                        "INSTR".to_string(),
                        vec![str_expr, substr],
                    ))))
                }
            }

            // BigQuery DATE_TRUNC(expr, unit) -> DATE_TRUNC('unit', expr) for standard SQL
            "DATE_TRUNC" if args.len() == 2 => {
                let expr = args.remove(0);
                let unit_expr = args.remove(0);
                let unit_str = get_unit_str(&unit_expr);

                match target {
                    DialectType::DuckDB
                    | DialectType::Snowflake
                    | DialectType::PostgreSQL
                    | DialectType::Presto
                    | DialectType::Trino
                    | DialectType::Databricks
                    | DialectType::Spark
                    | DialectType::Redshift
                    | DialectType::ClickHouse
                    | DialectType::TSQL => {
                        // Standard: DATE_TRUNC('UNIT', expr)
                        Ok(Expression::Function(Box::new(Function::new(
                            "DATE_TRUNC".to_string(),
                            vec![Expression::Literal(Literal::String(unit_str)), expr],
                        ))))
                    }
                    _ => {
                        // Keep BigQuery arg order: DATE_TRUNC(expr, unit)
                        Ok(Expression::Function(Box::new(Function::new(
                            "DATE_TRUNC".to_string(),
                            vec![expr, unit_expr],
                        ))))
                    }
                }
            }

            // TIMESTAMP_TRUNC / DATETIME_TRUNC -> target-specific
            "TIMESTAMP_TRUNC" | "DATETIME_TRUNC" if args.len() >= 2 => {
                // TIMESTAMP_TRUNC(ts, unit) or TIMESTAMP_TRUNC(ts, unit, timezone)
                let ts = args.remove(0);
                let unit_expr = args.remove(0);
                let tz = if !args.is_empty() {
                    Some(args.remove(0))
                } else {
                    None
                };
                let unit_str = get_unit_str(&unit_expr);

                match target {
                    DialectType::DuckDB => {
                        // DuckDB: DATE_TRUNC('UNIT', CAST(ts AS TIMESTAMPTZ))
                        // With timezone: DATE_TRUNC('UNIT', ts AT TIME ZONE 'tz') AT TIME ZONE 'tz' (for DAY granularity)
                        // Without timezone for MINUTE+ granularity: just DATE_TRUNC
                        let is_coarse = matches!(
                            unit_str.as_str(),
                            "DAY" | "WEEK" | "MONTH" | "QUARTER" | "YEAR"
                        );
                        // For DATETIME_TRUNC, cast string args to TIMESTAMP
                        let cast_ts = if name == "DATETIME_TRUNC" {
                            match ts {
                                Expression::Literal(Literal::String(ref _s)) => {
                                    Expression::Cast(Box::new(Cast {
                                        this: ts,
                                        to: DataType::Timestamp {
                                            precision: None,
                                            timezone: false,
                                        },
                                        trailing_comments: vec![],
                                        double_colon_syntax: false,
                                        format: None,
                                        default: None,
                                    }))
                                }
                                _ => Self::maybe_cast_ts_to_tz(ts, &name),
                            }
                        } else {
                            Self::maybe_cast_ts_to_tz(ts, &name)
                        };

                        if let Some(tz_arg) = tz {
                            if is_coarse {
                                // DATE_TRUNC('UNIT', ts AT TIME ZONE 'tz') AT TIME ZONE 'tz'
                                let at_tz = Expression::AtTimeZone(Box::new(
                                    crate::expressions::AtTimeZone {
                                        this: cast_ts,
                                        zone: tz_arg.clone(),
                                    },
                                ));
                                let date_trunc = Expression::Function(Box::new(Function::new(
                                    "DATE_TRUNC".to_string(),
                                    vec![Expression::Literal(Literal::String(unit_str)), at_tz],
                                )));
                                Ok(Expression::AtTimeZone(Box::new(
                                    crate::expressions::AtTimeZone {
                                        this: date_trunc,
                                        zone: tz_arg,
                                    },
                                )))
                            } else {
                                // For MINUTE/HOUR: no AT TIME ZONE wrapper, just DATE_TRUNC('UNIT', ts)
                                Ok(Expression::Function(Box::new(Function::new(
                                    "DATE_TRUNC".to_string(),
                                    vec![Expression::Literal(Literal::String(unit_str)), cast_ts],
                                ))))
                            }
                        } else {
                            // No timezone: DATE_TRUNC('UNIT', CAST(ts AS TIMESTAMPTZ))
                            Ok(Expression::Function(Box::new(Function::new(
                                "DATE_TRUNC".to_string(),
                                vec![Expression::Literal(Literal::String(unit_str)), cast_ts],
                            ))))
                        }
                    }
                    DialectType::Databricks | DialectType::Spark => {
                        // Databricks/Spark: DATE_TRUNC('UNIT', ts)
                        Ok(Expression::Function(Box::new(Function::new(
                            "DATE_TRUNC".to_string(),
                            vec![Expression::Literal(Literal::String(unit_str)), ts],
                        ))))
                    }
                    _ => {
                        // Default: keep as TIMESTAMP_TRUNC('UNIT', ts, [tz])
                        let unit = Expression::Literal(Literal::String(unit_str));
                        let mut date_trunc_args = vec![unit, ts];
                        if let Some(tz_arg) = tz {
                            date_trunc_args.push(tz_arg);
                        }
                        Ok(Expression::Function(Box::new(Function::new(
                            "TIMESTAMP_TRUNC".to_string(),
                            date_trunc_args,
                        ))))
                    }
                }
            }

            // TIME(h, m, s) -> target-specific, TIME('string') -> CAST('string' AS TIME)
            "TIME" => {
                if args.len() == 3 {
                    // TIME(h, m, s) constructor
                    match target {
                        DialectType::TSQL => {
                            // TIMEFROMPARTS(h, m, s, 0, 0)
                            args.push(Expression::number(0));
                            args.push(Expression::number(0));
                            Ok(Expression::Function(Box::new(Function::new(
                                "TIMEFROMPARTS".to_string(),
                                args,
                            ))))
                        }
                        DialectType::MySQL => Ok(Expression::Function(Box::new(Function::new(
                            "MAKETIME".to_string(),
                            args,
                        )))),
                        DialectType::PostgreSQL => Ok(Expression::Function(Box::new(
                            Function::new("MAKE_TIME".to_string(), args),
                        ))),
                        _ => Ok(Expression::Function(Box::new(Function::new(
                            "TIME".to_string(),
                            args,
                        )))),
                    }
                } else if args.len() == 1 {
                    let arg = args.remove(0);
                    if matches!(target, DialectType::Spark) {
                        // Spark: CAST(x AS TIMESTAMP) (yes, TIMESTAMP not TIME)
                        Ok(Expression::Cast(Box::new(Cast {
                            this: arg,
                            to: DataType::Timestamp {
                                timezone: false,
                                precision: None,
                            },
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        })))
                    } else {
                        // Most targets: CAST(x AS TIME)
                        Ok(Expression::Cast(Box::new(Cast {
                            this: arg,
                            to: DataType::Time {
                                precision: None,
                                timezone: false,
                            },
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        })))
                    }
                } else if args.len() == 2 {
                    // TIME(expr, timezone) -> CAST(CAST(expr AS TIMESTAMPTZ) AT TIME ZONE tz AS TIME)
                    let expr = args.remove(0);
                    let tz = args.remove(0);
                    let cast_tstz = Expression::Cast(Box::new(Cast {
                        this: expr,
                        to: DataType::Timestamp {
                            timezone: true,
                            precision: None,
                        },
                        trailing_comments: vec![],
                        double_colon_syntax: false,
                        format: None,
                        default: None,
                    }));
                    let at_tz = Expression::AtTimeZone(Box::new(crate::expressions::AtTimeZone {
                        this: cast_tstz,
                        zone: tz,
                    }));
                    Ok(Expression::Cast(Box::new(Cast {
                        this: at_tz,
                        to: DataType::Time {
                            precision: None,
                            timezone: false,
                        },
                        trailing_comments: vec![],
                        double_colon_syntax: false,
                        format: None,
                        default: None,
                    })))
                } else {
                    Ok(Expression::Function(Box::new(Function::new(
                        "TIME".to_string(),
                        args,
                    ))))
                }
            }

            // DATETIME('string') -> CAST('string' AS TIMESTAMP)
            // DATETIME('date', TIME 'time') -> CAST(CAST('date' AS DATE) + CAST('time' AS TIME) AS TIMESTAMP)
            // DATETIME('string', 'timezone') -> CAST(CAST('string' AS TIMESTAMPTZ) AT TIME ZONE tz AS TIMESTAMP)
            // DATETIME(y, m, d, h, min, s) -> target-specific
            "DATETIME" => {
                // For BigQuery target: keep DATETIME function but convert TIME literal to CAST
                if matches!(target, DialectType::BigQuery) {
                    if args.len() == 2 {
                        let has_time_literal =
                            matches!(&args[1], Expression::Literal(Literal::Time(_)));
                        if has_time_literal {
                            let first = args.remove(0);
                            let second = args.remove(0);
                            let time_as_cast = match second {
                                Expression::Literal(Literal::Time(s)) => {
                                    Expression::Cast(Box::new(Cast {
                                        this: Expression::Literal(Literal::String(s)),
                                        to: DataType::Time {
                                            precision: None,
                                            timezone: false,
                                        },
                                        trailing_comments: vec![],
                                        double_colon_syntax: false,
                                        format: None,
                                        default: None,
                                    }))
                                }
                                other => other,
                            };
                            return Ok(Expression::Function(Box::new(Function::new(
                                "DATETIME".to_string(),
                                vec![first, time_as_cast],
                            ))));
                        }
                    }
                    return Ok(Expression::Function(Box::new(Function::new(
                        "DATETIME".to_string(),
                        args,
                    ))));
                }

                if args.len() == 1 {
                    let arg = args.remove(0);
                    Ok(Expression::Cast(Box::new(Cast {
                        this: arg,
                        to: DataType::Timestamp {
                            timezone: false,
                            precision: None,
                        },
                        trailing_comments: vec![],
                        double_colon_syntax: false,
                        format: None,
                        default: None,
                    })))
                } else if args.len() == 2 {
                    let first = args.remove(0);
                    let second = args.remove(0);
                    // Check if second arg is a TIME literal
                    let is_time_literal = matches!(&second, Expression::Literal(Literal::Time(_)));
                    if is_time_literal {
                        // DATETIME('date', TIME 'time') -> CAST(CAST(date AS DATE) + CAST('time' AS TIME) AS TIMESTAMP)
                        let cast_date = Expression::Cast(Box::new(Cast {
                            this: first,
                            to: DataType::Date,
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        }));
                        // Convert TIME 'x' literal to string 'x' so CAST produces CAST('x' AS TIME) not CAST(TIME 'x' AS TIME)
                        let time_as_string = match second {
                            Expression::Literal(Literal::Time(s)) => {
                                Expression::Literal(Literal::String(s))
                            }
                            other => other,
                        };
                        let cast_time = Expression::Cast(Box::new(Cast {
                            this: time_as_string,
                            to: DataType::Time {
                                precision: None,
                                timezone: false,
                            },
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        }));
                        let add_expr =
                            Expression::Add(Box::new(BinaryOp::new(cast_date, cast_time)));
                        Ok(Expression::Cast(Box::new(Cast {
                            this: add_expr,
                            to: DataType::Timestamp {
                                timezone: false,
                                precision: None,
                            },
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        })))
                    } else {
                        // DATETIME('string', 'timezone')
                        let cast_tstz = Expression::Cast(Box::new(Cast {
                            this: first,
                            to: DataType::Timestamp {
                                timezone: true,
                                precision: None,
                            },
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        }));
                        let at_tz =
                            Expression::AtTimeZone(Box::new(crate::expressions::AtTimeZone {
                                this: cast_tstz,
                                zone: second,
                            }));
                        Ok(Expression::Cast(Box::new(Cast {
                            this: at_tz,
                            to: DataType::Timestamp {
                                timezone: false,
                                precision: None,
                            },
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        })))
                    }
                } else if args.len() >= 3 {
                    // DATETIME(y, m, d, h, min, s) -> TIMESTAMP_FROM_PARTS for Snowflake
                    // For other targets, use MAKE_TIMESTAMP or similar
                    if matches!(target, DialectType::Snowflake) {
                        Ok(Expression::Function(Box::new(Function::new(
                            "TIMESTAMP_FROM_PARTS".to_string(),
                            args,
                        ))))
                    } else {
                        Ok(Expression::Function(Box::new(Function::new(
                            "DATETIME".to_string(),
                            args,
                        ))))
                    }
                } else {
                    Ok(Expression::Function(Box::new(Function::new(
                        "DATETIME".to_string(),
                        args,
                    ))))
                }
            }

            // TIMESTAMP(x) -> CAST(x AS TIMESTAMP WITH TIME ZONE) for Presto
            // TIMESTAMP(x, tz) -> CAST(x AS TIMESTAMP) AT TIME ZONE tz for DuckDB
            "TIMESTAMP" => {
                if args.len() == 1 {
                    let arg = args.remove(0);
                    Ok(Expression::Cast(Box::new(Cast {
                        this: arg,
                        to: DataType::Timestamp {
                            timezone: true,
                            precision: None,
                        },
                        trailing_comments: vec![],
                        double_colon_syntax: false,
                        format: None,
                        default: None,
                    })))
                } else if args.len() == 2 {
                    let arg = args.remove(0);
                    let tz = args.remove(0);
                    let cast_ts = Expression::Cast(Box::new(Cast {
                        this: arg,
                        to: DataType::Timestamp {
                            timezone: false,
                            precision: None,
                        },
                        trailing_comments: vec![],
                        double_colon_syntax: false,
                        format: None,
                        default: None,
                    }));
                    if matches!(target, DialectType::Snowflake) {
                        // CONVERT_TIMEZONE('tz', CAST(x AS TIMESTAMP))
                        Ok(Expression::Function(Box::new(Function::new(
                            "CONVERT_TIMEZONE".to_string(),
                            vec![tz, cast_ts],
                        ))))
                    } else {
                        Ok(Expression::AtTimeZone(Box::new(
                            crate::expressions::AtTimeZone {
                                this: cast_ts,
                                zone: tz,
                            },
                        )))
                    }
                } else {
                    Ok(Expression::Function(Box::new(Function::new(
                        "TIMESTAMP".to_string(),
                        args,
                    ))))
                }
            }

            // STRING(x) -> CAST(x AS VARCHAR/TEXT)
            // STRING(x, tz) -> CAST(CAST(x AS TIMESTAMP) AT TIME ZONE 'UTC' AT TIME ZONE tz AS VARCHAR/TEXT)
            "STRING" => {
                if args.len() == 1 {
                    let arg = args.remove(0);
                    let cast_type = match target {
                        DialectType::DuckDB => DataType::Text,
                        _ => DataType::VarChar {
                            length: None,
                            parenthesized_length: false,
                        },
                    };
                    Ok(Expression::Cast(Box::new(Cast {
                        this: arg,
                        to: cast_type,
                        trailing_comments: vec![],
                        double_colon_syntax: false,
                        format: None,
                        default: None,
                    })))
                } else if args.len() == 2 {
                    let arg = args.remove(0);
                    let tz = args.remove(0);
                    let cast_type = match target {
                        DialectType::DuckDB => DataType::Text,
                        _ => DataType::VarChar {
                            length: None,
                            parenthesized_length: false,
                        },
                    };
                    if matches!(target, DialectType::Snowflake) {
                        // STRING(x, tz) -> CAST(CONVERT_TIMEZONE('UTC', tz, x) AS VARCHAR)
                        let convert_tz = Expression::Function(Box::new(Function::new(
                            "CONVERT_TIMEZONE".to_string(),
                            vec![
                                Expression::Literal(Literal::String("UTC".to_string())),
                                tz,
                                arg,
                            ],
                        )));
                        Ok(Expression::Cast(Box::new(Cast {
                            this: convert_tz,
                            to: cast_type,
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        })))
                    } else {
                        // STRING(x, tz) -> CAST(CAST(x AS TIMESTAMP) AT TIME ZONE 'UTC' AT TIME ZONE tz AS TEXT/VARCHAR)
                        let cast_ts = Expression::Cast(Box::new(Cast {
                            this: arg,
                            to: DataType::Timestamp {
                                timezone: false,
                                precision: None,
                            },
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        }));
                        let at_utc =
                            Expression::AtTimeZone(Box::new(crate::expressions::AtTimeZone {
                                this: cast_ts,
                                zone: Expression::Literal(Literal::String("UTC".to_string())),
                            }));
                        let at_tz =
                            Expression::AtTimeZone(Box::new(crate::expressions::AtTimeZone {
                                this: at_utc,
                                zone: tz,
                            }));
                        Ok(Expression::Cast(Box::new(Cast {
                            this: at_tz,
                            to: cast_type,
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        })))
                    }
                } else {
                    Ok(Expression::Function(Box::new(Function::new(
                        "STRING".to_string(),
                        args,
                    ))))
                }
            }

            // UNIX_SECONDS, UNIX_MILLIS, UNIX_MICROS as functions (not expressions)
            "UNIX_SECONDS" if args.len() == 1 => {
                let ts = args.remove(0);
                match target {
                    DialectType::DuckDB => {
                        // CAST(EPOCH(CAST(ts AS TIMESTAMPTZ)) AS BIGINT)
                        let cast_ts = Self::ensure_cast_timestamptz(ts);
                        let epoch = Expression::Function(Box::new(Function::new(
                            "EPOCH".to_string(),
                            vec![cast_ts],
                        )));
                        Ok(Expression::Cast(Box::new(Cast {
                            this: epoch,
                            to: DataType::BigInt { length: None },
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        })))
                    }
                    DialectType::Snowflake => {
                        // TIMESTAMPDIFF(SECONDS, CAST('1970-01-01 00:00:00+00' AS TIMESTAMPTZ), ts)
                        let epoch = Expression::Cast(Box::new(Cast {
                            this: Expression::Literal(Literal::String(
                                "1970-01-01 00:00:00+00".to_string(),
                            )),
                            to: DataType::Timestamp {
                                timezone: true,
                                precision: None,
                            },
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        }));
                        Ok(Expression::TimestampDiff(Box::new(
                            crate::expressions::TimestampDiff {
                                this: Box::new(epoch),
                                expression: Box::new(ts),
                                unit: Some("SECONDS".to_string()),
                            },
                        )))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "UNIX_SECONDS".to_string(),
                        vec![ts],
                    )))),
                }
            }

            "UNIX_MILLIS" if args.len() == 1 => {
                let ts = args.remove(0);
                match target {
                    DialectType::DuckDB => {
                        // EPOCH_MS(CAST(ts AS TIMESTAMPTZ))
                        let cast_ts = Self::ensure_cast_timestamptz(ts);
                        Ok(Expression::Function(Box::new(Function::new(
                            "EPOCH_MS".to_string(),
                            vec![cast_ts],
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "UNIX_MILLIS".to_string(),
                        vec![ts],
                    )))),
                }
            }

            "UNIX_MICROS" if args.len() == 1 => {
                let ts = args.remove(0);
                match target {
                    DialectType::DuckDB => {
                        // EPOCH_US(CAST(ts AS TIMESTAMPTZ))
                        let cast_ts = Self::ensure_cast_timestamptz(ts);
                        Ok(Expression::Function(Box::new(Function::new(
                            "EPOCH_US".to_string(),
                            vec![cast_ts],
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "UNIX_MICROS".to_string(),
                        vec![ts],
                    )))),
                }
            }

            // ARRAY_CONCAT / LIST_CONCAT -> target-specific
            "ARRAY_CONCAT" | "LIST_CONCAT" => {
                match target {
                    DialectType::Spark | DialectType::Databricks | DialectType::Hive => {
                        // CONCAT(arr1, arr2, ...)
                        Ok(Expression::Function(Box::new(Function::new(
                            "CONCAT".to_string(),
                            args,
                        ))))
                    }
                    DialectType::Presto | DialectType::Trino => {
                        // CONCAT(arr1, arr2, ...)
                        Ok(Expression::Function(Box::new(Function::new(
                            "CONCAT".to_string(),
                            args,
                        ))))
                    }
                    DialectType::Snowflake => {
                        // ARRAY_CAT(arr1, ARRAY_CAT(arr2, arr3))
                        if args.len() == 1 {
                            // ARRAY_CAT requires 2 args, add empty array as []
                            let empty_arr = Expression::ArrayFunc(Box::new(
                                crate::expressions::ArrayConstructor {
                                    expressions: vec![],
                                    bracket_notation: true,
                                    use_list_keyword: false,
                                },
                            ));
                            let mut new_args = args;
                            new_args.push(empty_arr);
                            Ok(Expression::Function(Box::new(Function::new(
                                "ARRAY_CAT".to_string(),
                                new_args,
                            ))))
                        } else if args.is_empty() {
                            Ok(Expression::Function(Box::new(Function::new(
                                "ARRAY_CAT".to_string(),
                                args,
                            ))))
                        } else {
                            let mut it = args.into_iter().rev();
                            let mut result = it.next().unwrap();
                            for arr in it {
                                result = Expression::Function(Box::new(Function::new(
                                    "ARRAY_CAT".to_string(),
                                    vec![arr, result],
                                )));
                            }
                            Ok(result)
                        }
                    }
                    DialectType::PostgreSQL => {
                        // ARRAY_CAT(arr1, ARRAY_CAT(arr2, arr3))
                        if args.len() <= 1 {
                            Ok(Expression::Function(Box::new(Function::new(
                                "ARRAY_CAT".to_string(),
                                args,
                            ))))
                        } else {
                            let mut it = args.into_iter().rev();
                            let mut result = it.next().unwrap();
                            for arr in it {
                                result = Expression::Function(Box::new(Function::new(
                                    "ARRAY_CAT".to_string(),
                                    vec![arr, result],
                                )));
                            }
                            Ok(result)
                        }
                    }
                    DialectType::Redshift => {
                        // ARRAY_CONCAT(arr1, ARRAY_CONCAT(arr2, arr3))
                        if args.len() <= 2 {
                            Ok(Expression::Function(Box::new(Function::new(
                                "ARRAY_CONCAT".to_string(),
                                args,
                            ))))
                        } else {
                            let mut it = args.into_iter().rev();
                            let mut result = it.next().unwrap();
                            for arr in it {
                                result = Expression::Function(Box::new(Function::new(
                                    "ARRAY_CONCAT".to_string(),
                                    vec![arr, result],
                                )));
                            }
                            Ok(result)
                        }
                    }
                    DialectType::DuckDB => {
                        // LIST_CONCAT supports multiple args natively in DuckDB
                        Ok(Expression::Function(Box::new(Function::new(
                            "LIST_CONCAT".to_string(),
                            args,
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "ARRAY_CONCAT".to_string(),
                        args,
                    )))),
                }
            }

            // ARRAY_CONCAT_AGG -> Snowflake: ARRAY_FLATTEN(ARRAY_AGG(x))
            "ARRAY_CONCAT_AGG" if args.len() == 1 => {
                let arg = args.remove(0);
                match target {
                    DialectType::Snowflake => {
                        let array_agg =
                            Expression::ArrayAgg(Box::new(crate::expressions::AggFunc {
                                this: arg,
                                distinct: false,
                                filter: None,
                                order_by: vec![],
                                name: None,
                                ignore_nulls: None,
                                having_max: None,
                                limit: None,
                            }));
                        Ok(Expression::Function(Box::new(Function::new(
                            "ARRAY_FLATTEN".to_string(),
                            vec![array_agg],
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "ARRAY_CONCAT_AGG".to_string(),
                        vec![arg],
                    )))),
                }
            }

            // MD5/SHA1/SHA256/SHA512 -> target-specific hash functions
            "MD5" if args.len() == 1 => {
                let arg = args.remove(0);
                match target {
                    DialectType::Spark | DialectType::Databricks | DialectType::Hive => {
                        // UNHEX(MD5(x))
                        let md5 = Expression::Function(Box::new(Function::new(
                            "MD5".to_string(),
                            vec![arg],
                        )));
                        Ok(Expression::Function(Box::new(Function::new(
                            "UNHEX".to_string(),
                            vec![md5],
                        ))))
                    }
                    DialectType::Snowflake => {
                        // MD5_BINARY(x)
                        Ok(Expression::Function(Box::new(Function::new(
                            "MD5_BINARY".to_string(),
                            vec![arg],
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "MD5".to_string(),
                        vec![arg],
                    )))),
                }
            }

            "SHA1" if args.len() == 1 => {
                let arg = args.remove(0);
                match target {
                    DialectType::DuckDB => {
                        // UNHEX(SHA1(x))
                        let sha1 = Expression::Function(Box::new(Function::new(
                            "SHA1".to_string(),
                            vec![arg],
                        )));
                        Ok(Expression::Function(Box::new(Function::new(
                            "UNHEX".to_string(),
                            vec![sha1],
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "SHA1".to_string(),
                        vec![arg],
                    )))),
                }
            }

            "SHA256" if args.len() == 1 => {
                let arg = args.remove(0);
                match target {
                    DialectType::DuckDB => {
                        // UNHEX(SHA256(x))
                        let sha = Expression::Function(Box::new(Function::new(
                            "SHA256".to_string(),
                            vec![arg],
                        )));
                        Ok(Expression::Function(Box::new(Function::new(
                            "UNHEX".to_string(),
                            vec![sha],
                        ))))
                    }
                    DialectType::Snowflake => {
                        // SHA2_BINARY(x, 256)
                        Ok(Expression::Function(Box::new(Function::new(
                            "SHA2_BINARY".to_string(),
                            vec![arg, Expression::number(256)],
                        ))))
                    }
                    DialectType::Redshift | DialectType::Spark => {
                        // SHA2(x, 256)
                        Ok(Expression::Function(Box::new(Function::new(
                            "SHA2".to_string(),
                            vec![arg, Expression::number(256)],
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "SHA256".to_string(),
                        vec![arg],
                    )))),
                }
            }

            "SHA512" if args.len() == 1 => {
                let arg = args.remove(0);
                match target {
                    DialectType::Snowflake => {
                        // SHA2_BINARY(x, 512)
                        Ok(Expression::Function(Box::new(Function::new(
                            "SHA2_BINARY".to_string(),
                            vec![arg, Expression::number(512)],
                        ))))
                    }
                    DialectType::Redshift | DialectType::Spark => {
                        // SHA2(x, 512)
                        Ok(Expression::Function(Box::new(Function::new(
                            "SHA2".to_string(),
                            vec![arg, Expression::number(512)],
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "SHA512".to_string(),
                        vec![arg],
                    )))),
                }
            }

            // REGEXP_EXTRACT_ALL(str, pattern) -> add default group arg
            "REGEXP_EXTRACT_ALL" if args.len() == 2 => {
                let str_expr = args.remove(0);
                let pattern = args.remove(0);

                // Check if pattern contains capturing groups (parentheses)
                let has_groups = match &pattern {
                    Expression::Literal(Literal::String(s)) => s.contains('(') && s.contains(')'),
                    _ => false,
                };

                match target {
                    DialectType::DuckDB => {
                        let group = if has_groups {
                            Expression::number(1)
                        } else {
                            Expression::number(0)
                        };
                        Ok(Expression::Function(Box::new(Function::new(
                            "REGEXP_EXTRACT_ALL".to_string(),
                            vec![str_expr, pattern, group],
                        ))))
                    }
                    DialectType::Spark | DialectType::Databricks => {
                        // Spark's default group_index is 1 (same as BigQuery), so omit for capturing groups
                        if has_groups {
                            Ok(Expression::Function(Box::new(Function::new(
                                "REGEXP_EXTRACT_ALL".to_string(),
                                vec![str_expr, pattern],
                            ))))
                        } else {
                            Ok(Expression::Function(Box::new(Function::new(
                                "REGEXP_EXTRACT_ALL".to_string(),
                                vec![str_expr, pattern, Expression::number(0)],
                            ))))
                        }
                    }
                    DialectType::Presto | DialectType::Trino => {
                        if has_groups {
                            Ok(Expression::Function(Box::new(Function::new(
                                "REGEXP_EXTRACT_ALL".to_string(),
                                vec![str_expr, pattern, Expression::number(1)],
                            ))))
                        } else {
                            Ok(Expression::Function(Box::new(Function::new(
                                "REGEXP_EXTRACT_ALL".to_string(),
                                vec![str_expr, pattern],
                            ))))
                        }
                    }
                    DialectType::Snowflake => {
                        if has_groups {
                            // REGEXP_EXTRACT_ALL(str, pattern, 1, 1, 'c', 1)
                            Ok(Expression::Function(Box::new(Function::new(
                                "REGEXP_EXTRACT_ALL".to_string(),
                                vec![
                                    str_expr,
                                    pattern,
                                    Expression::number(1),
                                    Expression::number(1),
                                    Expression::Literal(Literal::String("c".to_string())),
                                    Expression::number(1),
                                ],
                            ))))
                        } else {
                            Ok(Expression::Function(Box::new(Function::new(
                                "REGEXP_EXTRACT_ALL".to_string(),
                                vec![str_expr, pattern],
                            ))))
                        }
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "REGEXP_EXTRACT_ALL".to_string(),
                        vec![str_expr, pattern],
                    )))),
                }
            }

            // MOD(x, y) -> x % y for PostgreSQL/DuckDB
            "MOD" if args.len() == 2 => {
                match target {
                    DialectType::PostgreSQL
                    | DialectType::DuckDB
                    | DialectType::Presto
                    | DialectType::Trino
                    | DialectType::Athena
                    | DialectType::Snowflake => {
                        let x = args.remove(0);
                        let y = args.remove(0);
                        // Wrap complex expressions in parens to preserve precedence
                        let needs_paren = |e: &Expression| {
                            matches!(
                                e,
                                Expression::Add(_)
                                    | Expression::Sub(_)
                                    | Expression::Mul(_)
                                    | Expression::Div(_)
                            )
                        };
                        let x = if needs_paren(&x) {
                            Expression::Paren(Box::new(crate::expressions::Paren {
                                this: x,
                                trailing_comments: vec![],
                            }))
                        } else {
                            x
                        };
                        let y = if needs_paren(&y) {
                            Expression::Paren(Box::new(crate::expressions::Paren {
                                this: y,
                                trailing_comments: vec![],
                            }))
                        } else {
                            y
                        };
                        Ok(Expression::Mod(Box::new(
                            crate::expressions::BinaryOp::new(x, y),
                        )))
                    }
                    DialectType::Hive | DialectType::Spark | DialectType::Databricks => {
                        // Hive/Spark: a % b
                        let x = args.remove(0);
                        let y = args.remove(0);
                        let needs_paren = |e: &Expression| {
                            matches!(
                                e,
                                Expression::Add(_)
                                    | Expression::Sub(_)
                                    | Expression::Mul(_)
                                    | Expression::Div(_)
                            )
                        };
                        let x = if needs_paren(&x) {
                            Expression::Paren(Box::new(crate::expressions::Paren {
                                this: x,
                                trailing_comments: vec![],
                            }))
                        } else {
                            x
                        };
                        let y = if needs_paren(&y) {
                            Expression::Paren(Box::new(crate::expressions::Paren {
                                this: y,
                                trailing_comments: vec![],
                            }))
                        } else {
                            y
                        };
                        Ok(Expression::Mod(Box::new(
                            crate::expressions::BinaryOp::new(x, y),
                        )))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "MOD".to_string(),
                        args,
                    )))),
                }
            }

            // ARRAY_FILTER(arr, lambda) -> FILTER for Hive/Spark/Presto, ARRAY_FILTER for StarRocks
            "ARRAY_FILTER" if args.len() == 2 => {
                let name = match target {
                    DialectType::DuckDB => "LIST_FILTER",
                    DialectType::StarRocks => "ARRAY_FILTER",
                    _ => "FILTER",
                };
                Ok(Expression::Function(Box::new(Function::new(
                    name.to_string(),
                    args,
                ))))
            }
            // FILTER(arr, lambda) -> ARRAY_FILTER for StarRocks, LIST_FILTER for DuckDB
            "FILTER" if args.len() == 2 => {
                let name = match target {
                    DialectType::DuckDB => "LIST_FILTER",
                    DialectType::StarRocks => "ARRAY_FILTER",
                    _ => "FILTER",
                };
                Ok(Expression::Function(Box::new(Function::new(
                    name.to_string(),
                    args,
                ))))
            }
            // REDUCE(arr, init, lambda1, lambda2) -> AGGREGATE for Spark
            "REDUCE" if args.len() >= 3 => {
                let name = match target {
                    DialectType::Spark | DialectType::Databricks => "AGGREGATE",
                    _ => "REDUCE",
                };
                Ok(Expression::Function(Box::new(Function::new(
                    name.to_string(),
                    args,
                ))))
            }
            // ARRAY_REVERSE(x) -> arrayReverse for ClickHouse (handled by generator)
            "ARRAY_REVERSE" if args.len() == 1 => Ok(Expression::Function(Box::new(
                Function::new("ARRAY_REVERSE".to_string(), args),
            ))),

            // CONCAT(a, b, ...) -> a || b || ... for DuckDB with 3+ args
            "CONCAT" if args.len() > 2 => match target {
                DialectType::DuckDB => {
                    let mut it = args.into_iter();
                    let mut result = it.next().unwrap();
                    for arg in it {
                        result = Expression::DPipe(Box::new(crate::expressions::DPipe {
                            this: Box::new(result),
                            expression: Box::new(arg),
                            safe: None,
                        }));
                    }
                    Ok(result)
                }
                _ => Ok(Expression::Function(Box::new(Function::new(
                    "CONCAT".to_string(),
                    args,
                )))),
            },

            // GENERATE_DATE_ARRAY(start, end[, step]) -> target-specific
            "GENERATE_DATE_ARRAY" => {
                if matches!(target, DialectType::BigQuery) {
                    // BQ->BQ: add default interval if not present
                    if args.len() == 2 {
                        let start = args.remove(0);
                        let end = args.remove(0);
                        let default_interval =
                            Expression::Interval(Box::new(crate::expressions::Interval {
                                this: Some(Expression::Literal(Literal::String("1".to_string()))),
                                unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                    unit: crate::expressions::IntervalUnit::Day,
                                    use_plural: false,
                                }),
                            }));
                        Ok(Expression::Function(Box::new(Function::new(
                            "GENERATE_DATE_ARRAY".to_string(),
                            vec![start, end, default_interval],
                        ))))
                    } else {
                        Ok(Expression::Function(Box::new(Function::new(
                            "GENERATE_DATE_ARRAY".to_string(),
                            args,
                        ))))
                    }
                } else if matches!(target, DialectType::DuckDB) {
                    // DuckDB: CAST(GENERATE_SERIES(CAST(start AS DATE), CAST(end AS DATE), step) AS DATE[])
                    let start = args.get(0).cloned();
                    let end = args.get(1).cloned();
                    let step = args.get(2).cloned().or_else(|| {
                        Some(Expression::Interval(Box::new(
                            crate::expressions::Interval {
                                this: Some(Expression::Literal(Literal::String("1".to_string()))),
                                unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                    unit: crate::expressions::IntervalUnit::Day,
                                    use_plural: false,
                                }),
                            },
                        )))
                    });

                    // Wrap start/end in CAST(... AS DATE) only for string literals
                    let maybe_cast_date = |expr: Expression| -> Expression {
                        if matches!(&expr, Expression::Literal(Literal::String(_))) {
                            Expression::Cast(Box::new(Cast {
                                this: expr,
                                to: DataType::Date,
                                trailing_comments: vec![],
                                double_colon_syntax: false,
                                format: None,
                                default: None,
                            }))
                        } else {
                            expr
                        }
                    };
                    let cast_start = start.map(maybe_cast_date);
                    let cast_end = end.map(maybe_cast_date);

                    let gen_series =
                        Expression::GenerateSeries(Box::new(crate::expressions::GenerateSeries {
                            start: cast_start.map(Box::new),
                            end: cast_end.map(Box::new),
                            step: step.map(Box::new),
                            is_end_exclusive: None,
                        }));

                    // Wrap in CAST(... AS DATE[])
                    Ok(Expression::Cast(Box::new(Cast {
                        this: gen_series,
                        to: DataType::Array {
                            element_type: Box::new(DataType::Date),
                            dimension: None,
                        },
                        trailing_comments: vec![],
                        double_colon_syntax: false,
                        format: None,
                        default: None,
                    })))
                } else if matches!(target, DialectType::Snowflake) {
                    // Snowflake: keep as GENERATE_DATE_ARRAY function for later transform
                    // (transform_generate_date_array_snowflake will convert to ARRAY_GENERATE_RANGE + DATEADD)
                    if args.len() == 2 {
                        let start = args.remove(0);
                        let end = args.remove(0);
                        let default_interval =
                            Expression::Interval(Box::new(crate::expressions::Interval {
                                this: Some(Expression::Literal(Literal::String("1".to_string()))),
                                unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                    unit: crate::expressions::IntervalUnit::Day,
                                    use_plural: false,
                                }),
                            }));
                        Ok(Expression::Function(Box::new(Function::new(
                            "GENERATE_DATE_ARRAY".to_string(),
                            vec![start, end, default_interval],
                        ))))
                    } else {
                        Ok(Expression::Function(Box::new(Function::new(
                            "GENERATE_DATE_ARRAY".to_string(),
                            args,
                        ))))
                    }
                } else {
                    // Convert to GenerateSeries for other targets
                    let start = args.get(0).cloned();
                    let end = args.get(1).cloned();
                    let step = args.get(2).cloned().or_else(|| {
                        Some(Expression::Interval(Box::new(
                            crate::expressions::Interval {
                                this: Some(Expression::Literal(Literal::String("1".to_string()))),
                                unit: Some(crate::expressions::IntervalUnitSpec::Simple {
                                    unit: crate::expressions::IntervalUnit::Day,
                                    use_plural: false,
                                }),
                            },
                        )))
                    });
                    Ok(Expression::GenerateSeries(Box::new(
                        crate::expressions::GenerateSeries {
                            start: start.map(Box::new),
                            end: end.map(Box::new),
                            step: step.map(Box::new),
                            is_end_exclusive: None,
                        },
                    )))
                }
            }

            // PARSE_DATE(format, str) -> target-specific
            "PARSE_DATE" if args.len() == 2 => {
                let format = args.remove(0);
                let str_expr = args.remove(0);
                match target {
                    DialectType::DuckDB => {
                        // CAST(STRPTIME(str, duck_format) AS DATE)
                        let duck_format = Self::bq_format_to_duckdb(&format);
                        let strptime = Expression::Function(Box::new(Function::new(
                            "STRPTIME".to_string(),
                            vec![str_expr, duck_format],
                        )));
                        Ok(Expression::Cast(Box::new(Cast {
                            this: strptime,
                            to: DataType::Date,
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        })))
                    }
                    DialectType::Snowflake => {
                        // _POLYGLOT_DATE(str, snowflake_format)
                        // Use marker so Snowflake target transform keeps it as DATE() instead of TO_DATE()
                        let sf_format = Self::bq_format_to_snowflake(&format);
                        Ok(Expression::Function(Box::new(Function::new(
                            "_POLYGLOT_DATE".to_string(),
                            vec![str_expr, sf_format],
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "PARSE_DATE".to_string(),
                        vec![format, str_expr],
                    )))),
                }
            }

            // PARSE_TIMESTAMP(format, str) -> target-specific
            "PARSE_TIMESTAMP" if args.len() >= 2 => {
                let format = args.remove(0);
                let str_expr = args.remove(0);
                let tz = if !args.is_empty() {
                    Some(args.remove(0))
                } else {
                    None
                };
                match target {
                    DialectType::DuckDB => {
                        let duck_format = Self::bq_format_to_duckdb(&format);
                        let strptime = Expression::Function(Box::new(Function::new(
                            "STRPTIME".to_string(),
                            vec![str_expr, duck_format],
                        )));
                        Ok(strptime)
                    }
                    _ => {
                        let mut result_args = vec![format, str_expr];
                        if let Some(tz_arg) = tz {
                            result_args.push(tz_arg);
                        }
                        Ok(Expression::Function(Box::new(Function::new(
                            "PARSE_TIMESTAMP".to_string(),
                            result_args,
                        ))))
                    }
                }
            }

            // FORMAT_DATE(format, date) -> target-specific
            "FORMAT_DATE" if args.len() == 2 => {
                let format = args.remove(0);
                let date_expr = args.remove(0);
                match target {
                    DialectType::DuckDB => {
                        // STRFTIME(CAST(date AS DATE), format)
                        let cast_date = Expression::Cast(Box::new(Cast {
                            this: date_expr,
                            to: DataType::Date,
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        }));
                        Ok(Expression::Function(Box::new(Function::new(
                            "STRFTIME".to_string(),
                            vec![cast_date, format],
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "FORMAT_DATE".to_string(),
                        vec![format, date_expr],
                    )))),
                }
            }

            // FORMAT_DATETIME(format, datetime) -> target-specific
            "FORMAT_DATETIME" if args.len() == 2 => {
                let format = args.remove(0);
                let dt_expr = args.remove(0);

                if matches!(target, DialectType::BigQuery) {
                    // BQ->BQ: normalize %H:%M:%S to %T, %x to %D
                    let norm_format = Self::bq_format_normalize_bq(&format);
                    // Also strip DATETIME keyword from typed literals
                    let norm_dt = match dt_expr {
                        Expression::Literal(Literal::Timestamp(s)) => {
                            Expression::Cast(Box::new(Cast {
                                this: Expression::Literal(Literal::String(s)),
                                to: DataType::Custom {
                                    name: "DATETIME".to_string(),
                                },
                                trailing_comments: vec![],
                                double_colon_syntax: false,
                                format: None,
                                default: None,
                            }))
                        }
                        other => other,
                    };
                    return Ok(Expression::Function(Box::new(Function::new(
                        "FORMAT_DATETIME".to_string(),
                        vec![norm_format, norm_dt],
                    ))));
                }

                match target {
                    DialectType::DuckDB => {
                        // STRFTIME(CAST(dt AS TIMESTAMP), duckdb_format)
                        let cast_dt = Self::ensure_cast_timestamp(dt_expr);
                        let duck_format = Self::bq_format_to_duckdb(&format);
                        Ok(Expression::Function(Box::new(Function::new(
                            "STRFTIME".to_string(),
                            vec![cast_dt, duck_format],
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "FORMAT_DATETIME".to_string(),
                        vec![format, dt_expr],
                    )))),
                }
            }

            // FORMAT_TIMESTAMP(format, ts) -> target-specific
            "FORMAT_TIMESTAMP" if args.len() == 2 => {
                let format = args.remove(0);
                let ts_expr = args.remove(0);
                match target {
                    DialectType::DuckDB => {
                        // STRFTIME(CAST(CAST(ts AS TIMESTAMPTZ) AS TIMESTAMP), format)
                        let cast_tstz = Self::ensure_cast_timestamptz(ts_expr);
                        let cast_ts = Expression::Cast(Box::new(Cast {
                            this: cast_tstz,
                            to: DataType::Timestamp {
                                timezone: false,
                                precision: None,
                            },
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        }));
                        Ok(Expression::Function(Box::new(Function::new(
                            "STRFTIME".to_string(),
                            vec![cast_ts, format],
                        ))))
                    }
                    DialectType::Snowflake => {
                        // TO_CHAR(CAST(CAST(ts AS TIMESTAMPTZ) AS TIMESTAMP), snowflake_format)
                        let cast_tstz = Self::ensure_cast_timestamptz(ts_expr);
                        let cast_ts = Expression::Cast(Box::new(Cast {
                            this: cast_tstz,
                            to: DataType::Timestamp {
                                timezone: false,
                                precision: None,
                            },
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        }));
                        let sf_format = Self::bq_format_to_snowflake(&format);
                        Ok(Expression::Function(Box::new(Function::new(
                            "TO_CHAR".to_string(),
                            vec![cast_ts, sf_format],
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "FORMAT_TIMESTAMP".to_string(),
                        vec![format, ts_expr],
                    )))),
                }
            }

            // UNIX_DATE(date) -> DATE_DIFF('DAY', '1970-01-01', date) for DuckDB
            "UNIX_DATE" if args.len() == 1 => {
                let date = args.remove(0);
                match target {
                    DialectType::DuckDB => {
                        let epoch = Expression::Cast(Box::new(Cast {
                            this: Expression::Literal(Literal::String("1970-01-01".to_string())),
                            to: DataType::Date,
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        }));
                        // DATE_DIFF('DAY', epoch, date) but date might be DATE '...' literal
                        // Need to convert DATE literal to CAST
                        let norm_date = Self::date_literal_to_cast(date);
                        Ok(Expression::Function(Box::new(Function::new(
                            "DATE_DIFF".to_string(),
                            vec![
                                Expression::Literal(Literal::String("DAY".to_string())),
                                epoch,
                                norm_date,
                            ],
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "UNIX_DATE".to_string(),
                        vec![date],
                    )))),
                }
            }

            // UNIX_SECONDS(ts) -> target-specific
            "UNIX_SECONDS" if args.len() == 1 => {
                let ts = args.remove(0);
                match target {
                    DialectType::DuckDB => {
                        // CAST(EPOCH(CAST(ts AS TIMESTAMPTZ)) AS BIGINT)
                        let norm_ts = Self::ts_literal_to_cast_tz(ts);
                        let epoch = Expression::Function(Box::new(Function::new(
                            "EPOCH".to_string(),
                            vec![norm_ts],
                        )));
                        Ok(Expression::Cast(Box::new(Cast {
                            this: epoch,
                            to: DataType::BigInt { length: None },
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        })))
                    }
                    DialectType::Snowflake => {
                        // TIMESTAMPDIFF(SECONDS, CAST('1970-01-01 00:00:00+00' AS TIMESTAMPTZ), ts)
                        let epoch = Expression::Cast(Box::new(Cast {
                            this: Expression::Literal(Literal::String(
                                "1970-01-01 00:00:00+00".to_string(),
                            )),
                            to: DataType::Timestamp {
                                timezone: true,
                                precision: None,
                            },
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        }));
                        Ok(Expression::Function(Box::new(Function::new(
                            "TIMESTAMPDIFF".to_string(),
                            vec![
                                Expression::Identifier(Identifier::new("SECONDS".to_string())),
                                epoch,
                                ts,
                            ],
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "UNIX_SECONDS".to_string(),
                        vec![ts],
                    )))),
                }
            }

            // UNIX_MILLIS(ts) -> target-specific
            "UNIX_MILLIS" if args.len() == 1 => {
                let ts = args.remove(0);
                match target {
                    DialectType::DuckDB => {
                        let norm_ts = Self::ts_literal_to_cast_tz(ts);
                        Ok(Expression::Function(Box::new(Function::new(
                            "EPOCH_MS".to_string(),
                            vec![norm_ts],
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "UNIX_MILLIS".to_string(),
                        vec![ts],
                    )))),
                }
            }

            // UNIX_MICROS(ts) -> target-specific
            "UNIX_MICROS" if args.len() == 1 => {
                let ts = args.remove(0);
                match target {
                    DialectType::DuckDB => {
                        let norm_ts = Self::ts_literal_to_cast_tz(ts);
                        Ok(Expression::Function(Box::new(Function::new(
                            "EPOCH_US".to_string(),
                            vec![norm_ts],
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "UNIX_MICROS".to_string(),
                        vec![ts],
                    )))),
                }
            }

            // INSTR(str, substr) -> target-specific
            "INSTR" => {
                if matches!(target, DialectType::BigQuery) {
                    // BQ->BQ: keep as INSTR
                    Ok(Expression::Function(Box::new(Function::new(
                        "INSTR".to_string(),
                        args,
                    ))))
                } else if matches!(target, DialectType::Snowflake) && args.len() == 2 {
                    // Snowflake: CHARINDEX(substr, str) - swap args
                    let str_expr = args.remove(0);
                    let substr = args.remove(0);
                    Ok(Expression::Function(Box::new(Function::new(
                        "CHARINDEX".to_string(),
                        vec![substr, str_expr],
                    ))))
                } else {
                    // Keep as INSTR for other targets
                    Ok(Expression::Function(Box::new(Function::new(
                        "INSTR".to_string(),
                        args,
                    ))))
                }
            }

            // CURRENT_TIMESTAMP / CURRENT_DATE handling - parens normalization and timezone
            "CURRENT_TIMESTAMP" | "CURRENT_DATE" | "CURRENT_DATETIME" | "CURRENT_TIME" => {
                if matches!(target, DialectType::BigQuery) {
                    // BQ->BQ: always output with parens (function form), keep any timezone arg
                    Ok(Expression::Function(Box::new(Function::new(name, args))))
                } else if name == "CURRENT_DATE" && args.len() == 1 {
                    // CURRENT_DATE('UTC') - has timezone arg
                    let tz_arg = args.remove(0);
                    match target {
                        DialectType::DuckDB => {
                            // CAST(CURRENT_TIMESTAMP AT TIME ZONE 'UTC' AS DATE)
                            let ct = Expression::CurrentTimestamp(
                                crate::expressions::CurrentTimestamp {
                                    precision: None,
                                    sysdate: false,
                                },
                            );
                            let at_tz =
                                Expression::AtTimeZone(Box::new(crate::expressions::AtTimeZone {
                                    this: ct,
                                    zone: tz_arg,
                                }));
                            Ok(Expression::Cast(Box::new(Cast {
                                this: at_tz,
                                to: DataType::Date,
                                trailing_comments: vec![],
                                double_colon_syntax: false,
                                format: None,
                                default: None,
                            })))
                        }
                        DialectType::Snowflake => {
                            // CAST(CONVERT_TIMEZONE('UTC', CURRENT_TIMESTAMP()) AS DATE)
                            let ct = Expression::Function(Box::new(Function::new(
                                "CURRENT_TIMESTAMP".to_string(),
                                vec![],
                            )));
                            let convert = Expression::Function(Box::new(Function::new(
                                "CONVERT_TIMEZONE".to_string(),
                                vec![tz_arg, ct],
                            )));
                            Ok(Expression::Cast(Box::new(Cast {
                                this: convert,
                                to: DataType::Date,
                                trailing_comments: vec![],
                                double_colon_syntax: false,
                                format: None,
                                default: None,
                            })))
                        }
                        _ => {
                            // PostgreSQL, MySQL, etc.: CURRENT_DATE AT TIME ZONE 'UTC'
                            let cd = Expression::CurrentDate(crate::expressions::CurrentDate);
                            Ok(Expression::AtTimeZone(Box::new(
                                crate::expressions::AtTimeZone {
                                    this: cd,
                                    zone: tz_arg,
                                },
                            )))
                        }
                    }
                } else if (name == "CURRENT_TIMESTAMP"
                    || name == "CURRENT_TIME"
                    || name == "CURRENT_DATE")
                    && args.is_empty()
                    && matches!(
                        target,
                        DialectType::PostgreSQL
                            | DialectType::DuckDB
                            | DialectType::Presto
                            | DialectType::Trino
                    )
                {
                    // These targets want no-parens CURRENT_TIMESTAMP / CURRENT_DATE / CURRENT_TIME
                    if name == "CURRENT_TIMESTAMP" {
                        Ok(Expression::CurrentTimestamp(
                            crate::expressions::CurrentTimestamp {
                                precision: None,
                                sysdate: false,
                            },
                        ))
                    } else if name == "CURRENT_DATE" {
                        Ok(Expression::CurrentDate(crate::expressions::CurrentDate))
                    } else {
                        // CURRENT_TIME
                        Ok(Expression::CurrentTime(crate::expressions::CurrentTime {
                            precision: None,
                        }))
                    }
                } else {
                    // All other targets: keep as function (with parens)
                    Ok(Expression::Function(Box::new(Function::new(name, args))))
                }
            }

            // JSON_QUERY(json, path) -> target-specific
            "JSON_QUERY" if args.len() == 2 => {
                match target {
                    DialectType::DuckDB | DialectType::SQLite => {
                        // json -> path syntax
                        let json_expr = args.remove(0);
                        let path = args.remove(0);
                        Ok(Expression::JsonExtract(Box::new(
                            crate::expressions::JsonExtractFunc {
                                this: json_expr,
                                path,
                                returning: None,
                                arrow_syntax: true,
                                hash_arrow_syntax: false,
                                wrapper_option: None,
                                quotes_option: None,
                                on_scalar_string: false,
                                on_error: None,
                            },
                        )))
                    }
                    DialectType::Spark | DialectType::Databricks | DialectType::Hive => {
                        Ok(Expression::Function(Box::new(Function::new(
                            "GET_JSON_OBJECT".to_string(),
                            args,
                        ))))
                    }
                    DialectType::PostgreSQL | DialectType::Redshift => Ok(Expression::Function(
                        Box::new(Function::new("JSON_EXTRACT_PATH".to_string(), args)),
                    )),
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "JSON_QUERY".to_string(),
                        args,
                    )))),
                }
            }

            // JSON_VALUE_ARRAY(json, path) -> target-specific
            "JSON_VALUE_ARRAY" if args.len() == 2 => {
                match target {
                    DialectType::DuckDB => {
                        // CAST(json -> path AS TEXT[])
                        let json_expr = args.remove(0);
                        let path = args.remove(0);
                        let arrow = Expression::JsonExtract(Box::new(
                            crate::expressions::JsonExtractFunc {
                                this: json_expr,
                                path,
                                returning: None,
                                arrow_syntax: true,
                                hash_arrow_syntax: false,
                                wrapper_option: None,
                                quotes_option: None,
                                on_scalar_string: false,
                                on_error: None,
                            },
                        ));
                        Ok(Expression::Cast(Box::new(Cast {
                            this: arrow,
                            to: DataType::Array {
                                element_type: Box::new(DataType::Text),
                                dimension: None,
                            },
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        })))
                    }
                    DialectType::Snowflake => {
                        let json_expr = args.remove(0);
                        let path_expr = args.remove(0);
                        // Convert JSON path from $.path to just path
                        let sf_path = if let Expression::Literal(Literal::String(ref s)) = path_expr
                        {
                            let trimmed = s.trim_start_matches('$').trim_start_matches('.');
                            Expression::Literal(Literal::String(trimmed.to_string()))
                        } else {
                            path_expr
                        };
                        let parse_json = Expression::Function(Box::new(Function::new(
                            "PARSE_JSON".to_string(),
                            vec![json_expr],
                        )));
                        let get_path = Expression::Function(Box::new(Function::new(
                            "GET_PATH".to_string(),
                            vec![parse_json, sf_path],
                        )));
                        // TRANSFORM(get_path, x -> CAST(x AS VARCHAR))
                        let cast_expr = Expression::Cast(Box::new(Cast {
                            this: Expression::Identifier(Identifier::new("x")),
                            to: DataType::VarChar {
                                length: None,
                                parenthesized_length: false,
                            },
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        }));
                        let lambda = Expression::Lambda(Box::new(crate::expressions::LambdaExpr {
                            parameters: vec![Identifier::new("x")],
                            body: cast_expr,
                            colon: false,
                            parameter_types: vec![],
                        }));
                        Ok(Expression::Function(Box::new(Function::new(
                            "TRANSFORM".to_string(),
                            vec![get_path, lambda],
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "JSON_VALUE_ARRAY".to_string(),
                        args,
                    )))),
                }
            }

            // BigQuery REGEXP_EXTRACT(val, regex[, position[, occurrence]]) -> target dialects
            // BigQuery's 3rd arg is "position" (starting char index), 4th is "occurrence" (which match to return)
            // This is different from Hive/Spark where 3rd arg is "group_index"
            "REGEXP_EXTRACT" if matches!(source, DialectType::BigQuery) => {
                match target {
                    DialectType::DuckDB
                    | DialectType::Presto
                    | DialectType::Trino
                    | DialectType::Athena => {
                        if args.len() == 2 {
                            // REGEXP_EXTRACT(val, regex) -> REGEXP_EXTRACT(val, regex, 1)
                            args.push(Expression::number(1));
                            Ok(Expression::Function(Box::new(Function::new(
                                "REGEXP_EXTRACT".to_string(),
                                args,
                            ))))
                        } else if args.len() == 3 {
                            let val = args.remove(0);
                            let regex = args.remove(0);
                            let position = args.remove(0);
                            let is_pos_1 = matches!(&position, Expression::Literal(Literal::Number(n)) if n == "1");
                            if is_pos_1 {
                                Ok(Expression::Function(Box::new(Function::new(
                                    "REGEXP_EXTRACT".to_string(),
                                    vec![val, regex, Expression::number(1)],
                                ))))
                            } else {
                                let substring_expr = Expression::Function(Box::new(Function::new(
                                    "SUBSTRING".to_string(),
                                    vec![val, position],
                                )));
                                let nullif_expr = Expression::Function(Box::new(Function::new(
                                    "NULLIF".to_string(),
                                    vec![
                                        substring_expr,
                                        Expression::Literal(Literal::String(String::new())),
                                    ],
                                )));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "REGEXP_EXTRACT".to_string(),
                                    vec![nullif_expr, regex, Expression::number(1)],
                                ))))
                            }
                        } else if args.len() == 4 {
                            let val = args.remove(0);
                            let regex = args.remove(0);
                            let position = args.remove(0);
                            let occurrence = args.remove(0);
                            let is_pos_1 = matches!(&position, Expression::Literal(Literal::Number(n)) if n == "1");
                            let is_occ_1 = matches!(&occurrence, Expression::Literal(Literal::Number(n)) if n == "1");
                            if is_pos_1 && is_occ_1 {
                                Ok(Expression::Function(Box::new(Function::new(
                                    "REGEXP_EXTRACT".to_string(),
                                    vec![val, regex, Expression::number(1)],
                                ))))
                            } else {
                                let subject = if is_pos_1 {
                                    val
                                } else {
                                    let substring_expr = Expression::Function(Box::new(
                                        Function::new("SUBSTRING".to_string(), vec![val, position]),
                                    ));
                                    Expression::Function(Box::new(Function::new(
                                        "NULLIF".to_string(),
                                        vec![
                                            substring_expr,
                                            Expression::Literal(Literal::String(String::new())),
                                        ],
                                    )))
                                };
                                let extract_all = Expression::Function(Box::new(Function::new(
                                    "REGEXP_EXTRACT_ALL".to_string(),
                                    vec![subject, regex, Expression::number(1)],
                                )));
                                Ok(Expression::Function(Box::new(Function::new(
                                    "ARRAY_EXTRACT".to_string(),
                                    vec![extract_all, occurrence],
                                ))))
                            }
                        } else {
                            Ok(Expression::Function(Box::new(Function {
                                name: f.name,
                                args,
                                distinct: f.distinct,
                                trailing_comments: f.trailing_comments,
                                use_bracket_syntax: f.use_bracket_syntax,
                                no_parens: f.no_parens,
                                quoted: f.quoted,
                            })))
                        }
                    }
                    DialectType::Snowflake => {
                        // BigQuery REGEXP_EXTRACT -> Snowflake REGEXP_SUBSTR
                        Ok(Expression::Function(Box::new(Function::new(
                            "REGEXP_SUBSTR".to_string(),
                            args,
                        ))))
                    }
                    _ => {
                        // For other targets (Hive/Spark/BigQuery): pass through as-is
                        // BigQuery's default group behavior matches Hive/Spark for 2-arg case
                        Ok(Expression::Function(Box::new(Function {
                            name: f.name,
                            args,
                            distinct: f.distinct,
                            trailing_comments: f.trailing_comments,
                            use_bracket_syntax: f.use_bracket_syntax,
                            no_parens: f.no_parens,
                            quoted: f.quoted,
                        })))
                    }
                }
            }

            // BigQuery STRUCT(args) -> target-specific struct expression
            "STRUCT" => {
                // Convert Function args to Struct fields
                let mut fields: Vec<(Option<String>, Expression)> = Vec::new();
                for (i, arg) in args.into_iter().enumerate() {
                    match arg {
                        Expression::Alias(a) => {
                            // Named field: expr AS name
                            fields.push((Some(a.alias.name.clone()), a.this));
                        }
                        other => {
                            // Unnamed field: for Spark/Hive, keep as None
                            // For Snowflake, auto-name as _N
                            // For DuckDB, use column name for column refs, _N for others
                            if matches!(target, DialectType::Snowflake) {
                                fields.push((Some(format!("_{}", i)), other));
                            } else if matches!(target, DialectType::DuckDB) {
                                let auto_name = match &other {
                                    Expression::Column(col) => col.name.name.clone(),
                                    _ => format!("_{}", i),
                                };
                                fields.push((Some(auto_name), other));
                            } else {
                                fields.push((None, other));
                            }
                        }
                    }
                }

                match target {
                    DialectType::Snowflake => {
                        // OBJECT_CONSTRUCT('name', value, ...)
                        let mut oc_args = Vec::new();
                        for (name, val) in &fields {
                            if let Some(n) = name {
                                oc_args.push(Expression::Literal(Literal::String(n.clone())));
                                oc_args.push(val.clone());
                            } else {
                                oc_args.push(val.clone());
                            }
                        }
                        Ok(Expression::Function(Box::new(Function::new(
                            "OBJECT_CONSTRUCT".to_string(),
                            oc_args,
                        ))))
                    }
                    DialectType::DuckDB => {
                        // {'name': value, ...}
                        Ok(Expression::Struct(Box::new(crate::expressions::Struct {
                            fields,
                        })))
                    }
                    DialectType::Hive => {
                        // STRUCT(val1, val2, ...) - strip aliases
                        let hive_fields: Vec<(Option<String>, Expression)> =
                            fields.into_iter().map(|(_, v)| (None, v)).collect();
                        Ok(Expression::Struct(Box::new(crate::expressions::Struct {
                            fields: hive_fields,
                        })))
                    }
                    DialectType::Spark | DialectType::Databricks => {
                        // Use Expression::Struct to bypass Spark target transform auto-naming
                        Ok(Expression::Struct(Box::new(crate::expressions::Struct {
                            fields,
                        })))
                    }
                    DialectType::Presto | DialectType::Trino | DialectType::Athena => {
                        // Check if all fields are named AND all have inferable types - if so, wrap in CAST(ROW(...) AS ROW(name TYPE, ...))
                        let all_named =
                            !fields.is_empty() && fields.iter().all(|(name, _)| name.is_some());
                        let all_types_inferable = all_named
                            && fields
                                .iter()
                                .all(|(_, val)| Self::can_infer_presto_type(val));
                        let row_args: Vec<Expression> =
                            fields.iter().map(|(_, v)| v.clone()).collect();
                        let row_expr = Expression::Function(Box::new(Function::new(
                            "ROW".to_string(),
                            row_args,
                        )));
                        if all_named && all_types_inferable {
                            // Build ROW type with inferred types
                            let mut row_type_fields = Vec::new();
                            for (name, val) in &fields {
                                if let Some(n) = name {
                                    let type_str = Self::infer_sql_type_for_presto(val);
                                    row_type_fields.push(crate::expressions::StructField::new(
                                        n.clone(),
                                        crate::expressions::DataType::Custom { name: type_str },
                                    ));
                                }
                            }
                            let row_type = crate::expressions::DataType::Struct {
                                fields: row_type_fields,
                                nested: true,
                            };
                            Ok(Expression::Cast(Box::new(Cast {
                                this: row_expr,
                                to: row_type,
                                trailing_comments: Vec::new(),
                                double_colon_syntax: false,
                                format: None,
                                default: None,
                            })))
                        } else {
                            Ok(row_expr)
                        }
                    }
                    _ => {
                        // Default: keep as STRUCT function with original args
                        let mut new_args = Vec::new();
                        for (name, val) in fields {
                            if let Some(n) = name {
                                new_args.push(Expression::Alias(Box::new(
                                    crate::expressions::Alias::new(val, Identifier::new(n)),
                                )));
                            } else {
                                new_args.push(val);
                            }
                        }
                        Ok(Expression::Function(Box::new(Function::new(
                            "STRUCT".to_string(),
                            new_args,
                        ))))
                    }
                }
            }

            // ROUND(x, n, 'ROUND_HALF_EVEN') -> ROUND_EVEN(x, n) for DuckDB
            "ROUND" if args.len() == 3 => {
                let x = args.remove(0);
                let n = args.remove(0);
                let mode = args.remove(0);
                // Check if mode is 'ROUND_HALF_EVEN'
                let is_half_even = matches!(&mode, Expression::Literal(Literal::String(s)) if s.eq_ignore_ascii_case("ROUND_HALF_EVEN"));
                if is_half_even && matches!(target, DialectType::DuckDB) {
                    Ok(Expression::Function(Box::new(Function::new(
                        "ROUND_EVEN".to_string(),
                        vec![x, n],
                    ))))
                } else {
                    // Pass through with all args
                    Ok(Expression::Function(Box::new(Function::new(
                        "ROUND".to_string(),
                        vec![x, n, mode],
                    ))))
                }
            }

            // MAKE_INTERVAL(year, month, named_args...) -> INTERVAL string for Snowflake/DuckDB
            "MAKE_INTERVAL" => {
                // MAKE_INTERVAL(1, 2, minute => 5, day => 3)
                // The positional args are: year, month
                // Named args are: day =>, minute =>, etc.
                // For Snowflake: INTERVAL '1 year, 2 month, 5 minute, 3 day'
                // For DuckDB: INTERVAL '1 year 2 month 5 minute 3 day'
                // For BigQuery->BigQuery: reorder named args (day before minute)
                if matches!(target, DialectType::Snowflake | DialectType::DuckDB) {
                    let mut parts: Vec<(String, String)> = Vec::new();
                    let mut pos_idx = 0;
                    let pos_units = ["year", "month"];
                    for arg in &args {
                        if let Expression::NamedArgument(na) = arg {
                            // Named arg like minute => 5
                            let unit = na.name.name.clone();
                            if let Expression::Literal(Literal::Number(n)) = &na.value {
                                parts.push((unit, n.clone()));
                            }
                        } else if pos_idx < pos_units.len() {
                            if let Expression::Literal(Literal::Number(n)) = arg {
                                parts.push((pos_units[pos_idx].to_string(), n.clone()));
                            }
                            pos_idx += 1;
                        }
                    }
                    // Don't sort - preserve original argument order
                    let separator = if matches!(target, DialectType::Snowflake) {
                        ", "
                    } else {
                        " "
                    };
                    let interval_str = parts
                        .iter()
                        .map(|(u, v)| format!("{} {}", v, u))
                        .collect::<Vec<_>>()
                        .join(separator);
                    Ok(Expression::Interval(Box::new(
                        crate::expressions::Interval {
                            this: Some(Expression::Literal(Literal::String(interval_str))),
                            unit: None,
                        },
                    )))
                } else if matches!(target, DialectType::BigQuery) {
                    // BigQuery->BigQuery: reorder named args (day, minute, etc.)
                    let mut positional = Vec::new();
                    let mut named: Vec<(
                        String,
                        Expression,
                        crate::expressions::NamedArgSeparator,
                    )> = Vec::new();
                    let _pos_units = ["year", "month"];
                    let mut _pos_idx = 0;
                    for arg in args {
                        if let Expression::NamedArgument(na) = arg {
                            named.push((na.name.name.clone(), na.value, na.separator));
                        } else {
                            positional.push(arg);
                            _pos_idx += 1;
                        }
                    }
                    // Sort named args by: day, hour, minute, second
                    let unit_order = |u: &str| -> usize {
                        match u.to_lowercase().as_str() {
                            "day" => 0,
                            "hour" => 1,
                            "minute" => 2,
                            "second" => 3,
                            _ => 4,
                        }
                    };
                    named.sort_by_key(|(u, _, _)| unit_order(u));
                    let mut result_args = positional;
                    for (name, value, sep) in named {
                        result_args.push(Expression::NamedArgument(Box::new(
                            crate::expressions::NamedArgument {
                                name: Identifier::new(&name),
                                value,
                                separator: sep,
                            },
                        )));
                    }
                    Ok(Expression::Function(Box::new(Function::new(
                        "MAKE_INTERVAL".to_string(),
                        result_args,
                    ))))
                } else {
                    Ok(Expression::Function(Box::new(Function::new(
                        "MAKE_INTERVAL".to_string(),
                        args,
                    ))))
                }
            }

            // ARRAY_TO_STRING(array, sep, null_text) -> ARRAY_TO_STRING(LIST_TRANSFORM(array, x -> COALESCE(x, null_text)), sep) for DuckDB
            "ARRAY_TO_STRING" if args.len() == 3 => {
                let arr = args.remove(0);
                let sep = args.remove(0);
                let null_text = args.remove(0);
                match target {
                    DialectType::DuckDB => {
                        // LIST_TRANSFORM(array, x -> COALESCE(x, null_text))
                        let _lambda_param =
                            Expression::Identifier(crate::expressions::Identifier::new("x"));
                        let coalesce =
                            Expression::Coalesce(Box::new(crate::expressions::VarArgFunc {
                                original_name: None,
                                expressions: vec![
                                    Expression::Identifier(crate::expressions::Identifier::new(
                                        "x",
                                    )),
                                    null_text,
                                ],
                            }));
                        let lambda = Expression::Lambda(Box::new(crate::expressions::LambdaExpr {
                            parameters: vec![crate::expressions::Identifier::new("x")],
                            body: coalesce,
                            colon: false,
                            parameter_types: vec![],
                        }));
                        let list_transform = Expression::Function(Box::new(Function::new(
                            "LIST_TRANSFORM".to_string(),
                            vec![arr, lambda],
                        )));
                        Ok(Expression::Function(Box::new(Function::new(
                            "ARRAY_TO_STRING".to_string(),
                            vec![list_transform, sep],
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "ARRAY_TO_STRING".to_string(),
                        vec![arr, sep, null_text],
                    )))),
                }
            }

            // LENGTH(x) -> CASE TYPEOF(x) ... for DuckDB
            "LENGTH" if args.len() == 1 => {
                let arg = args.remove(0);
                match target {
                    DialectType::DuckDB => {
                        // CASE TYPEOF(foo) WHEN 'BLOB' THEN OCTET_LENGTH(CAST(foo AS BLOB)) ELSE LENGTH(CAST(foo AS TEXT)) END
                        let typeof_func = Expression::Function(Box::new(Function::new(
                            "TYPEOF".to_string(),
                            vec![arg.clone()],
                        )));
                        let blob_cast = Expression::Cast(Box::new(Cast {
                            this: arg.clone(),
                            to: DataType::VarBinary { length: None },
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        }));
                        let octet_length = Expression::Function(Box::new(Function::new(
                            "OCTET_LENGTH".to_string(),
                            vec![blob_cast],
                        )));
                        let text_cast = Expression::Cast(Box::new(Cast {
                            this: arg,
                            to: DataType::Text,
                            trailing_comments: vec![],
                            double_colon_syntax: false,
                            format: None,
                            default: None,
                        }));
                        let length_text = Expression::Function(Box::new(Function::new(
                            "LENGTH".to_string(),
                            vec![text_cast],
                        )));
                        Ok(Expression::Case(Box::new(crate::expressions::Case {
                            operand: Some(typeof_func),
                            whens: vec![(
                                Expression::Literal(Literal::String("BLOB".to_string())),
                                octet_length,
                            )],
                            else_: Some(length_text),
                            comments: Vec::new(),
                        })))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "LENGTH".to_string(),
                        vec![arg],
                    )))),
                }
            }

            // PERCENTILE_CONT(x, fraction RESPECT NULLS) -> QUANTILE_CONT(x, fraction) for DuckDB
            "PERCENTILE_CONT" if args.len() >= 2 && matches!(source, DialectType::BigQuery) => {
                // BigQuery PERCENTILE_CONT(x, fraction [RESPECT|IGNORE NULLS]) OVER ()
                // The args should be [x, fraction] with the null handling stripped
                // For DuckDB: QUANTILE_CONT(x, fraction)
                // For Spark: PERCENTILE_CONT(x, fraction) RESPECT NULLS (handled at window level)
                match target {
                    DialectType::DuckDB => {
                        // Strip down to just 2 args, rename to QUANTILE_CONT
                        let x = args[0].clone();
                        let frac = args[1].clone();
                        Ok(Expression::Function(Box::new(Function::new(
                            "QUANTILE_CONT".to_string(),
                            vec![x, frac],
                        ))))
                    }
                    _ => Ok(Expression::Function(Box::new(Function::new(
                        "PERCENTILE_CONT".to_string(),
                        args,
                    )))),
                }
            }

            // All others: pass through
            _ => Ok(Expression::Function(Box::new(Function {
                name: f.name,
                args,
                distinct: f.distinct,
                trailing_comments: f.trailing_comments,
                use_bracket_syntax: f.use_bracket_syntax,
                no_parens: f.no_parens,
                quoted: f.quoted,
            }))),
        }
    }

    /// Check if we can reliably infer the SQL type for Presto/Trino ROW CAST.
    /// Returns false for column references and other non-literal expressions where the type is unknown.
    fn can_infer_presto_type(expr: &Expression) -> bool {
        match expr {
            Expression::Literal(_) => true,
            Expression::Boolean(_) => true,
            Expression::Array(_) | Expression::ArrayFunc(_) => true,
            Expression::Struct(_) | Expression::StructFunc(_) => true,
            Expression::Function(f) => {
                let up = f.name.to_uppercase();
                up == "STRUCT"
                    || up == "ROW"
                    || up == "CURRENT_DATE"
                    || up == "CURRENT_TIMESTAMP"
                    || up == "NOW"
            }
            Expression::Cast(_) => true,
            Expression::Neg(inner) => Self::can_infer_presto_type(&inner.this),
            _ => false,
        }
    }

    /// Infer SQL type name for a Presto/Trino ROW CAST from a literal expression
    fn infer_sql_type_for_presto(expr: &Expression) -> String {
        use crate::expressions::Literal;
        match expr {
            Expression::Literal(Literal::String(_)) => "VARCHAR".to_string(),
            Expression::Literal(Literal::Number(n)) => {
                if n.contains('.') {
                    "DOUBLE".to_string()
                } else {
                    "INTEGER".to_string()
                }
            }
            Expression::Boolean(_) => "BOOLEAN".to_string(),
            Expression::Literal(Literal::Date(_)) => "DATE".to_string(),
            Expression::Literal(Literal::Timestamp(_)) => "TIMESTAMP".to_string(),
            Expression::Literal(Literal::Datetime(_)) => "TIMESTAMP".to_string(),
            Expression::Array(_) | Expression::ArrayFunc(_) => "ARRAY(VARCHAR)".to_string(),
            Expression::Struct(_) | Expression::StructFunc(_) => "ROW".to_string(),
            Expression::Function(f) => {
                let up = f.name.to_uppercase();
                if up == "STRUCT" || up == "ROW" {
                    "ROW".to_string()
                } else if up == "CURRENT_DATE" {
                    "DATE".to_string()
                } else if up == "CURRENT_TIMESTAMP" || up == "NOW" {
                    "TIMESTAMP".to_string()
                } else {
                    "VARCHAR".to_string()
                }
            }
            Expression::Cast(c) => {
                // If already cast, use the target type
                Self::data_type_to_presto_string(&c.to)
            }
            _ => "VARCHAR".to_string(),
        }
    }

    /// Convert a DataType to its Presto/Trino string representation for ROW type
    fn data_type_to_presto_string(dt: &crate::expressions::DataType) -> String {
        use crate::expressions::DataType;
        match dt {
            DataType::VarChar { .. } | DataType::Text | DataType::String { .. } => {
                "VARCHAR".to_string()
            }
            DataType::Int { .. }
            | DataType::BigInt { .. }
            | DataType::SmallInt { .. }
            | DataType::TinyInt { .. } => "INTEGER".to_string(),
            DataType::Float { .. } | DataType::Double { .. } => "DOUBLE".to_string(),
            DataType::Boolean => "BOOLEAN".to_string(),
            DataType::Date => "DATE".to_string(),
            DataType::Timestamp { .. } => "TIMESTAMP".to_string(),
            DataType::Struct { fields, .. } => {
                let field_strs: Vec<String> = fields
                    .iter()
                    .map(|f| {
                        format!(
                            "{} {}",
                            f.name,
                            Self::data_type_to_presto_string(&f.data_type)
                        )
                    })
                    .collect();
                format!("ROW({})", field_strs.join(", "))
            }
            DataType::Array { element_type, .. } => {
                format!("ARRAY({})", Self::data_type_to_presto_string(element_type))
            }
            DataType::Custom { name } => {
                // Pass through custom type names (e.g., "INTEGER", "VARCHAR" from earlier inference)
                name.clone()
            }
            _ => "VARCHAR".to_string(),
        }
    }

    /// Convert IntervalUnit to string
    fn interval_unit_to_string(unit: &crate::expressions::IntervalUnit) -> String {
        match unit {
            crate::expressions::IntervalUnit::Year => "YEAR".to_string(),
            crate::expressions::IntervalUnit::Quarter => "QUARTER".to_string(),
            crate::expressions::IntervalUnit::Month => "MONTH".to_string(),
            crate::expressions::IntervalUnit::Week => "WEEK".to_string(),
            crate::expressions::IntervalUnit::Day => "DAY".to_string(),
            crate::expressions::IntervalUnit::Hour => "HOUR".to_string(),
            crate::expressions::IntervalUnit::Minute => "MINUTE".to_string(),
            crate::expressions::IntervalUnit::Second => "SECOND".to_string(),
            crate::expressions::IntervalUnit::Millisecond => "MILLISECOND".to_string(),
            crate::expressions::IntervalUnit::Microsecond => "MICROSECOND".to_string(),
            crate::expressions::IntervalUnit::Nanosecond => "NANOSECOND".to_string(),
        }
    }

    /// Extract unit string from an expression (uppercased)
    fn get_unit_str_static(expr: &Expression) -> String {
        use crate::expressions::Literal;
        match expr {
            Expression::Identifier(id) => id.name.to_uppercase(),
            Expression::Literal(Literal::String(s)) => s.to_uppercase(),
            Expression::Column(col) => col.name.name.to_uppercase(),
            Expression::Function(f) => {
                let base = f.name.to_uppercase();
                if !f.args.is_empty() {
                    let inner = Self::get_unit_str_static(&f.args[0]);
                    format!("{}({})", base, inner)
                } else {
                    base
                }
            }
            _ => "DAY".to_string(),
        }
    }

    /// Parse unit string to IntervalUnit
    fn parse_interval_unit_static(s: &str) -> crate::expressions::IntervalUnit {
        match s {
            "YEAR" | "YY" | "YYYY" => crate::expressions::IntervalUnit::Year,
            "QUARTER" | "QQ" | "Q" => crate::expressions::IntervalUnit::Quarter,
            "MONTH" | "MM" | "M" => crate::expressions::IntervalUnit::Month,
            "WEEK" | "WK" | "WW" | "ISOWEEK" => crate::expressions::IntervalUnit::Week,
            "DAY" | "DD" | "D" | "DY" => crate::expressions::IntervalUnit::Day,
            "HOUR" | "HH" => crate::expressions::IntervalUnit::Hour,
            "MINUTE" | "MI" | "N" => crate::expressions::IntervalUnit::Minute,
            "SECOND" | "SS" | "S" => crate::expressions::IntervalUnit::Second,
            "MILLISECOND" | "MS" => crate::expressions::IntervalUnit::Millisecond,
            "MICROSECOND" | "MCS" | "US" => crate::expressions::IntervalUnit::Microsecond,
            _ if s.starts_with("WEEK(") => crate::expressions::IntervalUnit::Week,
            _ => crate::expressions::IntervalUnit::Day,
        }
    }

    /// Convert expression to simple string for interval building
    fn expr_to_string_static(expr: &Expression) -> String {
        use crate::expressions::Literal;
        match expr {
            Expression::Literal(Literal::Number(s)) => s.clone(),
            Expression::Literal(Literal::String(s)) => s.clone(),
            Expression::Identifier(id) => id.name.clone(),
            Expression::Neg(f) => format!("-{}", Self::expr_to_string_static(&f.this)),
            _ => "1".to_string(),
        }
    }

    /// Extract a simple string representation from a literal expression
    fn expr_to_string(expr: &Expression) -> String {
        use crate::expressions::Literal;
        match expr {
            Expression::Literal(Literal::Number(s)) => s.clone(),
            Expression::Literal(Literal::String(s)) => s.clone(),
            Expression::Neg(f) => format!("-{}", Self::expr_to_string(&f.this)),
            Expression::Identifier(id) => id.name.clone(),
            _ => "1".to_string(),
        }
    }

    /// Quote an interval value expression as a string literal if it's a number (or negated number)
    fn quote_interval_val(expr: &Expression) -> Expression {
        use crate::expressions::Literal;
        match expr {
            Expression::Literal(Literal::Number(n)) => {
                Expression::Literal(Literal::String(n.clone()))
            }
            Expression::Literal(Literal::String(_)) => expr.clone(),
            Expression::Neg(inner) => {
                if let Expression::Literal(Literal::Number(n)) = &inner.this {
                    Expression::Literal(Literal::String(format!("-{}", n)))
                } else {
                    expr.clone()
                }
            }
            _ => expr.clone(),
        }
    }

    /// Check if a timestamp string contains timezone info (offset like +02:00, or named timezone)
    fn timestamp_string_has_timezone(ts: &str) -> bool {
        let trimmed = ts.trim();
        // Check for numeric timezone offsets: +N, -N, +NN:NN, -NN:NN at end
        if let Some(last_space) = trimmed.rfind(' ') {
            let suffix = &trimmed[last_space + 1..];
            if (suffix.starts_with('+') || suffix.starts_with('-')) && suffix.len() > 1 {
                let rest = &suffix[1..];
                if rest.chars().all(|c| c.is_ascii_digit() || c == ':') {
                    return true;
                }
            }
        }
        // Check for named timezone abbreviations
        let ts_lower = trimmed.to_lowercase();
        let tz_abbrevs = [" utc", " gmt", " cet", " est", " pst", " cst", " mst"];
        for abbrev in &tz_abbrevs {
            if ts_lower.ends_with(abbrev) {
                return true;
            }
        }
        false
    }

    /// Maybe CAST timestamp literal to TIMESTAMPTZ for Snowflake
    fn maybe_cast_ts_to_tz(expr: Expression, func_name: &str) -> Expression {
        use crate::expressions::{Cast, DataType, Literal};
        match expr {
            Expression::Literal(Literal::Timestamp(s)) => {
                let tz = func_name.starts_with("TIMESTAMP");
                Expression::Cast(Box::new(Cast {
                    this: Expression::Literal(Literal::String(s)),
                    to: if tz {
                        DataType::Timestamp {
                            timezone: true,
                            precision: None,
                        }
                    } else {
                        DataType::Timestamp {
                            timezone: false,
                            precision: None,
                        }
                    },
                    trailing_comments: vec![],
                    double_colon_syntax: false,
                    format: None,
                    default: None,
                }))
            }
            other => other,
        }
    }

    /// Maybe CAST timestamp literal to TIMESTAMP (no tz)
    fn maybe_cast_ts(expr: Expression) -> Expression {
        use crate::expressions::{Cast, DataType, Literal};
        match expr {
            Expression::Literal(Literal::Timestamp(s)) => Expression::Cast(Box::new(Cast {
                this: Expression::Literal(Literal::String(s)),
                to: DataType::Timestamp {
                    timezone: false,
                    precision: None,
                },
                trailing_comments: vec![],
                double_colon_syntax: false,
                format: None,
                default: None,
            })),
            other => other,
        }
    }

    /// Convert DATE 'x' literal to CAST('x' AS DATE)
    fn date_literal_to_cast(expr: Expression) -> Expression {
        use crate::expressions::{Cast, DataType, Literal};
        match expr {
            Expression::Literal(Literal::Date(s)) => Expression::Cast(Box::new(Cast {
                this: Expression::Literal(Literal::String(s)),
                to: DataType::Date,
                trailing_comments: vec![],
                double_colon_syntax: false,
                format: None,
                default: None,
            })),
            other => other,
        }
    }

    /// Ensure an expression that should be a date is CAST(... AS DATE).
    /// Handles both DATE literals and string literals that look like dates.
    fn ensure_cast_date(expr: Expression) -> Expression {
        use crate::expressions::{Cast, DataType, Literal};
        match expr {
            Expression::Literal(Literal::Date(s)) => Expression::Cast(Box::new(Cast {
                this: Expression::Literal(Literal::String(s)),
                to: DataType::Date,
                trailing_comments: vec![],
                double_colon_syntax: false,
                format: None,
                default: None,
            })),
            Expression::Literal(Literal::String(ref _s)) => {
                // String literal that should be a date -> CAST('s' AS DATE)
                Expression::Cast(Box::new(Cast {
                    this: expr,
                    to: DataType::Date,
                    trailing_comments: vec![],
                    double_colon_syntax: false,
                    format: None,
                    default: None,
                }))
            }
            // Already a CAST or other expression -> leave as-is
            other => other,
        }
    }

    /// Force CAST(expr AS DATE) for any expression (not just literals)
    /// Skips if the expression is already a CAST to DATE
    fn force_cast_date(expr: Expression) -> Expression {
        use crate::expressions::{Cast, DataType};
        // If it's already a CAST to DATE, don't double-wrap
        if let Expression::Cast(ref c) = expr {
            if matches!(c.to, DataType::Date) {
                return expr;
            }
        }
        Expression::Cast(Box::new(Cast {
            this: expr,
            to: DataType::Date,
            trailing_comments: vec![],
            double_colon_syntax: false,
            format: None,
            default: None,
        }))
    }

    /// Internal TO_DATE function that won't be converted to CAST by the Snowflake handler.
    /// Uses the name `_POLYGLOT_TO_DATE` which is not recognized by the TO_DATE -> CAST logic.
    /// The Snowflake DATEDIFF handler converts these back to TO_DATE.
    const PRESERVED_TO_DATE: &'static str = "_POLYGLOT_TO_DATE";

    fn ensure_to_date_preserved(expr: Expression) -> Expression {
        use crate::expressions::{Function, Literal};
        if matches!(expr, Expression::Literal(Literal::String(_))) {
            Expression::Function(Box::new(Function::new(
                Self::PRESERVED_TO_DATE.to_string(),
                vec![expr],
            )))
        } else {
            expr
        }
    }

    /// TRY_CAST(expr AS DATE) - used for DuckDB when TO_DATE is unwrapped
    fn try_cast_date(expr: Expression) -> Expression {
        use crate::expressions::{Cast, DataType};
        Expression::TryCast(Box::new(Cast {
            this: expr,
            to: DataType::Date,
            trailing_comments: vec![],
            double_colon_syntax: false,
            format: None,
            default: None,
        }))
    }

    /// CAST(CAST(expr AS TIMESTAMP) AS DATE) - used when Hive string dates need to be cast
    fn double_cast_timestamp_date(expr: Expression) -> Expression {
        use crate::expressions::{Cast, DataType};
        let inner = Expression::Cast(Box::new(Cast {
            this: expr,
            to: DataType::Timestamp {
                timezone: false,
                precision: None,
            },
            trailing_comments: vec![],
            double_colon_syntax: false,
            format: None,
            default: None,
        }));
        Expression::Cast(Box::new(Cast {
            this: inner,
            to: DataType::Date,
            trailing_comments: vec![],
            double_colon_syntax: false,
            format: None,
            default: None,
        }))
    }

    /// CAST(CAST(expr AS DATETIME) AS DATE) - BigQuery variant
    fn double_cast_datetime_date(expr: Expression) -> Expression {
        use crate::expressions::{Cast, DataType};
        let inner = Expression::Cast(Box::new(Cast {
            this: expr,
            to: DataType::Custom {
                name: "DATETIME".to_string(),
            },
            trailing_comments: vec![],
            double_colon_syntax: false,
            format: None,
            default: None,
        }));
        Expression::Cast(Box::new(Cast {
            this: inner,
            to: DataType::Date,
            trailing_comments: vec![],
            double_colon_syntax: false,
            format: None,
            default: None,
        }))
    }

    /// CAST(CAST(expr AS DATETIME2) AS DATE) - TSQL variant
    fn double_cast_datetime2_date(expr: Expression) -> Expression {
        use crate::expressions::{Cast, DataType};
        let inner = Expression::Cast(Box::new(Cast {
            this: expr,
            to: DataType::Custom {
                name: "DATETIME2".to_string(),
            },
            trailing_comments: vec![],
            double_colon_syntax: false,
            format: None,
            default: None,
        }));
        Expression::Cast(Box::new(Cast {
            this: inner,
            to: DataType::Date,
            trailing_comments: vec![],
            double_colon_syntax: false,
            format: None,
            default: None,
        }))
    }

    /// Convert Hive/Java-style date format strings to C-style (strftime) format
    /// e.g., "yyyy-MM-dd'T'HH" -> "%Y-%m-%d'T'%H"
    fn hive_format_to_c_format(fmt: &str) -> String {
        let mut result = String::new();
        let chars: Vec<char> = fmt.chars().collect();
        let mut i = 0;
        while i < chars.len() {
            match chars[i] {
                'y' => {
                    let mut count = 0;
                    while i < chars.len() && chars[i] == 'y' {
                        count += 1;
                        i += 1;
                    }
                    if count >= 4 {
                        result.push_str("%Y");
                    } else if count == 2 {
                        result.push_str("%y");
                    } else {
                        result.push_str("%Y");
                    }
                }
                'M' => {
                    let mut count = 0;
                    while i < chars.len() && chars[i] == 'M' {
                        count += 1;
                        i += 1;
                    }
                    if count >= 3 {
                        result.push_str("%b");
                    } else if count == 2 {
                        result.push_str("%m");
                    } else {
                        result.push_str("%m");
                    }
                }
                'd' => {
                    let mut _count = 0;
                    while i < chars.len() && chars[i] == 'd' {
                        _count += 1;
                        i += 1;
                    }
                    result.push_str("%d");
                }
                'H' => {
                    let mut _count = 0;
                    while i < chars.len() && chars[i] == 'H' {
                        _count += 1;
                        i += 1;
                    }
                    result.push_str("%H");
                }
                'h' => {
                    let mut _count = 0;
                    while i < chars.len() && chars[i] == 'h' {
                        _count += 1;
                        i += 1;
                    }
                    result.push_str("%I");
                }
                'm' => {
                    let mut _count = 0;
                    while i < chars.len() && chars[i] == 'm' {
                        _count += 1;
                        i += 1;
                    }
                    result.push_str("%M");
                }
                's' => {
                    let mut _count = 0;
                    while i < chars.len() && chars[i] == 's' {
                        _count += 1;
                        i += 1;
                    }
                    result.push_str("%S");
                }
                'S' => {
                    // Fractional seconds - skip
                    while i < chars.len() && chars[i] == 'S' {
                        i += 1;
                    }
                    result.push_str("%f");
                }
                'a' => {
                    // AM/PM
                    while i < chars.len() && chars[i] == 'a' {
                        i += 1;
                    }
                    result.push_str("%p");
                }
                'E' => {
                    let mut count = 0;
                    while i < chars.len() && chars[i] == 'E' {
                        count += 1;
                        i += 1;
                    }
                    if count >= 4 {
                        result.push_str("%A");
                    } else {
                        result.push_str("%a");
                    }
                }
                '\'' => {
                    // Quoted literal text - pass through the quotes and content
                    result.push('\'');
                    i += 1;
                    while i < chars.len() && chars[i] != '\'' {
                        result.push(chars[i]);
                        i += 1;
                    }
                    if i < chars.len() {
                        result.push('\'');
                        i += 1;
                    }
                }
                c => {
                    result.push(c);
                    i += 1;
                }
            }
        }
        result
    }

    /// Convert Hive/Java format to Presto format (uses %T for HH:mm:ss)
    fn hive_format_to_presto_format(fmt: &str) -> String {
        let c_fmt = Self::hive_format_to_c_format(fmt);
        // Presto uses %T for HH:MM:SS
        c_fmt.replace("%H:%M:%S", "%T")
    }

    /// Ensure a timestamp-like expression for DuckDB with CAST(... AS TIMESTAMP)
    fn ensure_cast_timestamp(expr: Expression) -> Expression {
        use crate::expressions::{Cast, DataType, Literal};
        match expr {
            Expression::Literal(Literal::Timestamp(s)) => Expression::Cast(Box::new(Cast {
                this: Expression::Literal(Literal::String(s)),
                to: DataType::Timestamp {
                    timezone: false,
                    precision: None,
                },
                trailing_comments: vec![],
                double_colon_syntax: false,
                format: None,
                default: None,
            })),
            Expression::Literal(Literal::String(ref _s)) => Expression::Cast(Box::new(Cast {
                this: expr,
                to: DataType::Timestamp {
                    timezone: false,
                    precision: None,
                },
                trailing_comments: vec![],
                double_colon_syntax: false,
                format: None,
                default: None,
            })),
            Expression::Literal(Literal::Datetime(s)) => Expression::Cast(Box::new(Cast {
                this: Expression::Literal(Literal::String(s)),
                to: DataType::Timestamp {
                    timezone: false,
                    precision: None,
                },
                trailing_comments: vec![],
                double_colon_syntax: false,
                format: None,
                default: None,
            })),
            other => other,
        }
    }

    /// Force CAST to TIMESTAMP for any expression (not just literals)
    /// Used when transpiling from Redshift/TSQL where DATEDIFF/DATEADD args need explicit timestamp cast
    fn force_cast_timestamp(expr: Expression) -> Expression {
        use crate::expressions::{Cast, DataType};
        // Don't double-wrap if already a CAST to TIMESTAMP
        if let Expression::Cast(ref c) = expr {
            if matches!(c.to, DataType::Timestamp { .. }) {
                return expr;
            }
        }
        Expression::Cast(Box::new(Cast {
            this: expr,
            to: DataType::Timestamp {
                timezone: false,
                precision: None,
            },
            trailing_comments: vec![],
            double_colon_syntax: false,
            format: None,
            default: None,
        }))
    }

    /// Ensure a timestamp-like expression for DuckDB with CAST(... AS TIMESTAMPTZ)
    fn ensure_cast_timestamptz(expr: Expression) -> Expression {
        use crate::expressions::{Cast, DataType, Literal};
        match expr {
            Expression::Literal(Literal::Timestamp(s)) => Expression::Cast(Box::new(Cast {
                this: Expression::Literal(Literal::String(s)),
                to: DataType::Timestamp {
                    timezone: true,
                    precision: None,
                },
                trailing_comments: vec![],
                double_colon_syntax: false,
                format: None,
                default: None,
            })),
            Expression::Literal(Literal::String(ref _s)) => Expression::Cast(Box::new(Cast {
                this: expr,
                to: DataType::Timestamp {
                    timezone: true,
                    precision: None,
                },
                trailing_comments: vec![],
                double_colon_syntax: false,
                format: None,
                default: None,
            })),
            Expression::Literal(Literal::Datetime(s)) => Expression::Cast(Box::new(Cast {
                this: Expression::Literal(Literal::String(s)),
                to: DataType::Timestamp {
                    timezone: true,
                    precision: None,
                },
                trailing_comments: vec![],
                double_colon_syntax: false,
                format: None,
                default: None,
            })),
            other => other,
        }
    }

    /// Ensure expression is CAST to DATETIME (for BigQuery)
    fn ensure_cast_datetime(expr: Expression) -> Expression {
        use crate::expressions::{Cast, DataType, Literal};
        match expr {
            Expression::Literal(Literal::String(ref _s)) => Expression::Cast(Box::new(Cast {
                this: expr,
                to: DataType::Custom {
                    name: "DATETIME".to_string(),
                },
                trailing_comments: vec![],
                double_colon_syntax: false,
                format: None,
                default: None,
            })),
            other => other,
        }
    }

    /// Force CAST expression to DATETIME (for BigQuery) - always wraps unless already DATETIME
    fn force_cast_datetime(expr: Expression) -> Expression {
        use crate::expressions::{Cast, DataType};
        if let Expression::Cast(ref c) = expr {
            if let DataType::Custom { ref name } = c.to {
                if name.eq_ignore_ascii_case("DATETIME") {
                    return expr;
                }
            }
        }
        Expression::Cast(Box::new(Cast {
            this: expr,
            to: DataType::Custom {
                name: "DATETIME".to_string(),
            },
            trailing_comments: vec![],
            double_colon_syntax: false,
            format: None,
            default: None,
        }))
    }

    /// Ensure expression is CAST to DATETIME2 (for TSQL)
    fn ensure_cast_datetime2(expr: Expression) -> Expression {
        use crate::expressions::{Cast, DataType, Literal};
        match expr {
            Expression::Literal(Literal::String(ref _s)) => Expression::Cast(Box::new(Cast {
                this: expr,
                to: DataType::Custom {
                    name: "DATETIME2".to_string(),
                },
                trailing_comments: vec![],
                double_colon_syntax: false,
                format: None,
                default: None,
            })),
            other => other,
        }
    }

    /// Convert TIMESTAMP 'x' literal to CAST('x' AS TIMESTAMPTZ) for DuckDB
    fn ts_literal_to_cast_tz(expr: Expression) -> Expression {
        use crate::expressions::{Cast, DataType, Literal};
        match expr {
            Expression::Literal(Literal::Timestamp(s)) => Expression::Cast(Box::new(Cast {
                this: Expression::Literal(Literal::String(s)),
                to: DataType::Timestamp {
                    timezone: true,
                    precision: None,
                },
                trailing_comments: vec![],
                double_colon_syntax: false,
                format: None,
                default: None,
            })),
            other => other,
        }
    }

    /// Convert BigQuery format string to Snowflake format string
    fn bq_format_to_snowflake(format_expr: &Expression) -> Expression {
        use crate::expressions::Literal;
        if let Expression::Literal(Literal::String(s)) = format_expr {
            let sf = s
                .replace("%Y", "yyyy")
                .replace("%m", "mm")
                .replace("%d", "DD")
                .replace("%H", "HH24")
                .replace("%M", "MI")
                .replace("%S", "SS")
                .replace("%b", "mon")
                .replace("%B", "Month")
                .replace("%e", "FMDD");
            Expression::Literal(Literal::String(sf))
        } else {
            format_expr.clone()
        }
    }

    /// Convert BigQuery format string to DuckDB format string
    fn bq_format_to_duckdb(format_expr: &Expression) -> Expression {
        use crate::expressions::Literal;
        if let Expression::Literal(Literal::String(s)) = format_expr {
            let duck = s
                .replace("%T", "%H:%M:%S")
                .replace("%F", "%Y-%m-%d")
                .replace("%D", "%m/%d/%y")
                .replace("%x", "%m/%d/%y")
                .replace("%c", "%a %b %-d %H:%M:%S %Y")
                .replace("%e", "%-d")
                .replace("%E6S", "%S.%f");
            Expression::Literal(Literal::String(duck))
        } else {
            format_expr.clone()
        }
    }

    /// Convert BigQuery CAST FORMAT elements (like YYYY, MM, DD) to strftime (like %Y, %m, %d)
    fn bq_cast_format_to_strftime(format_expr: &Expression) -> Expression {
        use crate::expressions::Literal;
        if let Expression::Literal(Literal::String(s)) = format_expr {
            // Replace format elements from longest to shortest to avoid partial matches
            let result = s
                .replace("YYYYMMDD", "%Y%m%d")
                .replace("YYYY", "%Y")
                .replace("YY", "%y")
                .replace("MONTH", "%B")
                .replace("MON", "%b")
                .replace("MM", "%m")
                .replace("DD", "%d")
                .replace("HH24", "%H")
                .replace("HH12", "%I")
                .replace("HH", "%I")
                .replace("MI", "%M")
                .replace("SSTZH", "%S%z")
                .replace("SS", "%S")
                .replace("TZH", "%z");
            Expression::Literal(Literal::String(result))
        } else {
            format_expr.clone()
        }
    }

    /// Normalize BigQuery format strings for BQ->BQ output
    fn bq_format_normalize_bq(format_expr: &Expression) -> Expression {
        use crate::expressions::Literal;
        if let Expression::Literal(Literal::String(s)) = format_expr {
            let norm = s.replace("%H:%M:%S", "%T").replace("%x", "%D");
            Expression::Literal(Literal::String(norm))
        } else {
            format_expr.clone()
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_dialect_type_from_str() {
        assert_eq!(
            "postgres".parse::<DialectType>().unwrap(),
            DialectType::PostgreSQL
        );
        assert_eq!(
            "postgresql".parse::<DialectType>().unwrap(),
            DialectType::PostgreSQL
        );
        assert_eq!("mysql".parse::<DialectType>().unwrap(), DialectType::MySQL);
        assert_eq!(
            "bigquery".parse::<DialectType>().unwrap(),
            DialectType::BigQuery
        );
    }

    #[test]
    fn test_basic_transpile() {
        let dialect = Dialect::get(DialectType::Generic);
        let result = dialect
            .transpile_to("SELECT 1", DialectType::PostgreSQL)
            .unwrap();
        assert_eq!(result.len(), 1);
        assert_eq!(result[0], "SELECT 1");
    }

    #[test]
    fn test_function_transformation_mysql() {
        // NVL should be transformed to IFNULL in MySQL
        let dialect = Dialect::get(DialectType::Generic);
        let result = dialect
            .transpile_to("SELECT NVL(a, b)", DialectType::MySQL)
            .unwrap();
        assert_eq!(result[0], "SELECT IFNULL(a, b)");
    }

    #[test]
    fn test_get_path_duckdb() {
        // Test: step by step
        let snowflake = Dialect::get(DialectType::Snowflake);

        // Step 1: Parse and check what Snowflake produces as intermediate
        let result_sf_sf = snowflake
            .transpile_to(
                "SELECT PARSE_JSON('{\"fruit\":\"banana\"}'):fruit",
                DialectType::Snowflake,
            )
            .unwrap();
        eprintln!("Snowflake->Snowflake colon: {}", result_sf_sf[0]);

        // Step 2: DuckDB target
        let result_sf_dk = snowflake
            .transpile_to(
                "SELECT PARSE_JSON('{\"fruit\":\"banana\"}'):fruit",
                DialectType::DuckDB,
            )
            .unwrap();
        eprintln!("Snowflake->DuckDB colon: {}", result_sf_dk[0]);

        // Step 3: GET_PATH directly
        let result_gp = snowflake
            .transpile_to(
                "SELECT GET_PATH(PARSE_JSON('{\"fruit\":\"banana\"}'), 'fruit')",
                DialectType::DuckDB,
            )
            .unwrap();
        eprintln!("Snowflake->DuckDB explicit GET_PATH: {}", result_gp[0]);
    }

    #[test]
    fn test_function_transformation_postgres() {
        // IFNULL should be transformed to COALESCE in PostgreSQL
        let dialect = Dialect::get(DialectType::Generic);
        let result = dialect
            .transpile_to("SELECT IFNULL(a, b)", DialectType::PostgreSQL)
            .unwrap();
        assert_eq!(result[0], "SELECT COALESCE(a, b)");

        // NVL should also be transformed to COALESCE
        let result = dialect
            .transpile_to("SELECT NVL(a, b)", DialectType::PostgreSQL)
            .unwrap();
        assert_eq!(result[0], "SELECT COALESCE(a, b)");
    }

    #[test]
    fn test_hive_cast_to_trycast() {
        // Hive CAST should become TRY_CAST for targets that support it
        let hive = Dialect::get(DialectType::Hive);
        let result = hive
            .transpile_to("CAST(1 AS INT)", DialectType::DuckDB)
            .unwrap();
        assert_eq!(result[0], "TRY_CAST(1 AS INT)");

        let result = hive
            .transpile_to("CAST(1 AS INT)", DialectType::Presto)
            .unwrap();
        assert_eq!(result[0], "TRY_CAST(1 AS INTEGER)");
    }

    #[test]
    fn test_hive_array_identity() {
        // Hive ARRAY<DATE> should preserve angle bracket syntax
        let sql = "CREATE EXTERNAL TABLE `my_table` (`a7` ARRAY<DATE>) ROW FORMAT SERDE 'a' STORED AS INPUTFORMAT 'b' OUTPUTFORMAT 'c' LOCATION 'd' TBLPROPERTIES ('e'='f')";
        let hive = Dialect::get(DialectType::Hive);

        // Test via transpile_to (this works)
        let result = hive.transpile_to(sql, DialectType::Hive).unwrap();
        eprintln!("Hive ARRAY via transpile_to: {}", result[0]);
        assert!(
            result[0].contains("ARRAY<DATE>"),
            "transpile_to: Expected ARRAY<DATE>, got: {}",
            result[0]
        );

        // Test via parse -> transform -> generate (identity test path)
        let ast = hive.parse(sql).unwrap();
        let transformed = hive.transform(ast[0].clone()).unwrap();
        let output = hive.generate(&transformed).unwrap();
        eprintln!("Hive ARRAY via identity path: {}", output);
        assert!(
            output.contains("ARRAY<DATE>"),
            "identity path: Expected ARRAY<DATE>, got: {}",
            output
        );
    }

    #[test]
    fn test_starrocks_delete_between_expansion() {
        // StarRocks doesn't support BETWEEN in DELETE statements
        let dialect = Dialect::get(DialectType::Generic);

        // BETWEEN should be expanded to >= AND <= in DELETE
        let result = dialect
            .transpile_to(
                "DELETE FROM t WHERE a BETWEEN b AND c",
                DialectType::StarRocks,
            )
            .unwrap();
        assert_eq!(result[0], "DELETE FROM t WHERE a >= b AND a <= c");

        // NOT BETWEEN should be expanded to < OR > in DELETE
        let result = dialect
            .transpile_to(
                "DELETE FROM t WHERE a NOT BETWEEN b AND c",
                DialectType::StarRocks,
            )
            .unwrap();
        assert_eq!(result[0], "DELETE FROM t WHERE a < b OR a > c");

        // BETWEEN in SELECT should NOT be expanded (StarRocks supports it there)
        let result = dialect
            .transpile_to(
                "SELECT * FROM t WHERE a BETWEEN b AND c",
                DialectType::StarRocks,
            )
            .unwrap();
        assert!(
            result[0].contains("BETWEEN"),
            "BETWEEN should be preserved in SELECT"
        );
    }

    #[test]
    fn test_snowflake_ltrim_rtrim_parse() {
        let sf = Dialect::get(DialectType::Snowflake);
        let sql = "SELECT LTRIM(RTRIM(col)) FROM t1";
        let result = sf.transpile_to(sql, DialectType::DuckDB);
        match &result {
            Ok(r) => eprintln!("LTRIM/RTRIM result: {}", r[0]),
            Err(e) => eprintln!("LTRIM/RTRIM error: {}", e),
        }
        assert!(
            result.is_ok(),
            "Expected successful parse of LTRIM(RTRIM(col)), got error: {:?}",
            result.err()
        );
    }

    #[test]
    fn test_duckdb_count_if_parse() {
        let duck = Dialect::get(DialectType::DuckDB);
        let sql = "COUNT_IF(x)";
        let result = duck.transpile_to(sql, DialectType::DuckDB);
        match &result {
            Ok(r) => eprintln!("COUNT_IF result: {}", r[0]),
            Err(e) => eprintln!("COUNT_IF error: {}", e),
        }
        assert!(
            result.is_ok(),
            "Expected successful parse of COUNT_IF(x), got error: {:?}",
            result.err()
        );
    }

    #[test]
    fn test_tsql_cast_tinyint_parse() {
        let tsql = Dialect::get(DialectType::TSQL);
        let sql = "CAST(X AS TINYINT)";
        let result = tsql.transpile_to(sql, DialectType::DuckDB);
        match &result {
            Ok(r) => eprintln!("TSQL CAST TINYINT result: {}", r[0]),
            Err(e) => eprintln!("TSQL CAST TINYINT error: {}", e),
        }
        assert!(
            result.is_ok(),
            "Expected successful transpile, got error: {:?}",
            result.err()
        );
    }

    #[test]
    fn test_pg_hash_bitwise_xor() {
        let dialect = Dialect::get(DialectType::PostgreSQL);
        let result = dialect
            .transpile_to("x # y", DialectType::PostgreSQL)
            .unwrap();
        assert_eq!(result[0], "x # y");
    }

    #[test]
    fn test_pg_array_to_duckdb() {
        let dialect = Dialect::get(DialectType::PostgreSQL);
        let result = dialect
            .transpile_to("SELECT ARRAY[1, 2, 3] @> ARRAY[1, 2]", DialectType::DuckDB)
            .unwrap();
        assert_eq!(result[0], "SELECT [1, 2, 3] @> [1, 2]");
    }

    #[test]
    fn test_array_remove_bigquery() {
        let dialect = Dialect::get(DialectType::Generic);
        let result = dialect
            .transpile_to("ARRAY_REMOVE(the_array, target)", DialectType::BigQuery)
            .unwrap();
        assert_eq!(
            result[0],
            "ARRAY(SELECT _u FROM UNNEST(the_array) AS _u WHERE _u <> target)"
        );
    }

    #[test]
    fn test_map_clickhouse_case() {
        let dialect = Dialect::get(DialectType::Generic);
        let parsed = dialect
            .parse("CAST(MAP('a', '1') AS MAP(TEXT, TEXT))")
            .unwrap();
        eprintln!("MAP parsed: {:?}", parsed);
        let result = dialect
            .transpile_to(
                "CAST(MAP('a', '1') AS MAP(TEXT, TEXT))",
                DialectType::ClickHouse,
            )
            .unwrap();
        eprintln!("MAP result: {}", result[0]);
    }

    #[test]
    fn test_generate_date_array_presto() {
        let dialect = Dialect::get(DialectType::Generic);
        let result = dialect.transpile_to(
            "SELECT * FROM UNNEST(GENERATE_DATE_ARRAY(DATE '2020-01-01', DATE '2020-02-01', INTERVAL 1 WEEK))",
            DialectType::Presto,
        ).unwrap();
        eprintln!("GDA -> Presto: {}", result[0]);
        assert_eq!(result[0], "SELECT * FROM UNNEST(SEQUENCE(CAST('2020-01-01' AS DATE), CAST('2020-02-01' AS DATE), (1 * INTERVAL '7' DAY)))");
    }

    #[test]
    fn test_generate_date_array_postgres() {
        let dialect = Dialect::get(DialectType::Generic);
        let result = dialect.transpile_to(
            "SELECT * FROM UNNEST(GENERATE_DATE_ARRAY(DATE '2020-01-01', DATE '2020-02-01', INTERVAL 1 WEEK))",
            DialectType::PostgreSQL,
        ).unwrap();
        eprintln!("GDA -> PostgreSQL: {}", result[0]);
    }

    #[test]
    fn test_generate_date_array_snowflake() {
        let dialect = Dialect::get(DialectType::Generic);
        let result = dialect.transpile_to(
            "SELECT * FROM UNNEST(GENERATE_DATE_ARRAY(DATE '2020-01-01', DATE '2020-02-01', INTERVAL 1 WEEK))",
            DialectType::Snowflake,
        ).unwrap();
        eprintln!("GDA -> Snowflake: {}", result[0]);
    }

    #[test]
    fn test_array_length_generate_date_array_snowflake() {
        let dialect = Dialect::get(DialectType::Generic);
        let result = dialect.transpile_to(
            "SELECT ARRAY_LENGTH(GENERATE_DATE_ARRAY(DATE '2020-01-01', DATE '2020-02-01', INTERVAL 1 WEEK))",
            DialectType::Snowflake,
        ).unwrap();
        eprintln!("ARRAY_LENGTH(GDA) -> Snowflake: {}", result[0]);
    }

    #[test]
    fn test_generate_date_array_mysql() {
        let dialect = Dialect::get(DialectType::Generic);
        let result = dialect.transpile_to(
            "SELECT * FROM UNNEST(GENERATE_DATE_ARRAY(DATE '2020-01-01', DATE '2020-02-01', INTERVAL 1 WEEK))",
            DialectType::MySQL,
        ).unwrap();
        eprintln!("GDA -> MySQL: {}", result[0]);
    }

    #[test]
    fn test_generate_date_array_redshift() {
        let dialect = Dialect::get(DialectType::Generic);
        let result = dialect.transpile_to(
            "SELECT * FROM UNNEST(GENERATE_DATE_ARRAY(DATE '2020-01-01', DATE '2020-02-01', INTERVAL 1 WEEK))",
            DialectType::Redshift,
        ).unwrap();
        eprintln!("GDA -> Redshift: {}", result[0]);
    }

    #[test]
    fn test_generate_date_array_tsql() {
        let dialect = Dialect::get(DialectType::Generic);
        let result = dialect.transpile_to(
            "SELECT * FROM UNNEST(GENERATE_DATE_ARRAY(DATE '2020-01-01', DATE '2020-02-01', INTERVAL 1 WEEK))",
            DialectType::TSQL,
        ).unwrap();
        eprintln!("GDA -> TSQL: {}", result[0]);
    }

    #[test]
    fn test_struct_colon_syntax() {
        let dialect = Dialect::get(DialectType::Generic);
        // Test without colon first
        let result = dialect.transpile_to(
            "CAST((1, 2, 3, 4) AS STRUCT<a TINYINT, b SMALLINT, c INT, d BIGINT>)",
            DialectType::ClickHouse,
        );
        match result {
            Ok(r) => eprintln!("STRUCT no colon -> ClickHouse: {}", r[0]),
            Err(e) => eprintln!("STRUCT no colon error: {}", e),
        }
        // Now test with colon
        let result = dialect.transpile_to(
            "CAST((1, 2, 3, 4) AS STRUCT<a: TINYINT, b: SMALLINT, c: INT, d: BIGINT>)",
            DialectType::ClickHouse,
        );
        match result {
            Ok(r) => eprintln!("STRUCT colon -> ClickHouse: {}", r[0]),
            Err(e) => eprintln!("STRUCT colon error: {}", e),
        }
    }

    #[test]
    fn test_generate_date_array_cte_wrapped_mysql() {
        let dialect = Dialect::get(DialectType::Generic);
        let result = dialect.transpile_to(
            "WITH dates AS (SELECT * FROM UNNEST(GENERATE_DATE_ARRAY(DATE '2020-01-01', DATE '2020-02-01', INTERVAL 1 WEEK))) SELECT * FROM dates",
            DialectType::MySQL,
        ).unwrap();
        eprintln!("GDA CTE -> MySQL: {}", result[0]);
    }

    #[test]
    fn test_generate_date_array_cte_wrapped_tsql() {
        let dialect = Dialect::get(DialectType::Generic);
        let result = dialect.transpile_to(
            "WITH dates AS (SELECT * FROM UNNEST(GENERATE_DATE_ARRAY(DATE '2020-01-01', DATE '2020-02-01', INTERVAL 1 WEEK))) SELECT * FROM dates",
            DialectType::TSQL,
        ).unwrap();
        eprintln!("GDA CTE -> TSQL: {}", result[0]);
    }

    #[test]
    fn test_decode_literal_no_null_check() {
        // Oracle DECODE with all literals should produce simple equality, no IS NULL
        let dialect = Dialect::get(DialectType::Oracle);
        let result = dialect
            .transpile_to("SELECT decode(1,2,3,4)", DialectType::DuckDB)
            .unwrap();
        assert_eq!(
            result[0], "SELECT CASE WHEN 1 = 2 THEN 3 ELSE 4 END",
            "Literal DECODE should not have IS NULL checks"
        );
    }

    #[test]
    fn test_decode_column_vs_literal_no_null_check() {
        // Oracle DECODE with column vs literal should use simple equality (like sqlglot)
        let dialect = Dialect::get(DialectType::Oracle);
        let result = dialect
            .transpile_to("SELECT decode(col, 2, 3, 4) FROM t", DialectType::DuckDB)
            .unwrap();
        assert_eq!(
            result[0], "SELECT CASE WHEN col = 2 THEN 3 ELSE 4 END FROM t",
            "Column vs literal DECODE should not have IS NULL checks"
        );
    }

    #[test]
    fn test_decode_column_vs_column_keeps_null_check() {
        // Oracle DECODE with column vs column should keep null-safe comparison
        let dialect = Dialect::get(DialectType::Oracle);
        let result = dialect
            .transpile_to("SELECT decode(col, col2, 3, 4) FROM t", DialectType::DuckDB)
            .unwrap();
        assert!(
            result[0].contains("IS NULL"),
            "Column vs column DECODE should have IS NULL checks, got: {}",
            result[0]
        );
    }

    #[test]
    fn test_decode_null_search() {
        // Oracle DECODE with NULL search should use IS NULL
        let dialect = Dialect::get(DialectType::Oracle);
        let result = dialect
            .transpile_to("SELECT decode(col, NULL, 3, 4) FROM t", DialectType::DuckDB)
            .unwrap();
        assert_eq!(
            result[0],
            "SELECT CASE WHEN col IS NULL THEN 3 ELSE 4 END FROM t",
        );
    }
}
