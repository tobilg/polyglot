{
  "dialect": "oracle",
  "identity": [
    {
      "sql": "1 /* /* */",
      "expected": null
    },
    {
      "sql": "XMLELEMENT(EVALNAME foo + bar)",
      "expected": null
    },
    {
      "sql": "SELECT BITMAP_BUCKET_NUMBER(32769)",
      "expected": null
    },
    {
      "sql": "SELECT BITMAP_CONSTRUCT_AGG(value)",
      "expected": null
    },
    {
      "sql": "DBMS_RANDOM.NORMAL",
      "expected": null
    },
    {
      "sql": "CAST(value AS NUMBER DEFAULT 0 ON CONVERSION ERROR)",
      "expected": null
    },
    {
      "sql": "SYSDATE",
      "expected": null
    },
    {
      "sql": "CREATE GLOBAL TEMPORARY TABLE t AS SELECT * FROM orders",
      "expected": null
    },
    {
      "sql": "CREATE PRIVATE TEMPORARY TABLE t AS SELECT * FROM orders",
      "expected": null
    },
    {
      "sql": "REGEXP_REPLACE('source', 'search')",
      "expected": null
    },
    {
      "sql": "TIMESTAMP(3) WITH TIME ZONE",
      "expected": null
    },
    {
      "sql": "SELECT SYSTIMESTAMP AT TIME ZONE 'UTC'",
      "expected": null
    },
    {
      "sql": "CURRENT_TIMESTAMP(precision)",
      "expected": null
    },
    {
      "sql": "ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol",
      "expected": null
    },
    {
      "sql": "ALTER TABLE Payments ADD Stock NUMBER NOT NULL",
      "expected": null
    },
    {
      "sql": "SELECT x FROM t WHERE cond FOR UPDATE",
      "expected": null
    },
    {
      "sql": "SELECT JSON_OBJECT(k1: v1 FORMAT JSON, k2: v2 FORMAT JSON)",
      "expected": null
    },
    {
      "sql": "SELECT JSON_OBJECT('name': first_name || ' ' || last_name) FROM t",
      "expected": null
    },
    {
      "sql": "COALESCE(c1, c2, c3)",
      "expected": null
    },
    {
      "sql": "SELECT * FROM TABLE(foo)",
      "expected": null
    },
    {
      "sql": "SELECT a$x#b",
      "expected": null
    },
    {
      "sql": "SELECT :OBJECT",
      "expected": null
    },
    {
      "sql": "SELECT * FROM t FOR UPDATE",
      "expected": null
    },
    {
      "sql": "SELECT * FROM t FOR UPDATE WAIT 5",
      "expected": null
    },
    {
      "sql": "SELECT * FROM t FOR UPDATE NOWAIT",
      "expected": null
    },
    {
      "sql": "SELECT * FROM t FOR UPDATE SKIP LOCKED",
      "expected": null
    },
    {
      "sql": "SELECT * FROM t FOR UPDATE OF s.t.c, s.t.v",
      "expected": null
    },
    {
      "sql": "SELECT * FROM t FOR UPDATE OF s.t.c, s.t.v NOWAIT",
      "expected": null
    },
    {
      "sql": "SELECT * FROM t FOR UPDATE OF s.t.c, s.t.v SKIP LOCKED",
      "expected": null
    },
    {
      "sql": "SELECT STANDARD_HASH('hello')",
      "expected": null
    },
    {
      "sql": "SELECT STANDARD_HASH('hello', 'MD5')",
      "expected": null
    },
    {
      "sql": "SELECT * FROM table_name@dblink_name.database_link_domain",
      "expected": null
    },
    {
      "sql": "SELECT * FROM table_name SAMPLE (25) s",
      "expected": null
    },
    {
      "sql": "SELECT COUNT(*) * 10 FROM orders SAMPLE (10) SEED (1)",
      "expected": null
    },
    {
      "sql": "SELECT * FROM V$SESSION",
      "expected": null
    },
    {
      "sql": "SELECT TO_DATE('January 15, 1989, 11:00 A.M.')",
      "expected": null
    },
    {
      "sql": "SELECT INSTR(haystack, needle)",
      "expected": null
    },
    {
      "sql": "SELECT (TIMESTAMP '2025-12-30 20:00:00' - TIMESTAMP '2025-12-29 14:30:00') DAY TO SECOND",
      "expected": "SELECT (TO_TIMESTAMP('2025-12-30 20:00:00', 'YYYY-MM-DD HH24:MI:SS.FF6') - TO_TIMESTAMP('2025-12-29 14:30:00', 'YYYY-MM-DD HH24:MI:SS.FF6')) DAY TO SECOND"
    },
    {
      "sql": "SELECT (SYSTIMESTAMP - order_date) DAY(9) TO SECOND FROM orders",
      "expected": null
    },
    {
      "sql": "SELECT (SYSTIMESTAMP - order_date) DAY(9) TO SECOND(3) FROM orders",
      "expected": null
    },
    {
      "sql": "SELECT * FROM consumer LEFT JOIN groceries ON consumer.groceries_id = consumer.id PIVOT(MAX(type_id) FOR consumer_type IN (1, 2, 3, 4))",
      "expected": null
    },
    {
      "sql": "SELECT * FROM test UNPIVOT INCLUDE NULLS (value FOR Description IN (col AS 'PREFIX ' || CHR(38) || ' SUFFIX'))",
      "expected": null
    },
    {
      "sql": "SELECT last_name, employee_id, manager_id, LEVEL FROM employees START WITH employee_id = 100 CONNECT BY PRIOR employee_id = manager_id ORDER SIBLINGS BY last_name",
      "expected": null
    },
    {
      "sql": "ALTER TABLE Payments ADD (Stock NUMBER NOT NULL, dropid VARCHAR2(500) NOT NULL)",
      "expected": null
    },
    {
      "sql": "SELECT JSON_ARRAYAGG(JSON_OBJECT('RNK': RNK, 'RATING_CODE': RATING_CODE, 'DATE_VALUE': DATE_VALUE, 'AGENT_ID': AGENT_ID RETURNING CLOB) RETURNING CLOB) AS JSON_DATA FROM tablename",
      "expected": null
    },
    {
      "sql": "SELECT JSON_ARRAY(FOO() FORMAT JSON, BAR() NULL ON NULL RETURNING CLOB STRICT)",
      "expected": null
    },
    {
      "sql": "SELECT JSON_ARRAYAGG(FOO() FORMAT JSON ORDER BY bar NULL ON NULL RETURNING CLOB STRICT)",
      "expected": null
    },
    {
      "sql": "SELECT COUNT(1) INTO V_Temp FROM TABLE(CAST(somelist AS data_list)) WHERE col LIKE '%contact'",
      "expected": null
    },
    {
      "sql": "SELECT department_id INTO v_department_id FROM departments FETCH FIRST 1 ROWS ONLY",
      "expected": null
    },
    {
      "sql": "SELECT department_id BULK COLLECT INTO v_department_ids FROM departments",
      "expected": null
    },
    {
      "sql": "SELECT department_id, department_name BULK COLLECT INTO v_department_ids, v_department_names FROM departments",
      "expected": null
    },
    {
      "sql": "SELECT MIN(column_name) KEEP (DENSE_RANK FIRST ORDER BY column_name DESC) FROM table_name",
      "expected": null
    },
    {
      "sql": "XMLELEMENT(\"ImageID\", image.id)",
      "expected": "XMLELEMENT(NAME \"ImageID\", image.id)"
    },
    {
      "sql": "SELECT CAST('January 15, 1989, 11:00 A.M.' AS DATE DEFAULT NULL ON CONVERSION ERROR, 'Month dd, YYYY, HH:MI A.M.') FROM DUAL",
      "expected": "SELECT TO_DATE('January 15, 1989, 11:00 A.M.', 'Month dd, YYYY, HH12:MI A.M.') FROM DUAL"
    },
    {
      "sql": "SELECT TRUNC(SYSDATE)",
      "expected": "SELECT TRUNC(SYSDATE, 'DD')"
    },
    {
      "sql": "SELECT JSON_OBJECT(KEY 'key1' IS emp.column1, KEY 'key2' IS emp.column1) \"emp_key\" FROM emp",
      "expected": "SELECT JSON_OBJECT('key1': emp.column1, 'key2': emp.column1) AS \"emp_key\" FROM emp"
    },
    {
      "sql": "SELECT JSON_OBJECTAGG(KEY department_name VALUE department_id) FROM dep WHERE id <= 30",
      "expected": "SELECT JSON_OBJECTAGG(department_name: department_id) FROM dep WHERE id <= 30"
    },
    {
      "sql": "SELECT last_name, department_id, salary, MIN(salary) KEEP (DENSE_RANK FIRST ORDER BY commission_pct) OVER (PARTITION BY department_id) AS \"Worst\", MAX(salary) KEEP (DENSE_RANK LAST ORDER BY commission_pct) OVER (PARTITION BY department_id) AS \"Best\" FROM employees ORDER BY department_id, salary, last_name",
      "expected": null
    },
    {
      "sql": "SELECT UNIQUE col1, col2 FROM table",
      "expected": "SELECT DISTINCT col1, col2 FROM table"
    },
    {
      "sql": "SELECT * FROM T ORDER BY I OFFSET NVL(:variable1, 10) ROWS FETCH NEXT NVL(:variable2, 10) ROWS ONLY",
      "expected": null
    },
    {
      "sql": "SELECT * FROM t SAMPLE (.25)",
      "expected": "SELECT * FROM t SAMPLE (0.25)"
    },
    {
      "sql": "SELECT TO_CHAR(-100, 'L99', 'NL_CURRENCY = '' AusDollars '' ')",
      "expected": null
    },
    {
      "sql": "SELECT * FROM t START WITH col CONNECT BY NOCYCLE PRIOR col1 = col2",
      "expected": null
    },
    {
      "sql": "SELECT * FROM t ORDER BY a ASC NULLS LAST, b ASC NULLS FIRST, c DESC NULLS LAST, d DESC NULLS FIRST",
      "expected": "SELECT * FROM t ORDER BY a ASC, b ASC NULLS FIRST, c DESC NULLS LAST, d DESC"
    },
    {
      "sql": "SELECT /*+ ORDERED */* FROM tbl",
      "expected": "SELECT /*+ ORDERED */ * FROM tbl"
    },
    {
      "sql": "SELECT /* test */ /*+ ORDERED */* FROM tbl",
      "expected": "/* test */ SELECT /*+ ORDERED */ * FROM tbl"
    },
    {
      "sql": "SELECT /*+ ORDERED */*/* test */ FROM tbl",
      "expected": "SELECT /*+ ORDERED */ * /* test */ FROM tbl"
    },
    {
      "sql": "CREATE OR REPLACE FORCE VIEW foo1.foo2",
      "expected": null
    },
    {
      "sql": "TO_TIMESTAMP('foo')",
      "expected": null
    },
    {
      "sql": "SELECT TO_TIMESTAMP('05 Dec 2000 10:00 AM', 'DD Mon YYYY HH12:MI AM')",
      "expected": null
    },
    {
      "sql": "SELECT TO_TIMESTAMP('05 Dec 2000 10:00 PM', 'DD Mon YYYY HH12:MI PM')",
      "expected": null
    },
    {
      "sql": "SELECT TO_TIMESTAMP('05 Dec 2000 10:00 A.M.', 'DD Mon YYYY HH12:MI A.M.')",
      "expected": null
    },
    {
      "sql": "SELECT TO_TIMESTAMP('05 Dec 2000 10:00 P.M.', 'DD Mon YYYY HH12:MI P.M.')",
      "expected": null
    },
    {
      "sql": "SELECT CUME_DIST(15, 0.05) WITHIN GROUP (ORDER BY col1, col2) FROM t",
      "expected": null
    },
    {
      "sql": "SELECT DENSE_RANK(15, 0.05) WITHIN GROUP (ORDER BY col1, col2) FROM t",
      "expected": null
    },
    {
      "sql": "SELECT RANK(15, 0.05) WITHIN GROUP (ORDER BY col1, col2) FROM t",
      "expected": null
    },
    {
      "sql": "SELECT PERCENT_RANK(15, 0.05) WITHIN GROUP (ORDER BY col1, col2) FROM t",
      "expected": null
    },
    {
      "sql": "L2_DISTANCE(x, y)",
      "expected": null
    },
    {
      "sql": "BITMAP_OR_AGG(x)",
      "expected": null
    },
    {
      "sql": "SELECT e1.x, e2.x FROM e e1, e e2 WHERE e1.y (+) = e2.y",
      "expected": null
    },
    {
      "sql": "SELECT /*+ USE_NL(A B) */ A.COL_TEST FROM TABLE_A A, TABLE_B B",
      "expected": null
    },
    {
      "sql": "SELECT /*+ INDEX(v.j jhist_employee_ix (employee_id start_date)) */ * FROM v",
      "expected": null
    },
    {
      "sql": "SELECT /*+ USE_NL(A B C) */ A.COL_TEST FROM TABLE_A A, TABLE_B B, TABLE_C C",
      "expected": null
    },
    {
      "sql": "SELECT /*+ NO_INDEX(employees emp_empid) */ employee_id FROM employees WHERE employee_id > 200",
      "expected": null
    },
    {
      "sql": "SELECT /*+ NO_INDEX_FFS(items item_order_ix) */ order_id FROM order_items items",
      "expected": null
    },
    {
      "sql": "SELECT /*+ LEADING(e j) */ * FROM employees e, departments d, job_history j WHERE e.department_id = d.department_id AND e.hire_date = j.start_date",
      "expected": null
    },
    {
      "sql": "INSERT /*+ APPEND */ INTO IAP_TBL (id, col1) VALUES (2, 'test2')",
      "expected": null
    },
    {
      "sql": "INSERT /*+ APPEND_VALUES */ INTO dest_table VALUES (i, 'Value')",
      "expected": null
    },
    {
      "sql": "INSERT /*+ APPEND(d) */ INTO dest d VALUES (i, 'Value')",
      "expected": null
    },
    {
      "sql": "INSERT /*+ APPEND(d) */ INTO dest d (i, value) SELECT 1, 'value' FROM dual",
      "expected": null
    },
    {
      "sql": "SELECT /*+ LEADING(departments employees) USE_NL(employees) */ * FROM employees JOIN departments ON employees.department_id = departments.department_id",
      "expected": "SELECT /*+ LEADING(departments employees)\n  USE_NL(employees) */\n  *\nFROM employees\nJOIN departments\n  ON employees.department_id = departments.department_id"
    },
    {
      "sql": "SELECT /*+ USE_NL(bbbbbbbbbbbbbbbbbbbbbbbb) LEADING(aaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbbbbb cccccccccccccccccccccccc dddddddddddddddddddddddd) INDEX(cccccccccccccccccccccccc) */ * FROM aaaaaaaaaaaaaaaaaaaaaaaa JOIN bbbbbbbbbbbbbbbbbbbbbbbb ON aaaaaaaaaaaaaaaaaaaaaaaa.id = bbbbbbbbbbbbbbbbbbbbbbbb.a_id JOIN cccccccccccccccccccccccc ON bbbbbbbbbbbbbbbbbbbbbbbb.id = cccccccccccccccccccccccc.b_id JOIN dddddddddddddddddddddddd ON cccccccccccccccccccccccc.id = dddddddddddddddddddddddd.c_id",
      "expected": null
    },
    {
      "sql": "SELECT /*+ USE_NL(bbbbbbbbbbbbbbbbbbbbbbbb) LEADING(aaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbbbbb cccccccccccccccccccccccc dddddddddddddddddddddddd) INDEX(cccccccccccccccccccccccc) */ * FROM aaaaaaaaaaaaaaaaaaaaaaaa JOIN bbbbbbbbbbbbbbbbbbbbbbbb ON aaaaaaaaaaaaaaaaaaaaaaaa.id = bbbbbbbbbbbbbbbbbbbbbbbb.a_id JOIN cccccccccccccccccccccccc ON bbbbbbbbbbbbbbbbbbbbbbbb.id = cccccccccccccccccccccccc.b_id JOIN dddddddddddddddddddddddd ON cccccccccccccccccccccccc.id = dddddddddddddddddddddddd.c_id",
      "expected": "SELECT /*+ USE_NL(bbbbbbbbbbbbbbbbbbbbbbbb)\n  LEADING(\n    aaaaaaaaaaaaaaaaaaaaaaaa\n    bbbbbbbbbbbbbbbbbbbbbbbb\n    cccccccccccccccccccccccc\n    dddddddddddddddddddddddd\n  )\n  INDEX(cccccccccccccccccccccccc) */\n  *\nFROM aaaaaaaaaaaaaaaaaaaaaaaa\nJOIN bbbbbbbbbbbbbbbbbbbbbbbb\n  ON aaaaaaaaaaaaaaaaaaaaaaaa.id = bbbbbbbbbbbbbbbbbbbbbbbb.a_id\nJOIN cccccccccccccccccccccccc\n  ON bbbbbbbbbbbbbbbbbbbbbbbb.id = cccccccccccccccccccccccc.b_id\nJOIN dddddddddddddddddddddddd\n  ON cccccccccccccccccccccccc.id = dddddddddddddddddddddddd.c_id"
    },
    {
      "sql": "SELECT /*+ LEADING(departments employees) USE_NL(employees) select where group by is order by */ * FROM employees JOIN departments ON employees.department_id = departments.department_id",
      "expected": "SELECT /*+ LEADING(departments employees) USE_NL(employees) select where group by is order by */\n  *\nFROM employees\nJOIN departments\n  ON employees.department_id = departments.department_id"
    },
    {
      "sql": "SELECT /*+ LEADING(departments, employees) */ * FROM employees JOIN departments ON employees.department_id = departments.department_id",
      "expected": null
    },
    {
      "sql": "SELECT /*+ LEADING(departments select) */ * FROM employees JOIN departments ON employees.department_id = departments.department_id",
      "expected": null
    },
    {
      "sql": "XMLTABLE('x')",
      "expected": null
    },
    {
      "sql": "XMLTABLE('x' RETURNING SEQUENCE BY REF)",
      "expected": null
    },
    {
      "sql": "XMLTABLE('x' PASSING y)",
      "expected": null
    },
    {
      "sql": "XMLTABLE('x' PASSING y RETURNING SEQUENCE BY REF)",
      "expected": null
    },
    {
      "sql": "XMLTABLE('x' RETURNING SEQUENCE BY REF COLUMNS a VARCHAR2, b FLOAT)",
      "expected": null
    },
    {
      "sql": "SELECT x.* FROM example t, XMLTABLE(XMLNAMESPACES(DEFAULT 'http://example.com/default', 'http://example.com/ns1' AS \"ns1\"), '/root/data' PASSING t.xml COLUMNS id NUMBER PATH '@id', value VARCHAR2(100) PATH 'ns1:value/text()') x",
      "expected": null
    },
    {
      "sql": "SELECT\n  *\nFROM sales_history\nMATCH_RECOGNIZE (\n  PARTITION BY product\n  ORDER BY\n    tstamp\n  MEASURES\n    STRT.tstamp AS start_tstamp,\n    LAST(UP.tstamp) AS peak_tstamp,\n    LAST(DOWN.tstamp) AS end_tstamp,\n    MATCH_NUMBER() AS mno\n  ONE ROW PER MATCH\n  AFTER MATCH SKIP TO LAST DOWN\n  PATTERN (STRT UP+ FLAT* DOWN+)\n  DEFINE\n    UP AS UP.units_sold > PREV(UP.units_sold),\n    FLAT AS FLAT.units_sold = PREV(FLAT.units_sold),\n    DOWN AS DOWN.units_sold < PREV(DOWN.units_sold)\n) MR",
      "expected": null
    },
    {
      "sql": "SELECT * FROM JSON_TABLE(foo FORMAT JSON, 'bla' ERROR ON ERROR NULL ON EMPTY COLUMNS(foo PATH 'bar'))",
      "expected": null
    },
    {
      "sql": "SELECT * FROM JSON_TABLE(foo FORMAT JSON, 'bla' ERROR ON ERROR NULL ON EMPTY COLUMNS foo PATH 'bar')",
      "expected": "SELECT * FROM JSON_TABLE(foo FORMAT JSON, 'bla' ERROR ON ERROR NULL ON EMPTY COLUMNS(foo PATH 'bar'))"
    },
    {
      "sql": "SELECT\n  CASE WHEN DBMS_LOB.GETLENGTH(info) < 32000 THEN DBMS_LOB.SUBSTR(info) END AS info_txt,\n  info AS info_clob\nFROM schemaname.tablename ar\nINNER JOIN JSON_TABLE(:emps, '$[*]' COLUMNS(empno NUMBER PATH '$')) jt\n  ON ar.empno = jt.empno",
      "expected": null
    },
    {
      "sql": "SELECT\n  *\nFROM JSON_TABLE(res, '$.info[*]' COLUMNS(\n  tempid NUMBER PATH '$.tempid',\n  NESTED PATH '$.calid[*]' COLUMNS(last_dt PATH '$.last_dt ')\n)) src",
      "expected": null
    },
    {
      "sql": "CONVERT('foo', 'dst')",
      "expected": null
    },
    {
      "sql": "CONVERT('foo', 'dst', 'src')",
      "expected": null
    },
    {
      "sql": "INSERT ALL INTO dest_tab1 (id, description) VALUES (id, description) INTO dest_tab2 (id, description) VALUES (id, description) INTO dest_tab3 (id, description) VALUES (id, description) SELECT id, description FROM source_tab",
      "expected": null
    },
    {
      "sql": "INSERT ALL INTO pivot_dest (id, day, val) VALUES (id, 'mon', mon_val) INTO pivot_dest (id, day, val) VALUES (id, 'tue', tue_val) INTO pivot_dest (id, day, val) VALUES (id, 'wed', wed_val) INTO pivot_dest (id, day, val) VALUES (id, 'thu', thu_val) INTO pivot_dest (id, day, val) VALUES (id, 'fri', fri_val) SELECT * FROM pivot_source",
      "expected": null
    },
    {
      "sql": "INSERT ALL WHEN id <= 3 THEN INTO dest_tab1 (id, description) VALUES (id, description) WHEN id BETWEEN 4 AND 7 THEN INTO dest_tab2 (id, description) VALUES (id, description) WHEN id >= 8 THEN INTO dest_tab3 (id, description) VALUES (id, description) SELECT id, description FROM source_tab",
      "expected": null
    },
    {
      "sql": "INSERT ALL WHEN id <= 3 THEN INTO dest_tab1 (id, description) VALUES (id, description) WHEN id BETWEEN 4 AND 7 THEN INTO dest_tab2 (id, description) VALUES (id, description) WHEN 1 = 1 THEN INTO dest_tab3 (id, description) VALUES (id, description) SELECT id, description FROM source_tab",
      "expected": null
    },
    {
      "sql": "INSERT FIRST WHEN id <= 3 THEN INTO dest_tab1 (id, description) VALUES (id, description) WHEN id <= 5 THEN INTO dest_tab2 (id, description) VALUES (id, description) ELSE INTO dest_tab3 (id, description) VALUES (id, description) SELECT id, description FROM source_tab",
      "expected": null
    },
    {
      "sql": "INSERT FIRST WHEN id <= 3 THEN INTO dest_tab1 (id, description) VALUES (id, description) ELSE INTO dest_tab2 (id, description) VALUES (id, description) INTO dest_tab3 (id, description) VALUES (id, description) SELECT id, description FROM source_tab",
      "expected": null
    },
    {
      "sql": "/* COMMENT */ INSERT FIRST WHEN salary > 4000 THEN INTO emp2 WHEN salary > 5000 THEN INTO emp3 WHEN salary > 6000 THEN INTO emp4 SELECT salary FROM employees",
      "expected": null
    },
    {
      "sql": "GRANT SELECT ON TABLE t TO maria, harry",
      "expected": null
    },
    {
      "sql": "GRANT SELECT ON TABLE s.v TO PUBLIC",
      "expected": null
    },
    {
      "sql": "GRANT SELECT ON TABLE t TO purchases_reader_role",
      "expected": null
    },
    {
      "sql": "GRANT UPDATE, TRIGGER ON TABLE t TO anita, zhi",
      "expected": null
    },
    {
      "sql": "GRANT EXECUTE ON PROCEDURE p TO george",
      "expected": null
    },
    {
      "sql": "GRANT USAGE ON SEQUENCE order_id TO sales_role",
      "expected": null
    },
    {
      "sql": "REVOKE SELECT ON TABLE t FROM maria, harry",
      "expected": null
    },
    {
      "sql": "REVOKE SELECT ON TABLE s.v FROM PUBLIC",
      "expected": null
    },
    {
      "sql": "REVOKE SELECT ON TABLE t FROM purchases_reader_role",
      "expected": null
    },
    {
      "sql": "REVOKE UPDATE, TRIGGER ON TABLE t FROM anita, zhi",
      "expected": null
    },
    {
      "sql": "REVOKE EXECUTE ON PROCEDURE p FROM george",
      "expected": null
    },
    {
      "sql": "REVOKE USAGE ON SEQUENCE order_id FROM sales_role",
      "expected": null
    },
    {
      "sql": "ANALYZE TABLE tbl",
      "expected": null
    },
    {
      "sql": "ANALYZE INDEX ndx",
      "expected": null
    },
    {
      "sql": "ANALYZE TABLE db.tbl PARTITION(foo = 'foo', bar = 'bar')",
      "expected": null
    },
    {
      "sql": "ANALYZE TABLE db.tbl SUBPARTITION(foo = 'foo', bar = 'bar')",
      "expected": null
    },
    {
      "sql": "ANALYZE INDEX db.ndx PARTITION(foo = 'foo', bar = 'bar')",
      "expected": null
    },
    {
      "sql": "ANALYZE INDEX db.ndx PARTITION(part1)",
      "expected": null
    },
    {
      "sql": "ANALYZE CLUSTER db.cluster",
      "expected": null
    },
    {
      "sql": "ANALYZE TABLE tbl VALIDATE REF UPDATE",
      "expected": null
    },
    {
      "sql": "ANALYZE LIST CHAINED ROWS",
      "expected": null
    },
    {
      "sql": "ANALYZE LIST CHAINED ROWS INTO tbl",
      "expected": null
    },
    {
      "sql": "ANALYZE DELETE STATISTICS",
      "expected": null
    },
    {
      "sql": "ANALYZE DELETE SYSTEM STATISTICS",
      "expected": null
    },
    {
      "sql": "ANALYZE VALIDATE REF UPDATE",
      "expected": null
    },
    {
      "sql": "ANALYZE VALIDATE REF UPDATE SET DANGLING TO NULL",
      "expected": null
    },
    {
      "sql": "ANALYZE VALIDATE STRUCTURE",
      "expected": null
    },
    {
      "sql": "ANALYZE VALIDATE STRUCTURE CASCADE FAST",
      "expected": null
    },
    {
      "sql": "ANALYZE TABLE tbl VALIDATE STRUCTURE CASCADE COMPLETE ONLINE INTO db.tbl",
      "expected": null
    },
    {
      "sql": "ANALYZE TABLE tbl VALIDATE STRUCTURE CASCADE COMPLETE OFFLINE INTO db.tbl",
      "expected": null
    },
    {
      "sql": "SELECT id, PRIOR name AS parent_name, name FROM tree CONNECT BY NOCYCLE PRIOR id = parent_id",
      "expected": null
    },
    {
      "sql": "WITH t AS (SELECT 1 AS COL) SELECT col, ROWID FROM t WHERE ROWNUM = 1",
      "expected": null
    },
    {
      "sql": "SELECT CHR(187 USING NCHAR_CS)",
      "expected": null
    },
    {
      "sql": "SELECT CHR(187)",
      "expected": null
    },
    {
      "sql": "DBMS_RANDOM.VALUE(low, high)",
      "expected": null
    },
    {
      "sql": "DBMS_RANDOM.VALUE()",
      "expected": null
    },
    {
      "sql": "SYSTIMESTAMP",
      "expected": null
    },
    {
      "sql": "UTC_TIME()",
      "expected": null
    },
    {
      "sql": "UTC_TIME(6)",
      "expected": null
    },
    {
      "sql": "UTC_TIMESTAMP()",
      "expected": null
    },
    {
      "sql": "UTC_TIMESTAMP(6)",
      "expected": null
    }
  ],
  "transpilation": [
    {
      "sql": "SELECT CONNECT_BY_ROOT x y",
      "read": {},
      "write": {
        "oracle": "SELECT CONNECT_BY_ROOT x AS y"
      }
    },
    {
      "sql": "SELECT DBMS_RANDOM.VALUE()",
      "read": {
        "oracle": "SELECT DBMS_RANDOM.VALUE",
        "postgres": "SELECT RANDOM()"
      },
      "write": {
        "oracle": "SELECT DBMS_RANDOM.VALUE()",
        "postgres": "SELECT RANDOM()"
      }
    },
    {
      "sql": "SELECT TRIM('|' FROM '||Hello ||| world||')",
      "read": {},
      "write": {
        "clickhouse": "SELECT TRIM(BOTH '|' FROM '||Hello ||| world||')",
        "oracle": "SELECT TRIM('|' FROM '||Hello ||| world||')"
      }
    },
    {
      "sql": "SELECT department_id, department_name INTO v_department_id, v_department_name FROM departments FETCH FIRST 1 ROWS ONLY",
      "read": {},
      "write": {
        "oracle": "SELECT department_id, department_name INTO v_department_id, v_department_name FROM departments FETCH FIRST 1 ROWS ONLY"
      }
    },
    {
      "sql": "SELECT * FROM test WHERE MOD(col1, 4) = 3",
      "read": {
        "duckdb": "SELECT * FROM test WHERE col1 % 4 = 3"
      },
      "write": {
        "duckdb": "SELECT * FROM test WHERE col1 % 4 = 3",
        "oracle": "SELECT * FROM test WHERE MOD(col1, 4) = 3"
      }
    },
    {
      "sql": "CURRENT_TIMESTAMP BETWEEN TO_DATE(f.C_SDATE, 'YYYY/MM/DD') AND TO_DATE(f.C_EDATE, 'YYYY/MM/DD')",
      "read": {
        "postgres": "CURRENT_TIMESTAMP BETWEEN TO_DATE(f.C_SDATE, 'yyyy/mm/dd') AND TO_DATE(f.C_EDATE, 'yyyy/mm/dd')"
      },
      "write": {
        "oracle": "CURRENT_TIMESTAMP BETWEEN TO_DATE(f.C_SDATE, 'YYYY/MM/DD') AND TO_DATE(f.C_EDATE, 'YYYY/MM/DD')",
        "postgres": "CURRENT_TIMESTAMP BETWEEN TO_DATE(f.C_SDATE, 'YYYY/MM/DD') AND TO_DATE(f.C_EDATE, 'YYYY/MM/DD')"
      }
    },
    {
      "sql": "TO_CHAR(x)",
      "read": {},
      "write": {
        "doris": "CAST(x AS STRING)",
        "oracle": "TO_CHAR(x)"
      }
    },
    {
      "sql": "TO_NUMBER(expr, fmt, nlsparam)",
      "read": {
        "teradata": "TO_NUMBER(expr, fmt, nlsparam)"
      },
      "write": {
        "oracle": "TO_NUMBER(expr, fmt, nlsparam)",
        "teradata": "TO_NUMBER(expr, fmt, nlsparam)"
      }
    },
    {
      "sql": "TO_NUMBER(x)",
      "read": {},
      "write": {
        "bigquery": "CAST(x AS FLOAT64)",
        "doris": "CAST(x AS DOUBLE)",
        "drill": "CAST(x AS DOUBLE)",
        "duckdb": "CAST(x AS DOUBLE)",
        "hive": "CAST(x AS DOUBLE)",
        "mysql": "CAST(x AS DOUBLE)",
        "oracle": "TO_NUMBER(x)",
        "postgres": "CAST(x AS DOUBLE PRECISION)",
        "presto": "CAST(x AS DOUBLE)",
        "redshift": "CAST(x AS DOUBLE PRECISION)",
        "snowflake": "TO_NUMBER(x)",
        "spark": "CAST(x AS DOUBLE)",
        "spark2": "CAST(x AS DOUBLE)",
        "starrocks": "CAST(x AS DOUBLE)",
        "tableau": "CAST(x AS DOUBLE)",
        "teradata": "TO_NUMBER(x)"
      }
    },
    {
      "sql": "TO_NUMBER(x, fmt)",
      "read": {
        "databricks": "TO_NUMBER(x, fmt)",
        "drill": "TO_NUMBER(x, fmt)",
        "postgres": "TO_NUMBER(x, fmt)",
        "snowflake": "TO_NUMBER(x, fmt)",
        "spark": "TO_NUMBER(x, fmt)",
        "redshift": "TO_NUMBER(x, fmt)",
        "teradata": "TO_NUMBER(x, fmt)"
      },
      "write": {
        "databricks": "TO_NUMBER(x, fmt)",
        "drill": "TO_NUMBER(x, fmt)",
        "oracle": "TO_NUMBER(x, fmt)",
        "postgres": "TO_NUMBER(x, fmt)",
        "snowflake": "TO_NUMBER(x, fmt)",
        "spark": "TO_NUMBER(x, fmt)",
        "redshift": "TO_NUMBER(x, fmt)",
        "teradata": "TO_NUMBER(x, fmt)"
      }
    },
    {
      "sql": "SELECT CAST(NULL AS VARCHAR2(2328 CHAR)) AS COL1",
      "read": {},
      "write": {
        "oracle": "SELECT CAST(NULL AS VARCHAR2(2328 CHAR)) AS COL1",
        "spark": "SELECT CAST(NULL AS VARCHAR(2328)) AS COL1"
      }
    },
    {
      "sql": "SELECT CAST(NULL AS VARCHAR2(2328 BYTE)) AS COL1",
      "read": {},
      "write": {
        "oracle": "SELECT CAST(NULL AS VARCHAR2(2328 BYTE)) AS COL1",
        "spark": "SELECT CAST(NULL AS VARCHAR(2328)) AS COL1"
      }
    },
    {
      "sql": "DATE '2022-01-01'",
      "read": {},
      "write": {
        "mysql": "CAST('2022-01-01' AS DATE)",
        "oracle": "TO_DATE('2022-01-01', 'YYYY-MM-DD')",
        "postgres": "CAST('2022-01-01' AS DATE)"
      }
    },
    {
      "sql": "x::binary_double",
      "read": {},
      "write": {
        "oracle": "CAST(x AS DOUBLE PRECISION)"
      }
    },
    {
      "sql": "x::binary_float",
      "read": {},
      "write": {
        "oracle": "CAST(x AS FLOAT)"
      }
    },
    {
      "sql": "CAST(x AS sch.udt)",
      "read": {
        "postgres": "CAST(x AS sch.udt)"
      },
      "write": {
        "oracle": "CAST(x AS sch.udt)",
        "postgres": "CAST(x AS sch.udt)"
      }
    },
    {
      "sql": "SELECT TO_TIMESTAMP('2024-12-12 12:12:12.000000', 'YYYY-MM-DD HH24:MI:SS.FF6')",
      "read": {},
      "write": {
        "oracle": "SELECT TO_TIMESTAMP('2024-12-12 12:12:12.000000', 'YYYY-MM-DD HH24:MI:SS.FF6')",
        "duckdb": "SELECT STRPTIME('2024-12-12 12:12:12.000000', '%Y-%m-%d %H:%M:%S.%f')"
      }
    },
    {
      "sql": "SELECT TO_DATE('2024-12-12', 'YYYY-MM-DD')",
      "read": {},
      "write": {
        "oracle": "SELECT TO_DATE('2024-12-12', 'YYYY-MM-DD')",
        "duckdb": "SELECT CAST(STRPTIME('2024-12-12', '%Y-%m-%d') AS DATE)"
      }
    },
    {
      "sql": "NVL(NULL, 1)",
      "read": {},
      "write": {
        "oracle": "NVL(NULL, 1)",
        "clickhouse": "COALESCE(NULL, 1)"
      }
    },
    {
      "sql": "TRIM(BOTH 'h' FROM 'Hello World')",
      "read": {},
      "write": {
        "oracle": "TRIM(BOTH 'h' FROM 'Hello World')",
        "clickhouse": "TRIM(BOTH 'h' FROM 'Hello World')"
      }
    },
    {
      "sql": "SELECT * FROM t FETCH FIRST 10 ROWS ONLY",
      "read": {},
      "write": {
        "oracle": "SELECT * FROM t FETCH FIRST 10 ROWS ONLY",
        "tsql": "SELECT * FROM t ORDER BY (SELECT NULL) OFFSET 0 ROWS FETCH FIRST 10 ROWS ONLY"
      }
    },
    {
      "sql": "SELECT e1.x, e2.x FROM e e1, e e2 WHERE e1.y = e2.y (+)",
      "read": {},
      "write": {
        "oracle": "SELECT e1.x, e2.x FROM e e1, e e2 WHERE e1.y = e2.y (+)"
      }
    },
    {
      "sql": "SELECT warehouse_name warehouse,\n   warehouse2.\"Water\", warehouse2.\"Rail\"\n   FROM warehouses,\n   XMLTABLE('/Warehouse'\n      PASSING warehouses.warehouse_spec\n      COLUMNS\n         \"Water\" varchar2(6) PATH 'WaterAccess',\n         \"Rail\" varchar2(6) PATH 'RailAccess')\n      warehouse2",
      "read": {},
      "write": {
        "oracle": "SELECT\n  warehouse_name AS warehouse,\n  warehouse2.\"Water\",\n  warehouse2.\"Rail\"\nFROM warehouses, XMLTABLE(\n  '/Warehouse'\n  PASSING\n    warehouses.warehouse_spec\n  COLUMNS\n    \"Water\" VARCHAR2(6) PATH 'WaterAccess',\n    \"Rail\" VARCHAR2(6) PATH 'RailAccess'\n) warehouse2"
      }
    },
    {
      "sql": "SELECT table_name, column_name, data_default FROM xmltable('ROWSET/ROW'\n    passing dbms_xmlgen.getxmltype('SELECT table_name, column_name, data_default FROM user_tab_columns')\n    columns table_name      VARCHAR2(128)   PATH '*[1]'\n            , column_name   VARCHAR2(128)   PATH '*[2]'\n            , data_default  VARCHAR2(2000)  PATH '*[3]'\n            );",
      "read": {},
      "write": {
        "oracle": "SELECT\n  table_name,\n  column_name,\n  data_default\nFROM XMLTABLE(\n  'ROWSET/ROW'\n  PASSING\n    dbms_xmlgen.getxmltype('SELECT table_name, column_name, data_default FROM user_tab_columns')\n  COLUMNS\n    table_name VARCHAR2(128) PATH '*[1]',\n    column_name VARCHAR2(128) PATH '*[2]',\n    data_default VARCHAR2(2000) PATH '*[3]'\n)"
      }
    },
    {
      "sql": "TRUNC(SYSDATE, 'YEAR')",
      "read": {},
      "write": {
        "clickhouse": "DATE_TRUNC('YEAR', CURRENT_TIMESTAMP())",
        "oracle": "TRUNC(SYSDATE, 'YEAR')"
      }
    }
  ]
}