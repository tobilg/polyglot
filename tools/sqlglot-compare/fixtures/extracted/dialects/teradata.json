{
  "dialect": "teradata",
  "identity": [
    {
      "sql": "TO_NUMBER(expr, fmt, nlsparam)",
      "expected": null
    },
    {
      "sql": "SELECT TOP 10 * FROM tbl",
      "expected": null
    },
    {
      "sql": "SELECT * FROM tbl SAMPLE 5",
      "expected": null
    },
    {
      "sql": "SELECT * FROM tbl SAMPLE 0.33, .25, .1",
      "expected": "SELECT * FROM tbl SAMPLE 0.33, 0.25, 0.1"
    },
    {
      "sql": "SELECT 0x1d",
      "expected": "SELECT X'1d'"
    },
    {
      "sql": "SELECT X'1D'",
      "expected": "SELECT X'1D'"
    },
    {
      "sql": "SELECT x'1d'",
      "expected": "SELECT X'1d'"
    },
    {
      "sql": "TRANSLATE(x USING LATIN_TO_UNICODE)",
      "expected": null
    },
    {
      "sql": "TRANSLATE(x USING LATIN_TO_UNICODE WITH ERROR)",
      "expected": null
    },
    {
      "sql": "LOCKING ROW FOR ACCESS SELECT * FROM table1",
      "expected": null
    },
    {
      "sql": "LOCKING TABLE table1 FOR ACCESS SELECT col1, col2 FROM table1",
      "expected": null
    },
    {
      "sql": "LOCKING ROW FOR SHARE SELECT * FROM table1",
      "expected": null
    },
    {
      "sql": "LOCKING DATABASE db1 FOR READ SELECT * FROM table1",
      "expected": null
    },
    {
      "sql": "LOCKING ROW FOR EXCLUSIVE SELECT * FROM table1",
      "expected": null
    },
    {
      "sql": "LOCKING VIEW view1 FOR ACCESS SELECT * FROM view1",
      "expected": null
    },
    {
      "sql": "LOCKING ROW FOR ACCESS SELECT col1, col2 FROM table1 WHERE col1 > 10",
      "expected": null
    },
    {
      "sql": "LOCKING TABLE table1 FOR ACCESS SELECT * FROM table1 JOIN table2 ON table1.id = table2.id",
      "expected": null
    },
    {
      "sql": "CREATE VIEW view_b AS LOCKING ROW FOR ACCESS SELECT COL1, COL2 FROM table_b",
      "expected": null
    },
    {
      "sql": "COLLECT STATISTICS ON tbl INDEX(col)",
      "expected": null
    },
    {
      "sql": "COLLECT STATS ON tbl COLUMNS(col)",
      "expected": null
    },
    {
      "sql": "COLLECT STATS COLUMNS(col) ON tbl",
      "expected": null
    },
    {
      "sql": "HELP STATISTICS personel.employee",
      "expected": null
    },
    {
      "sql": "HELP STATISTICS personnel.employee FROM my_qcd",
      "expected": null
    },
    {
      "sql": "REPLACE VIEW view_b (COL1, COL2) AS LOCKING ROW FOR ACCESS SELECT COL1, COL2 FROM table_b",
      "expected": "CREATE OR REPLACE VIEW view_b (COL1, COL2) AS LOCKING ROW FOR ACCESS SELECT COL1, COL2 FROM table_b"
    },
    {
      "sql": "REPLACE VIEW view_b (COL1, COL2) AS LOCKING ROW FOR ACCESS SELECT COL1, COL2 FROM table_b",
      "expected": "CREATE OR REPLACE VIEW view_b (COL1, COL2) AS LOCKING ROW FOR ACCESS SELECT COL1, COL2 FROM table_b"
    },
    {
      "sql": "CREATE TABLE x (y INT) PRIMARY INDEX (y) PARTITION BY y INDEX (y)",
      "expected": null
    },
    {
      "sql": "CREATE TABLE x (y INT) PARTITION BY y INDEX (y)",
      "expected": null
    },
    {
      "sql": "CREATE MULTISET VOLATILE TABLE my_table (id INT) PRIMARY INDEX (id) ON COMMIT PRESERVE ROWS",
      "expected": null
    },
    {
      "sql": "CREATE SET VOLATILE TABLE my_table (id INT) PRIMARY INDEX (id) ON COMMIT DELETE ROWS",
      "expected": null
    },
    {
      "sql": "CREATE TABLE a (b INT) PRIMARY INDEX (y) PARTITION BY RANGE_N(b BETWEEN 'a', 'b' AND 'c' EACH '1')",
      "expected": null
    },
    {
      "sql": "CREATE TABLE a (b INT) PARTITION BY RANGE_N(b BETWEEN 0, 1 AND 2 EACH 1)",
      "expected": null
    },
    {
      "sql": "CREATE TABLE a (b INT) PARTITION BY RANGE_N(b BETWEEN *, 1 AND * EACH b) INDEX (a)",
      "expected": null
    },
    {
      "sql": "CREATE TABLE a, NO FALLBACK PROTECTION, NO LOG, NO JOURNAL, CHECKSUM=ON, NO MERGEBLOCKRATIO, BLOCKCOMPRESSION=ALWAYS (a INT)",
      "expected": null
    },
    {
      "sql": "CREATE TABLE a, NO FALLBACK PROTECTION, NO LOG, NO JOURNAL, CHECKSUM=ON, NO MERGEBLOCKRATIO, BLOCKCOMPRESSION=ALWAYS (a INT)",
      "expected": null
    },
    {
      "sql": "CREATE TABLE a, WITH JOURNAL TABLE=x.y.z, CHECKSUM=OFF, MERGEBLOCKRATIO=1, DATABLOCKSIZE=10 KBYTES (a INT)",
      "expected": null
    },
    {
      "sql": "CREATE TABLE a, BEFORE JOURNAL, AFTER JOURNAL, FREESPACE=1, DEFAULT DATABLOCKSIZE, BLOCKCOMPRESSION=DEFAULT (a INT)",
      "expected": null
    },
    {
      "sql": "CREATE TABLE a, DUAL JOURNAL, DUAL AFTER JOURNAL, MERGEBLOCKRATIO=1 PERCENT, DATABLOCKSIZE=10 KILOBYTES (a INT)",
      "expected": null
    },
    {
      "sql": "CREATE TABLE a, DUAL BEFORE JOURNAL, LOCAL AFTER JOURNAL, MAXIMUM DATABLOCKSIZE, BLOCKCOMPRESSION=AUTOTEMP(c1 INT) (a INT)",
      "expected": null
    },
    {
      "sql": "CREATE VOLATILE MULTISET TABLE a, NOT LOCAL AFTER JOURNAL, FREESPACE=1 PERCENT, DATABLOCKSIZE=10 BYTES, WITH NO CONCURRENT ISOLATED LOADING FOR ALL (a INT)",
      "expected": null
    },
    {
      "sql": "CREATE VOLATILE SET TABLE example1 AS (SELECT col1, col2, col3 FROM table1) WITH DATA PRIMARY INDEX (col1) ON COMMIT PRESERVE ROWS",
      "expected": null
    },
    {
      "sql": "CREATE SET GLOBAL TEMPORARY TABLE a, NO BEFORE JOURNAL, NO AFTER JOURNAL, MINIMUM DATABLOCKSIZE, BLOCKCOMPRESSION=NEVER (a INT)",
      "expected": null
    },
    {
      "sql": "CREATE TABLE db.foo (id INT NOT NULL, valid_date DATE FORMAT 'YYYY-MM-DD', measurement INT COMPRESS)",
      "expected": null
    },
    {
      "sql": "CREATE TABLE db.foo (id INT NOT NULL, valid_date DATE FORMAT 'YYYY-MM-DD', measurement INT COMPRESS (1, 2, 3))",
      "expected": null
    },
    {
      "sql": "CREATE TABLE db.foo (id INT NOT NULL, valid_date DATE FORMAT 'YYYY-MM-DD' COMPRESS (CAST('9999-09-09' AS DATE)), measurement INT)",
      "expected": null
    },
    {
      "sql": "a LT b",
      "expected": "a < b"
    },
    {
      "sql": "a LE b",
      "expected": "a <= b"
    },
    {
      "sql": "a GT b",
      "expected": "a > b"
    },
    {
      "sql": "a GE b",
      "expected": "a >= b"
    },
    {
      "sql": "a ^= b",
      "expected": "a <> b"
    },
    {
      "sql": "a NE b",
      "expected": "a <> b"
    },
    {
      "sql": "a NOT= b",
      "expected": "a <> b"
    },
    {
      "sql": "a EQ b",
      "expected": "a = b"
    },
    {
      "sql": "SEL a FROM b",
      "expected": "SELECT a FROM b"
    },
    {
      "sql": "SELECT col1, col2 FROM dbc.table1 WHERE col1 EQ 'value1' MINUS SELECT col1, col2 FROM dbc.table2",
      "expected": "SELECT col1, col2 FROM dbc.table1 WHERE col1 = 'value1' EXCEPT SELECT col1, col2 FROM dbc.table2"
    },
    {
      "sql": "UPD a SET b = 1",
      "expected": "UPDATE a SET b = 1"
    },
    {
      "sql": "DEL FROM a",
      "expected": "DELETE FROM a"
    },
    {
      "sql": "CREATE TABLE z (a SYSUDTLIB.INT)",
      "expected": null
    },
    {
      "sql": "CAST('1992-01' AS FORMAT 'YYYY-DD')",
      "expected": null
    },
    {
      "sql": "SELECT ('a' || 'b') (FORMAT '...')",
      "expected": null
    },
    {
      "sql": "SELECT Col1 (FORMAT '+9999') FROM Test1",
      "expected": null
    },
    {
      "sql": "SELECT date_col (FORMAT 'YYYY-MM-DD') FROM t",
      "expected": null
    },
    {
      "sql": "SELECT CAST(Col1 AS INTEGER) FROM Test1",
      "expected": "SELECT CAST(Col1 AS INT) FROM Test1"
    },
    {
      "sql": "CAST(CURRENT_TIMESTAMP(6) AS TIMESTAMP WITH TIME ZONE)",
      "expected": null
    },
    {
      "sql": "SET QUERY_BAND = 'app=myapp;' FOR SESSION",
      "expected": null
    },
    {
      "sql": "SET QUERY_BAND = 'app=myapp;user=john;' FOR TRANSACTION",
      "expected": null
    },
    {
      "sql": "SET QUERY_BAND = 'priority=high;' UPDATE FOR SESSION",
      "expected": null
    },
    {
      "sql": "SET QUERY_BAND = 'workload=batch;' UPDATE FOR TRANSACTION",
      "expected": null
    },
    {
      "sql": "SET QUERY_BAND = 'org=Finance;report=Fin123;' FOR SESSION",
      "expected": null
    },
    {
      "sql": "SET QUERY_BAND = NONE FOR SESSION",
      "expected": null
    },
    {
      "sql": "SET QUERY_BAND = NONE FOR SESSION VOLATILE",
      "expected": null
    },
    {
      "sql": "SET QUERY_BAND = 'priority=high;' UPDATE FOR SESSION VOLATILE",
      "expected": null
    },
    {
      "sql": "SET QUERY_BAND = 'NONE' FOR SESSION",
      "expected": null
    },
    {
      "sql": "SET QUERY_BAND = '' FOR SESSION",
      "expected": null
    },
    {
      "sql": "RENAME TABLE emp TO employee",
      "expected": null
    }
  ],
  "transpilation": [
    {
      "sql": "RANDOM(l, u)",
      "read": {},
      "write": {
        "teradata": "RANDOM(l, u)"
      }
    },
    {
      "sql": "DATABASE tduser",
      "read": {
        "databricks": "USE tduser"
      },
      "write": {
        "databricks": "USE tduser",
        "teradata": "DATABASE tduser"
      }
    },
    {
      "sql": "UPDATE A FROM schema.tableA AS A, (SELECT col1 FROM schema.tableA GROUP BY col1) AS B SET col2 = '' WHERE A.col1 = B.col1",
      "read": {},
      "write": {
        "teradata": "UPDATE A FROM schema.tableA AS A, (SELECT col1 FROM schema.tableA GROUP BY col1) AS B SET col2 = '' WHERE A.col1 = B.col1",
        "mysql": "UPDATE A JOIN `schema`.tableA AS A ON TRUE JOIN (SELECT col1 FROM `schema`.tableA GROUP BY col1) AS B ON TRUE SET A.col2 = '' WHERE A.col1 = B.col1"
      }
    },
    {
      "sql": "\n            CREATE SET TABLE test, NO FALLBACK, NO BEFORE JOURNAL, NO AFTER JOURNAL,\n            CHECKSUM = DEFAULT (x INT, y INT, z CHAR(30), a INT, b DATE, e INT)\n            PRIMARY INDEX (a),\n            INDEX(x, y)\n            ",
      "read": {},
      "write": {
        "teradata": "CREATE SET TABLE test, NO FALLBACK, NO BEFORE JOURNAL, NO AFTER JOURNAL, CHECKSUM=DEFAULT (x INT, y INT, z CHAR(30), a INT, b DATE, e INT) PRIMARY INDEX (a) INDEX (x, y)"
      }
    },
    {
      "sql": "REPLACE VIEW a AS (SELECT b FROM c)",
      "read": {},
      "write": {
        "teradata": "CREATE OR REPLACE VIEW a AS (SELECT b FROM c)"
      }
    },
    {
      "sql": "CREATE VOLATILE TABLE a",
      "read": {},
      "write": {
        "teradata": "CREATE VOLATILE TABLE a",
        "bigquery": "CREATE TABLE a",
        "clickhouse": "CREATE TABLE a",
        "databricks": "CREATE TABLE a",
        "drill": "CREATE TABLE a",
        "duckdb": "CREATE TABLE a",
        "hive": "CREATE TABLE a",
        "mysql": "CREATE TABLE a",
        "oracle": "CREATE TABLE a",
        "postgres": "CREATE TABLE a",
        "presto": "CREATE TABLE a",
        "redshift": "CREATE TABLE a",
        "snowflake": "CREATE TABLE a",
        "spark": "CREATE TABLE a",
        "sqlite": "CREATE TABLE a",
        "starrocks": "CREATE TABLE a",
        "tableau": "CREATE TABLE a",
        "trino": "CREATE TABLE a",
        "tsql": "CREATE TABLE a"
      }
    },
    {
      "sql": "INS INTO x SELECT * FROM y",
      "read": {},
      "write": {
        "teradata": "INSERT INTO x SELECT * FROM y"
      }
    },
    {
      "sql": "a MOD b",
      "read": {},
      "write": {
        "teradata": "a MOD b",
        "mysql": "a % b"
      }
    },
    {
      "sql": "a ** b",
      "read": {},
      "write": {
        "teradata": "a ** b",
        "mysql": "POWER(a, b)"
      }
    },
    {
      "sql": "CREATE TABLE z (a ST_GEOMETRY(1))",
      "read": {},
      "write": {
        "teradata": "CREATE TABLE z (a ST_GEOMETRY(1))",
        "redshift": "CREATE TABLE z (a GEOMETRY(1))"
      }
    },
    {
      "sql": "CAST('1992-01' AS DATE FORMAT 'YYYY-DD')",
      "read": {
        "bigquery": "CAST('1992-01' AS DATE FORMAT 'YYYY-DD')"
      },
      "write": {
        "teradata": "CAST('1992-01' AS DATE FORMAT 'YYYY-DD')",
        "bigquery": "PARSE_DATE('%Y-%d', '1992-01')",
        "databricks": "TO_DATE('1992-01', 'yyyy-dd')",
        "mysql": "STR_TO_DATE('1992-01', '%Y-%d')",
        "spark": "TO_DATE('1992-01', 'yyyy-dd')"
      }
    },
    {
      "sql": "TRYCAST('-2.5' AS DECIMAL(5, 2))",
      "read": {
        "snowflake": "TRY_CAST('-2.5' AS DECIMAL(5, 2))"
      },
      "write": {
        "snowflake": "TRY_CAST('-2.5' AS DECIMAL(5, 2))",
        "teradata": "TRYCAST('-2.5' AS DECIMAL(5, 2))"
      }
    },
    {
      "sql": "CURRENT_TIMESTAMP",
      "read": {
        "teradata": "CURRENT_TIMESTAMP",
        "snowflake": "CURRENT_TIMESTAMP()"
      },
      "write": {}
    },
    {
      "sql": "SELECT '2023-01-01' + INTERVAL '5' YEAR",
      "read": {
        "teradata": "SELECT '2023-01-01' + INTERVAL '5' YEAR",
        "snowflake": "SELECT DATEADD(YEAR, 5, '2023-01-01')"
      },
      "write": {}
    },
    {
      "sql": "SELECT '2023-01-01' - INTERVAL '5' YEAR",
      "read": {
        "teradata": "SELECT '2023-01-01' - INTERVAL '5' YEAR",
        "snowflake": "SELECT DATEADD(YEAR, -5, '2023-01-01')"
      },
      "write": {}
    },
    {
      "sql": "SELECT '2023-01-01' - INTERVAL '5' YEAR",
      "read": {
        "teradata": "SELECT '2023-01-01' - INTERVAL '5' YEAR",
        "sqlite": "SELECT DATE_SUB('2023-01-01', 5, YEAR)"
      },
      "write": {}
    },
    {
      "sql": "SELECT '2023-01-01' + INTERVAL '5' YEAR",
      "read": {
        "teradata": "SELECT '2023-01-01' + INTERVAL '5' YEAR",
        "sqlite": "SELECT DATE_SUB('2023-01-01', -5, YEAR)"
      },
      "write": {}
    },
    {
      "sql": "SELECT (90 * INTERVAL '1' DAY)",
      "read": {
        "teradata": "SELECT (90 * INTERVAL '1' DAY)",
        "snowflake": "SELECT INTERVAL '1' QUARTER"
      },
      "write": {}
    },
    {
      "sql": "SELECT (7 * INTERVAL '1' DAY)",
      "read": {
        "teradata": "SELECT (7 * INTERVAL '1' DAY)",
        "snowflake": "SELECT INTERVAL '1' WEEK"
      },
      "write": {}
    },
    {
      "sql": "SELECT '2023-01-01' + (90 * INTERVAL '5' DAY)",
      "read": {
        "teradata": "SELECT '2023-01-01' + (90 * INTERVAL '5' DAY)",
        "snowflake": "SELECT DATEADD(QUARTER, 5, '2023-01-01')"
      },
      "write": {}
    },
    {
      "sql": "SELECT '2023-01-01' + (7 * INTERVAL '5' DAY)",
      "read": {
        "teradata": "SELECT '2023-01-01' + (7 * INTERVAL '5' DAY)",
        "snowflake": "SELECT DATEADD(WEEK, 5, '2023-01-01')"
      },
      "write": {}
    },
    {
      "sql": "CAST(TO_CHAR(x, 'Q') AS INT)",
      "read": {
        "teradata": "CAST(TO_CHAR(x, 'Q') AS INT)",
        "snowflake": "DATE_PART(QUARTER, x)",
        "bigquery": "EXTRACT(QUARTER FROM x)"
      },
      "write": {}
    },
    {
      "sql": "EXTRACT(MONTH FROM x)",
      "read": {
        "teradata": "EXTRACT(MONTH FROM x)",
        "snowflake": "DATE_PART(MONTH, x)",
        "bigquery": "EXTRACT(MONTH FROM x)"
      },
      "write": {}
    },
    {
      "sql": "CAST(TO_CHAR(x, 'Q') AS INT)",
      "read": {
        "snowflake": "quarter(x)",
        "teradata": "CAST(TO_CHAR(x, 'Q') AS INT)"
      },
      "write": {}
    }
  ]
}