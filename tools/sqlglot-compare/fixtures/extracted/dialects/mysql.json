{
  "dialect": "mysql",
  "identity": [
    {
      "sql": "CREATE TABLE bar (abacate DOUBLE(10, 2) UNSIGNED)",
      "expected": null
    },
    {
      "sql": "CREATE TABLE t (id DECIMAL(20, 4) UNSIGNED)",
      "expected": null
    },
    {
      "sql": "CREATE TABLE foo (a BIGINT, UNIQUE (b) USING BTREE)",
      "expected": null
    },
    {
      "sql": "CREATE TABLE foo (id BIGINT)",
      "expected": null
    },
    {
      "sql": "CREATE TABLE 00f (1d BIGINT)",
      "expected": null
    },
    {
      "sql": "CREATE TABLE temp (id SERIAL PRIMARY KEY)",
      "expected": null
    },
    {
      "sql": "UPDATE items SET items.price = 0 WHERE items.id >= 5 LIMIT 10",
      "expected": null
    },
    {
      "sql": "DELETE FROM t WHERE a <= 10 LIMIT 10",
      "expected": null
    },
    {
      "sql": "DELETE FROM t FORCE INDEX (idx) WHERE a > 5 ORDER BY id",
      "expected": null
    },
    {
      "sql": "CREATE TABLE foo (a BIGINT, INDEX USING BTREE (b))",
      "expected": null
    },
    {
      "sql": "CREATE TABLE foo (a BIGINT, FULLTEXT INDEX (b))",
      "expected": null
    },
    {
      "sql": "CREATE TABLE foo (a BIGINT, SPATIAL INDEX (b))",
      "expected": null
    },
    {
      "sql": "CREATE TABLE foo (a INT UNSIGNED ZEROFILL)",
      "expected": null
    },
    {
      "sql": "ALTER TABLE t1 ADD COLUMN x INT, ALGORITHM=INPLACE, LOCK=EXCLUSIVE",
      "expected": null
    },
    {
      "sql": "ALTER TABLE t ADD INDEX `i` (`c`)",
      "expected": null
    },
    {
      "sql": "ALTER TABLE t ADD UNIQUE `i` (`c`)",
      "expected": null
    },
    {
      "sql": "ALTER TABLE test_table MODIFY COLUMN test_column LONGTEXT",
      "expected": null
    },
    {
      "sql": "ALTER VIEW v AS SELECT a, b, c, d FROM foo",
      "expected": null
    },
    {
      "sql": "ALTER VIEW v AS SELECT * FROM foo WHERE c > 100",
      "expected": null
    },
    {
      "sql": "ALTER ALGORITHM = MERGE VIEW v AS SELECT * FROM foo",
      "expected": null
    },
    {
      "sql": "ALTER DEFINER = 'admin'@'localhost' VIEW v AS SELECT * FROM foo",
      "expected": null
    },
    {
      "sql": "CREATE SQL SECURITY INVOKER VIEW id_test (id, foo) AS SELECT 0, foo FROM test",
      "expected": null
    },
    {
      "sql": "CREATE SQL SECURITY DEFINER VIEW id_test (id, foo) AS SELECT 0, foo FROM test",
      "expected": null
    },
    {
      "sql": "ALTER SQL SECURITY = DEFINER VIEW v AS SELECT * FROM foo",
      "expected": null
    },
    {
      "sql": "INSERT INTO things (a, b) VALUES (1, 2) AS new_data ON DUPLICATE KEY UPDATE id = LAST_INSERT_ID(id), a = new_data.a, b = new_data.b",
      "expected": null
    },
    {
      "sql": "CREATE TABLE `oauth_consumer` (`key` VARCHAR(32) NOT NULL, UNIQUE `OAUTH_CONSUMER_KEY` (`key`))",
      "expected": null
    },
    {
      "sql": "CREATE TABLE `x` (`username` VARCHAR(200), PRIMARY KEY (`username`(16)))",
      "expected": null
    },
    {
      "sql": "UPDATE items SET items.price = 0 WHERE items.id >= 5 ORDER BY items.id LIMIT 10",
      "expected": null
    },
    {
      "sql": "CREATE TABLE foo (a BIGINT, INDEX b USING HASH (c) COMMENT 'd' VISIBLE ENGINE_ATTRIBUTE = 'e' WITH PARSER foo)",
      "expected": null
    },
    {
      "sql": "DELETE t1 FROM t1 LEFT JOIN t2 ON t1.id = t2.id WHERE t2.id IS NULL",
      "expected": null
    },
    {
      "sql": "DELETE t1, t2 FROM t1 INNER JOIN t2 INNER JOIN t3 WHERE t1.id = t2.id AND t2.id = t3.id",
      "expected": null
    },
    {
      "sql": "DELETE FROM t1, t2 USING t1 INNER JOIN t2 INNER JOIN t3 WHERE t1.id = t2.id AND t2.id = t3.id",
      "expected": null
    },
    {
      "sql": "INSERT IGNORE INTO subscribers (email) VALUES ('john.doe@gmail.com'), ('jane.smith@ibm.com')",
      "expected": null
    },
    {
      "sql": "INSERT INTO t1 (a, b, c) VALUES (1, 2, 3), (4, 5, 6) ON DUPLICATE KEY UPDATE c = VALUES(a) + VALUES(b)",
      "expected": null
    },
    {
      "sql": "INSERT INTO t1 (a, b) SELECT c, d FROM t2 UNION SELECT e, f FROM t3 ON DUPLICATE KEY UPDATE b = b + c",
      "expected": null
    },
    {
      "sql": "INSERT INTO t1 (a, b, c) VALUES (1, 2, 3) ON DUPLICATE KEY UPDATE c = c + 1",
      "expected": null
    },
    {
      "sql": "INSERT INTO x VALUES (1, 'a', 2.0) ON DUPLICATE KEY UPDATE x.id = 1",
      "expected": null
    },
    {
      "sql": "CREATE OR REPLACE VIEW my_view AS SELECT column1 AS `boo`, column2 AS `foo` FROM my_table WHERE column3 = 'some_value' UNION SELECT q.* FROM fruits_table, JSON_TABLE(Fruits, '$[*]' COLUMNS(id VARCHAR(255) PATH '$.$id', value VARCHAR(255) PATH '$.value')) AS q",
      "expected": null
    },
    {
      "sql": "CREATE TABLE test_table (id INT AUTO_INCREMENT, PRIMARY KEY (id) USING BTREE)",
      "expected": null
    },
    {
      "sql": "CREATE TABLE test_table (id INT AUTO_INCREMENT, PRIMARY KEY (id) USING HASH)",
      "expected": null
    },
    {
      "sql": "CREATE TABLE test (id INT, PRIMARY KEY pk_name (id))",
      "expected": null
    },
    {
      "sql": "CREATE TABLE test (id INT, PRIMARY KEY `pk_name` (id))",
      "expected": null
    },
    {
      "sql": "CREATE TABLE test (id INT, PRIMARY KEY \"pk_name\" (id))",
      "expected": "CREATE TABLE test (id INT, PRIMARY KEY `pk_name` (id))"
    },
    {
      "sql": "CREATE TABLE test (id INT, CONSTRAINT pk_name PRIMARY KEY (id))",
      "expected": null
    },
    {
      "sql": "CREATE TABLE test (a INT, b INT GENERATED ALWAYS AS (a + a) STORED)",
      "expected": null
    },
    {
      "sql": "CREATE TABLE test (a INT, b INT GENERATED ALWAYS AS (a + a) VIRTUAL)",
      "expected": null
    },
    {
      "sql": "CREATE TABLE test (a INT, b INT AS (a + a) STORED)",
      "expected": "CREATE TABLE test (a INT, b INT GENERATED ALWAYS AS (a + a) STORED)"
    },
    {
      "sql": "CREATE TABLE test (a INT, b INT AS (a + a) VIRTUAL)",
      "expected": "CREATE TABLE test (a INT, b INT GENERATED ALWAYS AS (a + a) VIRTUAL)"
    },
    {
      "sql": "/*left*/ EXPLAIN SELECT /*hint*/ col FROM t1 /*right*/",
      "expected": "/* left */ DESCRIBE /* hint */ SELECT col FROM t1 /* right */"
    },
    {
      "sql": "CREATE TABLE t (name VARCHAR)",
      "expected": "CREATE TABLE t (name TEXT)"
    },
    {
      "sql": "ALTER TABLE t ADD KEY `i` (`c`)",
      "expected": "ALTER TABLE t ADD INDEX `i` (`c`)"
    },
    {
      "sql": "CREATE TABLE `foo` (`id` char(36) NOT NULL DEFAULT (uuid()), PRIMARY KEY (`id`), UNIQUE KEY `id` (`id`))",
      "expected": "CREATE TABLE `foo` (`id` CHAR(36) NOT NULL DEFAULT (UUID()), PRIMARY KEY (`id`), UNIQUE `id` (`id`))"
    },
    {
      "sql": "CREATE TABLE IF NOT EXISTS industry_info (a BIGINT(20) NOT NULL AUTO_INCREMENT, b BIGINT(20) NOT NULL, c VARCHAR(1000), PRIMARY KEY (a), UNIQUE KEY d (b), KEY e (b))",
      "expected": "CREATE TABLE IF NOT EXISTS industry_info (a BIGINT(20) NOT NULL AUTO_INCREMENT, b BIGINT(20) NOT NULL, c VARCHAR(1000), PRIMARY KEY (a), UNIQUE d (b), INDEX e (b))"
    },
    {
      "sql": "CREATE TABLE test (ts TIMESTAMP, ts_tz TIMESTAMPTZ, ts_ltz TIMESTAMPLTZ)",
      "expected": "CREATE TABLE test (ts TIMESTAMP, ts_tz TIMESTAMP, ts_ltz TIMESTAMP)"
    },
    {
      "sql": "ALTER TABLE test_table ALTER COLUMN test_column SET DATA TYPE LONGTEXT",
      "expected": "ALTER TABLE test_table MODIFY COLUMN test_column LONGTEXT"
    },
    {
      "sql": "CREATE TABLE t (c DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC",
      "expected": "CREATE TABLE t (c DATETIME DEFAULT CURRENT_TIMESTAMP() ON UPDATE CURRENT_TIMESTAMP()) DEFAULT CHARACTER SET=utf8 ROW_FORMAT=DYNAMIC"
    },
    {
      "sql": "CREATE TABLE `foo` (a VARCHAR(10), KEY idx_a (a DESC))",
      "expected": "CREATE TABLE `foo` (a VARCHAR(10), INDEX idx_a (a DESC))"
    },
    {
      "sql": "CREATE TABLE `foo` (a VARCHAR(10), UNIQUE INDEX idx_a (a))",
      "expected": "CREATE TABLE `foo` (a VARCHAR(10), UNIQUE idx_a (a))"
    },
    {
      "sql": "ALTER TABLE t ALTER INDEX i INVISIBLE",
      "expected": null
    },
    {
      "sql": "ALTER TABLE t ALTER INDEX i VISIBLE",
      "expected": null
    },
    {
      "sql": "ALTER TABLE t ALTER COLUMN c SET INVISIBLE",
      "expected": null
    },
    {
      "sql": "ALTER TABLE t ALTER COLUMN c SET VISIBLE",
      "expected": null
    },
    {
      "sql": "UPDATE foo JOIN bar ON TRUE SET foo.a = bar.a WHERE foo.id = bar.id",
      "expected": null
    },
    {
      "sql": "SELECT HIGH_PRIORITY STRAIGHT_JOIN SQL_CALC_FOUND_ROWS * FROM t",
      "expected": null
    },
    {
      "sql": "SELECT CAST(COALESCE(`id`, 'NULL') AS CHAR CHARACTER SET binary)",
      "expected": null
    },
    {
      "sql": "SELECT e.* FROM e STRAIGHT_JOIN p ON e.x = p.y",
      "expected": null
    },
    {
      "sql": "ALTER TABLE test_table ALTER COLUMN test_column SET DEFAULT 1",
      "expected": null
    },
    {
      "sql": "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:00.0000')",
      "expected": null
    },
    {
      "sql": "SELECT @var1 := 1, @var2",
      "expected": null
    },
    {
      "sql": "UNLOCK TABLES",
      "expected": null
    },
    {
      "sql": "LOCK TABLES `app_fields` WRITE",
      "expected": null
    },
    {
      "sql": "SELECT 1 XOR 0",
      "expected": null
    },
    {
      "sql": "SELECT 1 && 0",
      "expected": "SELECT 1 AND 0"
    },
    {
      "sql": "SELECT /*+ BKA(t1) NO_BKA(t2) */ * FROM t1 INNER JOIN t2",
      "expected": null
    },
    {
      "sql": "SELECT /*+ MERGE(dt) */ * FROM (SELECT * FROM t1) AS dt",
      "expected": null
    },
    {
      "sql": "SELECT /*+ INDEX(t, i) */ c1 FROM t WHERE c2 = 'value'",
      "expected": null
    },
    {
      "sql": "SELECT @a MEMBER OF(@c), @b MEMBER OF(@c)",
      "expected": null
    },
    {
      "sql": "SELECT JSON_ARRAY(4, 5) MEMBER OF('[[3,4],[4,5]]')",
      "expected": null
    },
    {
      "sql": "SELECT CAST('[4,5]' AS JSON) MEMBER OF('[[3,4],[4,5]]')",
      "expected": null
    },
    {
      "sql": "SELECT 'ab' MEMBER OF('[23, \"abc\", 17, \"ab\", 10]')",
      "expected": null
    },
    {
      "sql": "SELECT * FROM foo WHERE 'ab' MEMBER OF(content)",
      "expected": null
    },
    {
      "sql": "SELECT CURRENT_TIMESTAMP(6)",
      "expected": null
    },
    {
      "sql": "SELECT CURRENT_ROLE()",
      "expected": null
    },
    {
      "sql": "x ->> '$.name'",
      "expected": null
    },
    {
      "sql": "SELECT CAST(`a`.`b` AS CHAR) FROM foo",
      "expected": null
    },
    {
      "sql": "SELECT TRIM(LEADING 'bla' FROM ' XXX ')",
      "expected": null
    },
    {
      "sql": "SELECT TRIM(TRAILING 'bla' FROM ' XXX ')",
      "expected": null
    },
    {
      "sql": "SELECT TRIM(BOTH 'bla' FROM ' XXX ')",
      "expected": null
    },
    {
      "sql": "SELECT TRIM('bla' FROM ' XXX ')",
      "expected": null
    },
    {
      "sql": "@@GLOBAL.max_connections",
      "expected": null
    },
    {
      "sql": "CREATE TABLE A LIKE B",
      "expected": null
    },
    {
      "sql": "SELECT * FROM t1, t2 FOR SHARE OF t1, t2 SKIP LOCKED",
      "expected": null
    },
    {
      "sql": "SELECT a || b",
      "expected": "SELECT a OR b"
    },
    {
      "sql": "SELECT * FROM source, JSON_TABLE(source.links, '$.org[*]' COLUMNS(row_id FOR ORDINALITY, link VARCHAR(255) PATH '$.link')) AS links",
      "expected": null
    },
    {
      "sql": "SELECT * FROM x ORDER BY BINARY a",
      "expected": "SELECT * FROM x ORDER BY CAST(a AS BINARY)"
    },
    {
      "sql": "SELECT * FROM foo WHERE 3 MEMBER OF(JSON_EXTRACT(info, '$.value'))",
      "expected": null
    },
    {
      "sql": "SELECT * FROM t1, t2, t3 FOR SHARE OF t1 NOWAIT FOR UPDATE OF t2, t3 SKIP LOCKED",
      "expected": null
    },
    {
      "sql": "REPLACE INTO table SELECT id FROM table2 WHERE cnt > 100",
      "expected": null
    },
    {
      "sql": "CAST(x AS VARCHAR)",
      "expected": "CAST(x AS CHAR)"
    },
    {
      "sql": "SELECT * FROM foo WHERE 3 MEMBER OF(info->'$.value')",
      "expected": "SELECT * FROM foo WHERE 3 MEMBER OF(JSON_EXTRACT(info, '$.value'))"
    },
    {
      "sql": "SELECT 1 AS row",
      "expected": "SELECT 1 AS `row`"
    },
    {
      "sql": "SELECT * FROM table1 USE INDEX (col1_index, col2_index) WHERE col1 = 1 AND col2 = 2 AND col3 = 3",
      "expected": null
    },
    {
      "sql": "SELECT * FROM table1 IGNORE INDEX (col3_index) WHERE col1 = 1 AND col2 = 2 AND col3 = 3",
      "expected": null
    },
    {
      "sql": "SELECT * FROM t1 USE INDEX (i1) IGNORE INDEX FOR ORDER BY (i2) ORDER BY a",
      "expected": null
    },
    {
      "sql": "SELECT * FROM t1 USE INDEX (i1) USE INDEX (i1, i1)",
      "expected": null
    },
    {
      "sql": "SELECT * FROM t1 USE INDEX FOR JOIN (i1) FORCE INDEX FOR JOIN (i2)",
      "expected": null
    },
    {
      "sql": "SELECT * FROM t1 USE INDEX () IGNORE INDEX (i2) USE INDEX (i1) USE INDEX (i2)",
      "expected": null
    },
    {
      "sql": "SET @var_name = expr",
      "expected": null
    },
    {
      "sql": "SET @name = 43",
      "expected": null
    },
    {
      "sql": "SET @total_tax = (SELECT SUM(tax) FROM taxable_transactions)",
      "expected": null
    },
    {
      "sql": "SET GLOBAL max_connections = 1000",
      "expected": null
    },
    {
      "sql": "SET @@GLOBAL.max_connections = 1000",
      "expected": null
    },
    {
      "sql": "SET SESSION sql_mode = 'TRADITIONAL'",
      "expected": null
    },
    {
      "sql": "SET LOCAL sql_mode = 'TRADITIONAL'",
      "expected": null
    },
    {
      "sql": "SET @@SESSION.sql_mode = 'TRADITIONAL'",
      "expected": null
    },
    {
      "sql": "SET @@LOCAL.sql_mode = 'TRADITIONAL'",
      "expected": null
    },
    {
      "sql": "SET @@sql_mode = 'TRADITIONAL'",
      "expected": null
    },
    {
      "sql": "SET sql_mode = 'TRADITIONAL'",
      "expected": null
    },
    {
      "sql": "SET PERSIST max_connections = 1000",
      "expected": null
    },
    {
      "sql": "SET @@PERSIST.max_connections = 1000",
      "expected": null
    },
    {
      "sql": "SET PERSIST_ONLY back_log = 100",
      "expected": null
    },
    {
      "sql": "SET @@PERSIST_ONLY.back_log = 100",
      "expected": null
    },
    {
      "sql": "SET @@SESSION.max_join_size = DEFAULT",
      "expected": null
    },
    {
      "sql": "SET @@SESSION.max_join_size = @@GLOBAL.max_join_size",
      "expected": null
    },
    {
      "sql": "SET @x = 1, SESSION sql_mode = ''",
      "expected": null
    },
    {
      "sql": "SET GLOBAL max_connections = 1000, sort_buffer_size = 1000000",
      "expected": null
    },
    {
      "sql": "SET @@GLOBAL.sort_buffer_size = 50000, sort_buffer_size = 1000000",
      "expected": null
    },
    {
      "sql": "SET CHARACTER SET 'utf8'",
      "expected": null
    },
    {
      "sql": "SET CHARACTER SET utf8",
      "expected": null
    },
    {
      "sql": "SET CHARACTER SET DEFAULT",
      "expected": null
    },
    {
      "sql": "SET NAMES 'utf8'",
      "expected": null
    },
    {
      "sql": "SET NAMES DEFAULT",
      "expected": null
    },
    {
      "sql": "SET NAMES 'utf8' COLLATE 'utf8_unicode_ci'",
      "expected": null
    },
    {
      "sql": "SET NAMES utf8 COLLATE utf8_unicode_ci",
      "expected": null
    },
    {
      "sql": "SET autocommit = ON",
      "expected": null
    },
    {
      "sql": "SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE",
      "expected": null
    },
    {
      "sql": "SET TRANSACTION READ ONLY",
      "expected": null
    },
    {
      "sql": "SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ WRITE",
      "expected": null
    },
    {
      "sql": "DATABASE()",
      "expected": "SCHEMA()"
    },
    {
      "sql": "SET GLOBAL sort_buffer_size = 1000000, SESSION sort_buffer_size = 1000000",
      "expected": null
    },
    {
      "sql": "SET @@GLOBAL.sort_buffer_size = 1000000, @@LOCAL.sort_buffer_size = 1000000",
      "expected": null
    },
    {
      "sql": "INTERVAL '1' YEAR",
      "expected": null
    },
    {
      "sql": "DATE_ADD(x, INTERVAL '1' YEAR)",
      "expected": null
    },
    {
      "sql": "CHAR(0)",
      "expected": null
    },
    {
      "sql": "CHAR(77, 121, 83, 81, '76')",
      "expected": null
    },
    {
      "sql": "CHAR(77, 77.3, '77.3' USING utf8mb4)",
      "expected": null
    },
    {
      "sql": "SELECT * FROM t1 PARTITION(p0)",
      "expected": null
    },
    {
      "sql": "SELECT @var1 := 1, @var2",
      "expected": null
    },
    {
      "sql": "SELECT @var1, @var2 := @var1",
      "expected": null
    },
    {
      "sql": "SELECT @var1 := COUNT(*) FROM t1",
      "expected": null
    },
    {
      "sql": "SET @var1 := 1",
      "expected": "SET @var1 = 1"
    },
    {
      "sql": "SELECT DISTINCTROW tbl.col FROM tbl",
      "expected": "SELECT DISTINCT tbl.col FROM tbl"
    },
    {
      "sql": "ATAN(y, x)",
      "expected": null
    },
    {
      "sql": "SELECT 'foo' SOUNDS LIKE 'bar'",
      "expected": "SELECT SOUNDEX('foo') = SOUNDEX('bar')"
    },
    {
      "sql": "SELECT 'foo' NOT SOUNDS LIKE 'bar'",
      "expected": "SELECT NOT SOUNDEX('foo') = SOUNDEX('bar')"
    },
    {
      "sql": "SELECT SUBSTR(1 FROM 2 FOR 3)",
      "expected": "SELECT SUBSTRING(1, 2, 3)"
    },
    {
      "sql": "SELECT ELT(2, 'foo', 'bar', 'baz') AS Result",
      "expected": null
    },
    {
      "sql": "SELECT CHARSET(CHAR(100 USING utf8))",
      "expected": null
    },
    {
      "sql": "CAST(x AS ENUM('a', 'b'))",
      "expected": null
    },
    {
      "sql": "CAST(x AS SET('a', 'b'))",
      "expected": null
    },
    {
      "sql": "CAST(x AS MEDIUMINT) + CAST(y AS YEAR(4))",
      "expected": "CAST(x AS SIGNED) + CAST(y AS YEAR(4))"
    },
    {
      "sql": "CAST(x AS TIMESTAMP)",
      "expected": "TIMESTAMP(x)"
    },
    {
      "sql": "CAST(x AS TIMESTAMPTZ)",
      "expected": "TIMESTAMP(x)"
    },
    {
      "sql": "CAST(x AS TIMESTAMPLTZ)",
      "expected": "TIMESTAMP(x)"
    },
    {
      "sql": "SELECT LEFT('str', 2)",
      "expected": "SELECT LEFT('str', 2)"
    },
    {
      "sql": "SELECT INSTR('str', 'substr')",
      "expected": "SELECT LOCATE('substr', 'str')"
    },
    {
      "sql": "SELECT UCASE('foo')",
      "expected": "SELECT UPPER('foo')"
    },
    {
      "sql": "SELECT LCASE('foo')",
      "expected": "SELECT LOWER('foo')"
    },
    {
      "sql": "SELECT DAY_OF_MONTH('2023-01-01')",
      "expected": "SELECT DAYOFMONTH('2023-01-01')"
    },
    {
      "sql": "SELECT DAY_OF_WEEK('2023-01-01')",
      "expected": "SELECT DAYOFWEEK('2023-01-01')"
    },
    {
      "sql": "SELECT DAY_OF_YEAR('2023-01-01')",
      "expected": "SELECT DAYOFYEAR('2023-01-01')"
    },
    {
      "sql": "SELECT WEEK_OF_YEAR('2023-01-01')",
      "expected": "SELECT WEEKOFYEAR('2023-01-01')"
    },
    {
      "sql": "CREATE TABLE t (foo VARBINARY(5))",
      "expected": null
    },
    {
      "sql": "'\"abc\"'",
      "expected": null
    },
    {
      "sql": "'\\'a'",
      "expected": "'''a'"
    },
    {
      "sql": "\"'abc'\"",
      "expected": "'''abc'''"
    },
    {
      "sql": "'\\\"'",
      "expected": "'\"'"
    },
    {
      "sql": "'\\\\\"a'",
      "expected": null
    },
    {
      "sql": "'\t'",
      "expected": "'\\t'"
    },
    {
      "sql": "'\\j'",
      "expected": "'j'"
    },
    {
      "sql": "CONVERT('a' USING binary)",
      "expected": "CAST('a' AS CHAR CHARACTER SET binary)"
    },
    {
      "sql": "TIME_STR_TO_UNIX(x)",
      "expected": "UNIX_TIMESTAMP(x)"
    },
    {
      "sql": "SELECT FROM_UNIXTIME(1711366265, '%Y %D %M')",
      "expected": null
    },
    {
      "sql": "SELECT TIME_STR_TO_TIME('2023-01-01 13:14:15.123456+00:00')",
      "expected": "SELECT CAST('2023-01-01 13:14:15.123456+00:00' AS DATETIME(6))"
    },
    {
      "sql": "SELECT TIME_STR_TO_TIME('2023-01-01 13:14:15.123+00:00')",
      "expected": "SELECT CAST('2023-01-01 13:14:15.123+00:00' AS DATETIME(3))"
    },
    {
      "sql": "SELECT TIME_STR_TO_TIME('2023-01-01 13:14:15+00:00')",
      "expected": "SELECT CAST('2023-01-01 13:14:15+00:00' AS DATETIME)"
    },
    {
      "sql": "SELECT TIME_STR_TO_TIME('2023-01-01 13:14:15-08:00', 'America/Los_Angeles')",
      "expected": "SELECT TIMESTAMP('2023-01-01 13:14:15-08:00')"
    },
    {
      "sql": "SELECT TIME_STR_TO_TIME('2023-01-01 13:14:15-08:00', 'America/Los_Angeles')",
      "expected": "SELECT TIMESTAMP('2023-01-01 13:14:15-08:00')"
    },
    {
      "sql": "SELECT TIME_STR_TO_TIME('2023-01-01 13:14:15.12345+00:00')",
      "expected": "SELECT CAST('2023-01-01 13:14:15.12345+00:00' AS DATETIME(6))"
    },
    {
      "sql": "SELECT TIME_STR_TO_TIME('2023-01-01 13:14:15.1234+00:00')",
      "expected": "SELECT CAST('2023-01-01 13:14:15.1234+00:00' AS DATETIME(6))"
    },
    {
      "sql": "SELECT TIME_STR_TO_TIME('2023-01-01 13:14:15.12+00:00')",
      "expected": "SELECT CAST('2023-01-01 13:14:15.12+00:00' AS DATETIME(3))"
    },
    {
      "sql": "SELECT TIME_STR_TO_TIME('2023-01-01 13:14:15.1+00:00')",
      "expected": "SELECT CAST('2023-01-01 13:14:15.1+00:00' AS DATETIME(3))"
    },
    {
      "sql": "SELECT name FROM temp WHERE name = ? FOR UPDATE",
      "expected": null
    },
    {
      "sql": "CREATE TABLE z (a INT) ENGINE=InnoDB AUTO_INCREMENT=1 CHARACTER SET=utf8 COLLATE=utf8_bin COMMENT='x'",
      "expected": null
    },
    {
      "sql": "CREATE TABLE z (a INT) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARACTER SET=utf8 COLLATE=utf8_bin COMMENT='x'",
      "expected": null
    },
    {
      "sql": "CREATE TABLE z (a INT DEFAULT NULL, PRIMARY KEY (a)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARACTER SET=utf8 COLLATE=utf8_bin COMMENT='x'",
      "expected": null
    },
    {
      "sql": "SHOW COLUMNS FROM tbl_name",
      "expected": null
    },
    {
      "sql": "SHOW FULL COLUMNS FROM tbl_name FROM db_name LIKE '%foo%'",
      "expected": null
    },
    {
      "sql": "SHOW GRANTS FOR foo",
      "expected": null
    },
    {
      "sql": "SHOW ENGINE foo STATUS",
      "expected": null
    },
    {
      "sql": "SHOW ENGINE foo MUTEX",
      "expected": null
    },
    {
      "sql": "SHOW INDEX FROM foo",
      "expected": null
    },
    {
      "sql": "SHOW INDEX FROM foo FROM bar",
      "expected": null
    },
    {
      "sql": "SHOW PROCESSLIST",
      "expected": null
    },
    {
      "sql": "SHOW FULL PROCESSLIST",
      "expected": null
    },
    {
      "sql": "SHOW PROFILE",
      "expected": null
    },
    {
      "sql": "SHOW PROFILE BLOCK IO",
      "expected": null
    },
    {
      "sql": "SHOW PROFILE BLOCK IO, PAGE FAULTS FOR QUERY 1 OFFSET 2 LIMIT 3",
      "expected": null
    },
    {
      "sql": "SHOW REPLICA STATUS",
      "expected": null
    },
    {
      "sql": "SHOW SLAVE STATUS",
      "expected": "SHOW REPLICA STATUS"
    },
    {
      "sql": "SHOW REPLICA STATUS FOR CHANNEL channel_name",
      "expected": null
    },
    {
      "sql": "SHOW TABLES",
      "expected": null
    },
    {
      "sql": "SHOW FULL TABLES FROM db_name LIKE '%foo%'",
      "expected": null
    },
    {
      "sql": "SELECT JSON_OBJECT('id', 87, 'name', 'carrot')",
      "expected": null
    },
    {
      "sql": "EXPLAIN ANALYZE SELECT * FROM t",
      "expected": "DESCRIBE ANALYZE SELECT * FROM t"
    },
    {
      "sql": "ANALYZE LOCAL TABLE tbl",
      "expected": null
    },
    {
      "sql": "ANALYZE NO_WRITE_TO_BINLOG TABLE tbl",
      "expected": null
    },
    {
      "sql": "ANALYZE tbl UPDATE HISTOGRAM ON col1",
      "expected": null
    },
    {
      "sql": "ANALYZE tbl UPDATE HISTOGRAM ON col1 USING DATA 'json_data'",
      "expected": null
    },
    {
      "sql": "ANALYZE tbl UPDATE HISTOGRAM ON col1 WITH 5 BUCKETS",
      "expected": null
    },
    {
      "sql": "ANALYZE tbl UPDATE HISTOGRAM ON col1 WITH 5 BUCKETS AUTO UPDATE",
      "expected": null
    },
    {
      "sql": "ANALYZE tbl UPDATE HISTOGRAM ON col1 WITH 5 BUCKETS MANUAL UPDATE",
      "expected": null
    },
    {
      "sql": "ANALYZE tbl DROP HISTOGRAM ON col1",
      "expected": null
    },
    {
      "sql": "SELECT foo AT TIME ZONE 'UTC'",
      "expected": "SELECT foo"
    },
    {
      "sql": "UTC_TIME()",
      "expected": null
    },
    {
      "sql": "UTC_TIME(6)",
      "expected": null
    },
    {
      "sql": "UTC_TIMESTAMP()",
      "expected": null
    },
    {
      "sql": "UTC_TIMESTAMP(6)",
      "expected": null
    },
    {
      "sql": "x % y",
      "expected": null
    },
    {
      "sql": "x MOD y",
      "expected": "x % y"
    },
    {
      "sql": "MOD(x, y)",
      "expected": "x % y"
    }
  ],
  "transpilation": [
    {
      "sql": "insert into t(i) values (default)",
      "read": {},
      "write": {
        "duckdb": "INSERT INTO t (i) VALUES (DEFAULT)",
        "mysql": "INSERT INTO t (i) VALUES (DEFAULT)"
      }
    },
    {
      "sql": "CREATE TABLE t (id INT UNSIGNED)",
      "read": {},
      "write": {
        "duckdb": "CREATE TABLE t (id UINTEGER)",
        "mysql": "CREATE TABLE t (id INT UNSIGNED)"
      }
    },
    {
      "sql": "CREATE TABLE z (a INT) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARACTER SET=utf8 COLLATE=utf8_bin COMMENT='x'",
      "read": {},
      "write": {
        "duckdb": "CREATE TABLE z (a INT)",
        "mysql": "CREATE TABLE z (a INT) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARACTER SET=utf8 COLLATE=utf8_bin COMMENT='x'",
        "spark": "CREATE TABLE z (a INT) COMMENT 'x'",
        "sqlite": "CREATE TABLE z (a INTEGER)"
      }
    },
    {
      "sql": "CREATE TABLE x (id int not null auto_increment, primary key (id))",
      "read": {},
      "write": {
        "mysql": "CREATE TABLE x (id INT NOT NULL AUTO_INCREMENT, PRIMARY KEY (id))",
        "sqlite": "CREATE TABLE x (id INTEGER NOT NULL AUTOINCREMENT PRIMARY KEY)"
      }
    },
    {
      "sql": "CAST(x AS MEDIUMTEXT) + CAST(y AS LONGTEXT) + CAST(z AS TINYTEXT)",
      "read": {},
      "write": {
        "mysql": "CAST(x AS CHAR) + CAST(y AS CHAR) + CAST(z AS CHAR)",
        "spark": "CAST(x AS TEXT) + CAST(y AS TEXT) + CAST(z AS TEXT)"
      }
    },
    {
      "sql": "CAST(x AS MEDIUMBLOB) + CAST(y AS LONGBLOB) + CAST(z AS TINYBLOB)",
      "read": {},
      "write": {
        "mysql": "CAST(x AS CHAR) + CAST(y AS CHAR) + CAST(z AS CHAR)",
        "spark": "CAST(x AS BLOB) + CAST(y AS BLOB) + CAST(z AS BLOB)"
      }
    },
    {
      "sql": "CHAR(10)",
      "read": {},
      "write": {
        "mysql": "CHAR(10)",
        "presto": "CHR(10)",
        "sqlite": "CHAR(10)",
        "tsql": "CHAR(10)"
      }
    },
    {
      "sql": "CREATE TABLE t (foo BLOB)",
      "read": {},
      "write": {
        "mysql": "CREATE TABLE t (foo BLOB)",
        "oracle": "CREATE TABLE t (foo BLOB)",
        "postgres": "CREATE TABLE t (foo BYTEA)",
        "tsql": "CREATE TABLE t (foo VARBINARY)",
        "sqlite": "CREATE TABLE t (foo BLOB)",
        "duckdb": "CREATE TABLE t (foo VARBINARY)",
        "hive": "CREATE TABLE t (foo BINARY)",
        "bigquery": "CREATE TABLE t (foo BYTES)",
        "redshift": "CREATE TABLE t (foo VARBYTE)",
        "clickhouse": "CREATE TABLE t (foo Nullable(String))"
      }
    },
    {
      "sql": "'a \\' b '' '",
      "read": {},
      "write": {
        "mysql": "'a '' b '' '",
        "spark": "'a \\' b \\' '"
      }
    },
    {
      "sql": "_utf8mb4 'hola'",
      "read": {
        "mysql": "_utf8mb4'hola'"
      },
      "write": {
        "mysql": "_utf8mb4 'hola'"
      }
    },
    {
      "sql": "N'some text'",
      "read": {
        "mysql": "n'some text'"
      },
      "write": {
        "mysql": "N'some text'"
      }
    },
    {
      "sql": "_latin1 x'4D7953514C'",
      "read": {
        "mysql": "_latin1 X'4D7953514C'"
      },
      "write": {
        "mysql": "_latin1 x'4D7953514C'"
      }
    },
    {
      "sql": "SELECT X'1A'",
      "read": {},
      "write": {
        "mysql": "SELECT x'1A'"
      }
    },
    {
      "sql": "SELECT 0xz",
      "read": {},
      "write": {
        "mysql": "SELECT `0xz`"
      }
    },
    {
      "sql": "SELECT \"2021-01-01\" + INTERVAL 1 MONTH",
      "read": {},
      "write": {
        "mysql": "SELECT '2021-01-01' + INTERVAL '1' MONTH"
      }
    },
    {
      "sql": "CONVERT(x USING latin1)",
      "read": {},
      "write": {
        "mysql": "CAST(x AS CHAR CHARACTER SET latin1)"
      }
    },
    {
      "sql": "CAST(x AS CHAR CHARACTER SET latin1)",
      "read": {},
      "write": {
        "mysql": "CAST(x AS CHAR CHARACTER SET latin1)"
      }
    },
    {
      "sql": "MATCH(col1, col2, col3) AGAINST('abc')",
      "read": {
        "mysql": "MATCH(col1, col2, col3) AGAINST('abc')"
      },
      "write": {
        "mysql": "MATCH(col1, col2, col3) AGAINST('abc')",
        "postgres": "(col1 @@ 'abc' OR col2 @@ 'abc' OR col3 @@ 'abc')"
      }
    },
    {
      "sql": "MATCH(col1, col2) AGAINST('abc' IN NATURAL LANGUAGE MODE)",
      "read": {},
      "write": {
        "mysql": "MATCH(col1, col2) AGAINST('abc' IN NATURAL LANGUAGE MODE)"
      }
    },
    {
      "sql": "MATCH(col1, col2) AGAINST('abc' IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION)",
      "read": {},
      "write": {
        "mysql": "MATCH(col1, col2) AGAINST('abc' IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION)"
      }
    },
    {
      "sql": "MATCH(col1, col2) AGAINST('abc' IN BOOLEAN MODE)",
      "read": {},
      "write": {
        "mysql": "MATCH(col1, col2) AGAINST('abc' IN BOOLEAN MODE)"
      }
    },
    {
      "sql": "MATCH(col1, col2) AGAINST('abc' WITH QUERY EXPANSION)",
      "read": {},
      "write": {
        "mysql": "MATCH(col1, col2) AGAINST('abc' WITH QUERY EXPANSION)"
      }
    },
    {
      "sql": "MATCH(a.b) AGAINST('abc')",
      "read": {},
      "write": {
        "mysql": "MATCH(a.b) AGAINST('abc')"
      }
    },
    {
      "sql": "SELECT DATE_FORMAT('2017-06-15', '%Y')",
      "read": {},
      "write": {
        "mysql": "SELECT DATE_FORMAT('2017-06-15', '%Y')",
        "snowflake": "SELECT TO_CHAR(CAST('2017-06-15' AS TIMESTAMP), 'yyyy')"
      }
    },
    {
      "sql": "SELECT DATE_FORMAT('2017-06-15', '%m')",
      "read": {},
      "write": {
        "mysql": "SELECT DATE_FORMAT('2017-06-15', '%m')",
        "snowflake": "SELECT TO_CHAR(CAST('2017-06-15' AS TIMESTAMP), 'mm')"
      }
    },
    {
      "sql": "SELECT DATE_FORMAT('2017-06-15', '%d')",
      "read": {},
      "write": {
        "mysql": "SELECT DATE_FORMAT('2017-06-15', '%d')",
        "snowflake": "SELECT TO_CHAR(CAST('2017-06-15' AS TIMESTAMP), 'DD')"
      }
    },
    {
      "sql": "SELECT DATE_FORMAT('2017-06-15', '%Y-%m-%d')",
      "read": {},
      "write": {
        "mysql": "SELECT DATE_FORMAT('2017-06-15', '%Y-%m-%d')",
        "snowflake": "SELECT TO_CHAR(CAST('2017-06-15' AS TIMESTAMP), 'yyyy-mm-DD')"
      }
    },
    {
      "sql": "SELECT DATE_FORMAT('2017-06-15 22:23:34', '%H')",
      "read": {},
      "write": {
        "mysql": "SELECT DATE_FORMAT('2017-06-15 22:23:34', '%H')",
        "snowflake": "SELECT TO_CHAR(CAST('2017-06-15 22:23:34' AS TIMESTAMP), 'hh24')"
      }
    },
    {
      "sql": "SELECT DATE_FORMAT('2017-06-15', '%w')",
      "read": {},
      "write": {
        "mysql": "SELECT DATE_FORMAT('2017-06-15', '%w')",
        "snowflake": "SELECT TO_CHAR(CAST('2017-06-15' AS TIMESTAMP), 'dy')"
      }
    },
    {
      "sql": "SELECT DATE_FORMAT('2024-08-22 14:53:12', '%a')",
      "read": {},
      "write": {
        "mysql": "SELECT DATE_FORMAT('2024-08-22 14:53:12', '%a')",
        "snowflake": "SELECT TO_CHAR(CAST('2024-08-22 14:53:12' AS TIMESTAMP), 'DY')"
      }
    },
    {
      "sql": "SELECT DATE_FORMAT('2009-10-04 22:23:00', '%a %M %Y')",
      "read": {},
      "write": {
        "mysql": "SELECT DATE_FORMAT('2009-10-04 22:23:00', '%a %M %Y')",
        "snowflake": "SELECT TO_CHAR(CAST('2009-10-04 22:23:00' AS TIMESTAMP), 'DY mmmm yyyy')"
      }
    },
    {
      "sql": "SELECT DATE_FORMAT('2007-10-04 22:23:00', '%H:%i:%s')",
      "read": {},
      "write": {
        "mysql": "SELECT DATE_FORMAT('2007-10-04 22:23:00', '%T')",
        "snowflake": "SELECT TO_CHAR(CAST('2007-10-04 22:23:00' AS TIMESTAMP), 'hh24:mi:ss')"
      }
    },
    {
      "sql": "SELECT DATE_FORMAT('1900-10-04 22:23:00', '%d %y %a %d %m %b')",
      "read": {},
      "write": {
        "mysql": "SELECT DATE_FORMAT('1900-10-04 22:23:00', '%d %y %a %d %m %b')",
        "snowflake": "SELECT TO_CHAR(CAST('1900-10-04 22:23:00' AS TIMESTAMP), 'DD yy DY DD mm mon')"
      }
    },
    {
      "sql": "SELECT TO_DAYS(x)",
      "read": {},
      "write": {
        "mysql": "SELECT (DATEDIFF(x, '0000-01-01') + 1)",
        "presto": "SELECT (DATE_DIFF('DAY', CAST(CAST('0000-01-01' AS TIMESTAMP) AS DATE), CAST(CAST(x AS TIMESTAMP) AS DATE)) + 1)"
      }
    },
    {
      "sql": "SELECT DATEDIFF(x, y)",
      "read": {
        "presto": "SELECT DATE_DIFF('DAY', y, x)",
        "redshift": "SELECT DATEDIFF(DAY, y, x)"
      },
      "write": {
        "mysql": "SELECT DATEDIFF(x, y)",
        "presto": "SELECT DATE_DIFF('DAY', y, x)",
        "redshift": "SELECT DATEDIFF(DAY, y, x)"
      }
    },
    {
      "sql": "DAYOFYEAR(x)",
      "read": {},
      "write": {
        "mysql": "DAYOFYEAR(x)"
      }
    },
    {
      "sql": "DAYOFMONTH(x)",
      "read": {},
      "write": {
        "mysql": "DAYOFMONTH(x)"
      }
    },
    {
      "sql": "DAYOFWEEK(x)",
      "read": {},
      "write": {
        "mysql": "DAYOFWEEK(x)"
      }
    },
    {
      "sql": "WEEKOFYEAR(x)",
      "read": {},
      "write": {
        "mysql": "WEEKOFYEAR(x)"
      }
    },
    {
      "sql": "DAY(x)",
      "read": {},
      "write": {
        "mysql": "DAY(x)"
      }
    },
    {
      "sql": "WEEK(x)",
      "read": {},
      "write": {
        "mysql": "WEEK(x)"
      }
    },
    {
      "sql": "YEAR(x)",
      "read": {},
      "write": {
        "mysql": "YEAR(x)"
      }
    },
    {
      "sql": "STR_TO_DATE(x, '%Y-%m-%d')",
      "read": {},
      "write": {
        "presto": "CAST(DATE_PARSE(x, '%Y-%m-%d') AS DATE)"
      }
    },
    {
      "sql": "STR_TO_DATE(x, '%Y-%m-%dT%T')",
      "read": {},
      "write": {
        "presto": "DATE_PARSE(x, '%Y-%m-%dT%T')"
      }
    },
    {
      "sql": "SELECT FROM_UNIXTIME(col)",
      "read": {
        "postgres": "SELECT TO_TIMESTAMP(col)"
      },
      "write": {
        "mysql": "SELECT FROM_UNIXTIME(col)",
        "postgres": "SELECT TO_TIMESTAMP(col)",
        "redshift": "SELECT (TIMESTAMP 'epoch' + col * INTERVAL '1 SECOND')"
      }
    },
    {
      "sql": "CURDATE()",
      "read": {},
      "write": {
        "mysql": "CURRENT_DATE",
        "postgres": "CURRENT_DATE"
      }
    },
    {
      "sql": "SELECT CONCAT('11', '22')",
      "read": {
        "postgres": "SELECT '11' || '22'"
      },
      "write": {
        "mysql": "SELECT CONCAT('11', '22')",
        "postgres": "SELECT '11' || '22'"
      }
    },
    {
      "sql": "SELECT department, GROUP_CONCAT(name) AS employee_names FROM data GROUP BY department",
      "read": {
        "postgres": "SELECT department, array_agg(name) AS employee_names FROM data GROUP BY department"
      },
      "write": {}
    },
    {
      "sql": "SELECT UNIX_TIMESTAMP(CAST('2024-04-29 12:00:00' AS DATETIME))",
      "read": {
        "mysql": "SELECT UNIX_TIMESTAMP(CAST('2024-04-29 12:00:00' AS DATETIME))",
        "postgres": "SELECT EXTRACT(epoch FROM TIMESTAMP '2024-04-29 12:00:00')"
      },
      "write": {}
    },
    {
      "sql": "SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]')",
      "read": {
        "sqlite": "SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]')"
      },
      "write": {
        "mysql": "SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]')",
        "sqlite": "SELECT '[10, 20, [30, 40]]' -> '$[1]'"
      }
    },
    {
      "sql": "SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]', '$[0]')",
      "read": {
        "sqlite": "SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]', '$[0]')"
      },
      "write": {
        "mysql": "SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]', '$[0]')",
        "sqlite": "SELECT JSON_EXTRACT('[10, 20, [30, 40]]', '$[1]', '$[0]')"
      }
    },
    {
      "sql": "SELECT * FROM x LEFT JOIN y ON x.id = y.id UNION ALL SELECT * FROM x RIGHT JOIN y ON x.id = y.id WHERE NOT EXISTS(SELECT 1 FROM x WHERE x.id = y.id) ORDER BY 1 LIMIT 0",
      "read": {
        "postgres": "SELECT * FROM x FULL JOIN y ON x.id = y.id ORDER BY 1 LIMIT 0"
      },
      "write": {}
    },
    {
      "sql": "SELECT * FROM t1 LEFT OUTER JOIN t2 ON t1.x = t2.x UNION ALL SELECT * FROM t1 RIGHT OUTER JOIN t2 ON t1.x = t2.x WHERE NOT EXISTS(SELECT 1 FROM t1 WHERE t1.x = t2.x)",
      "read": {
        "postgres": "SELECT * FROM t1 FULL OUTER JOIN t2 ON t1.x = t2.x"
      },
      "write": {}
    },
    {
      "sql": "SELECT * FROM t1 LEFT OUTER JOIN t2 USING (x) UNION ALL SELECT * FROM t1 RIGHT OUTER JOIN t2 USING (x) WHERE NOT EXISTS(SELECT 1 FROM t1 WHERE t1.x = t2.x)",
      "read": {
        "postgres": "SELECT * FROM t1 FULL OUTER JOIN t2 USING (x) "
      },
      "write": {}
    },
    {
      "sql": "SELECT * FROM t1 LEFT OUTER JOIN t2 USING (x, y) UNION ALL SELECT * FROM t1 RIGHT OUTER JOIN t2 USING (x, y) WHERE NOT EXISTS(SELECT 1 FROM t1 WHERE t1.x = t2.x AND t1.y = t2.y)",
      "read": {
        "postgres": "SELECT * FROM t1 FULL OUTER JOIN t2 USING (x, y) "
      },
      "write": {}
    },
    {
      "sql": "a XOR b",
      "read": {
        "mysql": "a XOR b",
        "snowflake": "BOOLXOR(a, b)"
      },
      "write": {
        "duckdb": "(a AND (NOT b)) OR ((NOT a) AND b)",
        "mysql": "a XOR b",
        "postgres": "(a AND (NOT b)) OR ((NOT a) AND b)",
        "snowflake": "BOOLXOR(a, b)",
        "trino": "(a AND (NOT b)) OR ((NOT a) AND b)"
      }
    },
    {
      "sql": "SELECT * FROM test LIMIT 0 + 1, 0 + 1",
      "read": {},
      "write": {
        "mysql": "SELECT * FROM test LIMIT 1 OFFSET 1",
        "postgres": "SELECT * FROM test LIMIT 0 + 1 OFFSET 0 + 1",
        "presto": "SELECT * FROM test OFFSET 1 LIMIT 1",
        "snowflake": "SELECT * FROM test LIMIT 1 OFFSET 1",
        "trino": "SELECT * FROM test OFFSET 1 LIMIT 1",
        "bigquery": "SELECT * FROM test LIMIT 1 OFFSET 1"
      }
    },
    {
      "sql": "CAST(x AS TEXT)",
      "read": {},
      "write": {
        "mysql": "CAST(x AS CHAR)",
        "presto": "CAST(x AS VARCHAR)",
        "starrocks": "CAST(x AS STRING)"
      }
    },
    {
      "sql": "CAST(x AS SIGNED)",
      "read": {},
      "write": {
        "mysql": "CAST(x AS SIGNED)"
      }
    },
    {
      "sql": "CAST(x AS SIGNED INTEGER)",
      "read": {},
      "write": {
        "mysql": "CAST(x AS SIGNED)"
      }
    },
    {
      "sql": "CAST(x AS UNSIGNED)",
      "read": {},
      "write": {
        "mysql": "CAST(x AS UNSIGNED)"
      }
    },
    {
      "sql": "CAST(x AS UNSIGNED INTEGER)",
      "read": {},
      "write": {
        "mysql": "CAST(x AS UNSIGNED)"
      }
    },
    {
      "sql": "TIME_STR_TO_TIME(x)",
      "read": {},
      "write": {
        "mysql": "CAST(x AS DATETIME)"
      }
    },
    {
      "sql": "SELECT 17 MEMBER OF('[23, \"abc\", 17, \"ab\", 10]')",
      "read": {},
      "write": {
        "mysql": "SELECT 17 MEMBER OF('[23, \"abc\", 17, \"ab\", 10]')"
      }
    },
    {
      "sql": "SELECT DATE_ADD('2023-06-23 12:00:00', INTERVAL 2 * 2 MONTH) FROM foo",
      "read": {},
      "write": {
        "mysql": "SELECT DATE_ADD('2023-06-23 12:00:00', INTERVAL (2 * 2) MONTH) FROM foo"
      }
    },
    {
      "sql": "SELECT * FROM t LOCK IN SHARE MODE",
      "read": {},
      "write": {
        "mysql": "SELECT * FROM t FOR SHARE"
      }
    },
    {
      "sql": "SELECT DATE(DATE_SUB(`dt`, INTERVAL DAYOFMONTH(`dt`) - 1 DAY)) AS __timestamp FROM tableT",
      "read": {},
      "write": {
        "mysql": "SELECT DATE(DATE_SUB(`dt`, INTERVAL (DAYOFMONTH(`dt`) - 1) DAY)) AS __timestamp FROM tableT"
      }
    },
    {
      "sql": "SELECT a FROM tbl FOR UPDATE",
      "read": {},
      "write": {
        "mysql": "SELECT a FROM tbl FOR UPDATE",
        "oracle": "SELECT a FROM tbl FOR UPDATE",
        "postgres": "SELECT a FROM tbl FOR UPDATE",
        "redshift": "SELECT a FROM tbl",
        "tsql": "SELECT a FROM tbl"
      }
    },
    {
      "sql": "SELECT a FROM tbl FOR SHARE",
      "read": {},
      "write": {
        "mysql": "SELECT a FROM tbl FOR SHARE",
        "oracle": "SELECT a FROM tbl FOR SHARE",
        "postgres": "SELECT a FROM tbl FOR SHARE",
        "tsql": "SELECT a FROM tbl"
      }
    },
    {
      "sql": "GROUP_CONCAT(DISTINCT x ORDER BY y DESC)",
      "read": {},
      "write": {
        "mysql": "GROUP_CONCAT(DISTINCT x ORDER BY y DESC SEPARATOR ',')",
        "sqlite": "GROUP_CONCAT(DISTINCT x)",
        "tsql": "STRING_AGG(x, ',') WITHIN GROUP (ORDER BY y DESC)",
        "databricks": "LISTAGG(DISTINCT x, ',') WITHIN GROUP (ORDER BY y DESC)",
        "postgres": "STRING_AGG(DISTINCT x, ',' ORDER BY y DESC NULLS LAST)"
      }
    },
    {
      "sql": "GROUP_CONCAT(x ORDER BY y SEPARATOR z)",
      "read": {},
      "write": {
        "mysql": "GROUP_CONCAT(x ORDER BY y SEPARATOR z)",
        "sqlite": "GROUP_CONCAT(x, z)",
        "tsql": "STRING_AGG(x, z) WITHIN GROUP (ORDER BY y)",
        "databricks": "LISTAGG(x, z) WITHIN GROUP (ORDER BY y)",
        "postgres": "STRING_AGG(x, z ORDER BY y NULLS FIRST)"
      }
    },
    {
      "sql": "GROUP_CONCAT(DISTINCT x ORDER BY y DESC SEPARATOR '')",
      "read": {},
      "write": {
        "mysql": "GROUP_CONCAT(DISTINCT x ORDER BY y DESC SEPARATOR '')",
        "sqlite": "GROUP_CONCAT(DISTINCT x, '')",
        "tsql": "STRING_AGG(x, '') WITHIN GROUP (ORDER BY y DESC)",
        "databricks": "LISTAGG(DISTINCT x, '') WITHIN GROUP (ORDER BY y DESC)",
        "postgres": "STRING_AGG(DISTINCT x, '' ORDER BY y DESC NULLS LAST)"
      }
    },
    {
      "sql": "GROUP_CONCAT(a, b, c SEPARATOR ',')",
      "read": {},
      "write": {
        "mysql": "GROUP_CONCAT(CONCAT(a, b, c) SEPARATOR ',')",
        "sqlite": "GROUP_CONCAT(a || b || c, ',')",
        "tsql": "STRING_AGG(a + b + c, ',')",
        "postgres": "STRING_AGG(a || b || c, ',')",
        "databricks": "LISTAGG(CONCAT(a, b, c), ',')",
        "presto": "ARRAY_JOIN(ARRAY_AGG(CONCAT(CAST(a AS VARCHAR), CAST(b AS VARCHAR), CAST(c AS VARCHAR))), ',')"
      }
    },
    {
      "sql": "GROUP_CONCAT(a, b, c SEPARATOR '')",
      "read": {},
      "write": {
        "mysql": "GROUP_CONCAT(CONCAT(a, b, c) SEPARATOR '')",
        "sqlite": "GROUP_CONCAT(a || b || c, '')",
        "tsql": "STRING_AGG(a + b + c, '')",
        "databricks": "LISTAGG(CONCAT(a, b, c), '')",
        "postgres": "STRING_AGG(a || b || c, '')"
      }
    },
    {
      "sql": "GROUP_CONCAT(DISTINCT a, b, c SEPARATOR '')",
      "read": {},
      "write": {
        "mysql": "GROUP_CONCAT(DISTINCT CONCAT(a, b, c) SEPARATOR '')",
        "sqlite": "GROUP_CONCAT(DISTINCT a || b || c, '')",
        "tsql": "STRING_AGG(a + b + c, '')",
        "databricks": "LISTAGG(DISTINCT CONCAT(a, b, c), '')",
        "postgres": "STRING_AGG(DISTINCT a || b || c, '')"
      }
    },
    {
      "sql": "GROUP_CONCAT(a, b, c ORDER BY d SEPARATOR '')",
      "read": {},
      "write": {
        "mysql": "GROUP_CONCAT(CONCAT(a, b, c) ORDER BY d SEPARATOR '')",
        "sqlite": "GROUP_CONCAT(a || b || c, '')",
        "tsql": "STRING_AGG(a + b + c, '') WITHIN GROUP (ORDER BY d)",
        "databricks": "LISTAGG(CONCAT(a, b, c), '') WITHIN GROUP (ORDER BY d)",
        "postgres": "STRING_AGG(a || b || c, '' ORDER BY d NULLS FIRST)"
      }
    },
    {
      "sql": "GROUP_CONCAT(DISTINCT a, b, c ORDER BY d SEPARATOR '')",
      "read": {},
      "write": {
        "mysql": "GROUP_CONCAT(DISTINCT CONCAT(a, b, c) ORDER BY d SEPARATOR '')",
        "sqlite": "GROUP_CONCAT(DISTINCT a || b || c, '')",
        "tsql": "STRING_AGG(a + b + c, '') WITHIN GROUP (ORDER BY d)",
        "databricks": "LISTAGG(DISTINCT CONCAT(a, b, c), '') WITHIN GROUP (ORDER BY d)",
        "postgres": "STRING_AGG(DISTINCT a || b || c, '' ORDER BY d NULLS FIRST)"
      }
    },
    {
      "sql": "\n            CREATE TABLE `t_customer_account` (\n              `id` int(11) NOT NULL AUTO_INCREMENT,\n              `customer_id` int(11) DEFAULT NULL COMMENT '客户id',\n              `bank` varchar(100) COLLATE utf8_bin DEFAULT NULL COMMENT '行别',\n              `account_no` varchar(100) COLLATE utf8_bin DEFAULT NULL COMMENT '账号',\n              PRIMARY KEY (`id`)\n            ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARACTER SET=utf8 COLLATE=utf8_bin COMMENT='客户账户表'\n            ",
      "read": {},
      "write": {
        "mysql": "CREATE TABLE `t_customer_account` (\n  `id` INT(11) NOT NULL AUTO_INCREMENT,\n  `customer_id` INT(11) DEFAULT NULL COMMENT '客户id',\n  `bank` VARCHAR(100) COLLATE utf8_bin DEFAULT NULL COMMENT '行别',\n  `account_no` VARCHAR(100) COLLATE utf8_bin DEFAULT NULL COMMENT '账号',\n  PRIMARY KEY (`id`)\n)\nENGINE=InnoDB\nAUTO_INCREMENT=1\nDEFAULT CHARACTER SET=utf8\nCOLLATE=utf8_bin\nCOMMENT='客户账户表'"
      }
    },
    {
      "sql": "SHOW INDEX FROM bar.foo",
      "read": {},
      "write": {
        "mysql": "SHOW INDEX FROM foo FROM bar"
      }
    },
    {
      "sql": "SELECT ISNULL(x)",
      "read": {},
      "write": {
        "mysql": "SELECT (x IS NULL)"
      }
    },
    {
      "sql": "MONTHNAME(x)",
      "read": {},
      "write": {
        "mysql": "DATE_FORMAT(x, '%M')"
      }
    },
    {
      "sql": "a / b",
      "read": {},
      "write": {
        "bigquery": "a / NULLIF(b, 0)",
        "clickhouse": "a / b",
        "databricks": "a / NULLIF(b, 0)",
        "duckdb": "a / b",
        "hive": "a / b",
        "mysql": "a / b",
        "oracle": "a / NULLIF(b, 0)",
        "snowflake": "a / NULLIF(b, 0)",
        "spark": "a / b",
        "starrocks": "a / b",
        "drill": "CAST(a AS DOUBLE) / NULLIF(b, 0)",
        "postgres": "CAST(a AS DOUBLE PRECISION) / NULLIF(b, 0)",
        "presto": "CAST(a AS DOUBLE) / NULLIF(b, 0)",
        "redshift": "CAST(a AS DOUBLE PRECISION) / NULLIF(b, 0)",
        "sqlite": "CAST(a AS REAL) / b",
        "teradata": "CAST(a AS DOUBLE PRECISION) / NULLIF(b, 0)",
        "trino": "CAST(a AS DOUBLE) / NULLIF(b, 0)",
        "tsql": "CAST(a AS FLOAT) / NULLIF(b, 0)"
      }
    },
    {
      "sql": "SELECT FORMAT(12332.123456, 4)",
      "read": {},
      "write": {
        "duckdb": "SELECT FORMAT('{:,.4f}', 12332.123456)",
        "mysql": "SELECT FORMAT(12332.123456, 4)"
      }
    },
    {
      "sql": "SELECT FORMAT(12332.1, 4)",
      "read": {},
      "write": {
        "duckdb": "SELECT FORMAT('{:,.4f}', 12332.1)",
        "mysql": "SELECT FORMAT(12332.1, 4)"
      }
    },
    {
      "sql": "SELECT FORMAT(12332.2, 0)",
      "read": {},
      "write": {
        "duckdb": "SELECT FORMAT('{:,.0f}', 12332.2)",
        "mysql": "SELECT FORMAT(12332.2, 0)"
      }
    },
    {
      "sql": "SELECT FORMAT(12332.2, 2, 'de_DE')",
      "read": {},
      "write": {
        "mysql": "SELECT FORMAT(12332.2, 2, 'de_DE')"
      }
    }
  ]
}